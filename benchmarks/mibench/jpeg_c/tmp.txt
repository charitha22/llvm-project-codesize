/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jcmarker.c -o src/jcmarker.o   -mllvm -reroll-loops=3
Optimizing: jinit_marker_writer
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_compress_struct*, i32, i8*, i32)* @write_any_marker, void (%struct.jpeg_compress_struct*, i32, i8*, i32)** %write_any_marker, align 8, !tbaa !14
Attempting Group:
  store i8* %call, i8** %3, align 8, !tbaa !13
Done Loop Roller: 0/0
Nothing found in: jinit_marker_writer
Optimizing: emit_byte
looking for reduction
looking for reduction
looking for reduction
  %dec = add i64 %2, -1
looking for reduction
Attempting Group:
  store i8 %conv, i8* %1, align 1, !tbaa !13
Attempting Group:
  store i8* %incdec.ptr, i8** %next_output_byte, align 8, !tbaa !10
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 22, i32* %msg_code, align 8, !tbaa !17
looking for reduction
Done Loop Roller: 0/0
Nothing found in: emit_byte
Optimizing: emit_marker
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 255) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %mark) #1
Creating Node
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 255) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %mark) #1
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
i32 255
i32 %mark
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 255
Alt Seq
Creating Node
Function: emit_byte
Function: emit_byte
Match: 1
1 x 2
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 255) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %mark) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 255) #1
}
Count: 1
Start:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 255) #1
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 255) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 255) #1
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %mark) #1
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %mark) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %mark) #1
I:   ret void
Last:   ret void
Schedulable: 1
Loop Rolling: emit_marker
Generating tree
Generating MATCH
Match: 
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 255) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %mark) #1
Generating IDENTICAL
Generating ALTSEQ
Values:
i32 255
i32 %mark
Generated Version 4:
  %1 = icmp eq i8 %0, 0
  %2 = select i1 %1, i32 255, i32 %mark
Generating IDENTICAL
Operands done!
Generated:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %2) #1
Gen:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %2) #1
Graph code generated!
Root:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 255) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %mark) #1
Root size: 2
digraph VTree {
0 [label="call: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: 255, %mark", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="func: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->0 
}

Gains: 6 - 6 = 0; Width: 2; Unprofitable; emit_marker
Done Loop Roller: 0/1
Optimizing: emit_2bytes
looking for reduction
looking for reduction
  %and = and i32 %0, 255
looking for reduction
looking for reduction
  %and1 = and i32 %value, 255
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and1) #1
Creating Node
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and1) #1
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %and = and i32 %0, 255
  %and1 = and i32 %value, 255
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %0 = lshr i32 %value, 8
i32 %value
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %0 = lshr i32 %value, 8
Alt Seq
Creating Node
i32 255
i32 255
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
Function: emit_byte
Function: emit_byte
Match: 1
1 x 2
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and1) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and) #1
}
Count: 1
Start:   %and = and i32 %0, 255
Non-memory:   %and = and i32 %0, 255
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and) #1
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and1) #1
}
Non-memory:   %and1 = and i32 %value, 255
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and1) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and1) #1
I:   ret void
Last:   ret void
Schedulable: 1
Loop Rolling: emit_2bytes
Generating tree
Generating MATCH
Match: 
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and1) #1
Generating IDENTICAL
Generating MATCH
Match: 
  %and = and i32 %0, 255
  %and1 = and i32 %value, 255
Generating ALTSEQ
Values:
  %0 = lshr i32 %value, 8
i32 %value
Generated Version 4:
  %2 = icmp eq i8 %1, 0
  %3 = select i1 %2, i32 %0, i32 %value
Generating IDENTICAL
Operands done!
Generated:   %4 = and i32 %3, 255
Gen:   %4 = and i32 %3, 255
Generating IDENTICAL
Operands done!
Generated:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %4) #1
Gen:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %4) #1
Graph code generated!
Root:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and1) #1
Root size: 2
digraph VTree {
0 [label="call: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="and", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %0, %value", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="255", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="func: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
5->0 
3->2 
4->2 
}

Gains: 10 - 8 = 2; Width: 2; Unprofitable; emit_2bytes
Done Loop Roller: 0/1
Optimizing: write_any_marker
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add = add nuw nsw i32 %datalen, 2
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %add) #1
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 %marker) #1
  %dataptr.addr.0 = phi i8* [ %dataptr, %if.then ], [ %incdec.ptr, %while.body ]
  %datalen.addr.0 = phi i32 [ %datalen, %if.then ], [ %dec, %while.body ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %conv) #1
looking for reduction
Done Loop Roller: 0/0
Nothing found in: write_any_marker
Optimizing: emit_jfif_app0
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 74) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 73) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %conv) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 224) #1
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 16) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %conv1) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %conv2) #1
Creating Node
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 74) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 73) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %conv) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
Match: 1
10 x 10
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 10
Final Match: 1
All the Same
Creating Node
i32 74
i32 70
i32 73
i32 70
i32 0
i32 1
i32 1
  %conv = zext i8 %0 to i32
i32 0
i32 0
Match: 0
6 x 10
Final Match: 0
GEPSeq2
BinOP?
i32 74
Mismatching
Creating Node
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Match: 1
1 x 10
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 74) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 73) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %conv) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 74) #1
}
Count: 1
Start:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 74) #1
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 74) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 74) #1
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 73) #1
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 73) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 73) #1
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %conv) #1
}
Non-memory:   %density_unit = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 32
Processing:   %0 = load i8, i8* %density_unit, align 4, !tbaa !2
Count: 1
Not found:   %0 = load i8, i8* %density_unit, align 4, !tbaa !2
Read/Write memory
I:   %0 = load i8, i8* %density_unit, align 4, !tbaa !2
Last:   ret void
Schedulable: 0
digraph VTree {
0 [label="call: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="func: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->0 
}


entry:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 224) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 16) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 74) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 73) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
  %density_unit = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 32
  %0 = load i8, i8* %density_unit, align 4, !tbaa !2
  %conv = zext i8 %0 to i32
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %conv) #1
  %X_density = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 33
  %1 = load i16, i16* %X_density, align 2, !tbaa !10
  %conv1 = zext i16 %1 to i32
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %conv1) #1
  %Y_density = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 34
  %2 = load i16, i16* %Y_density, align 8, !tbaa !11
  %conv2 = zext i16 %2 to i32
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %conv2) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  ret void

Creating Node
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 16) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %conv1) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %conv2) #1
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
i32 16
  %conv1 = zext i16 %1 to i32
  %conv2 = zext i16 %2 to i32
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i32 16
Mismatching
Creating Node
Function: emit_2bytes
Function: emit_2bytes
Function: emit_2bytes
Match: 1
1 x 3
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 16) #1
}
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %conv1) #1
}
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %conv2) #1
}
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 16) #1
}
Count: 1
Start:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 16) #1
Processing:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 16) #1
Count: 1
Found:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 16) #1
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %conv1) #1
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 74) #1
Count: 1
Not found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 74) #1
Read/Write memory
I:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 74) #1
Last:   ret void
Schedulable: 0
digraph VTree {
0 [label="call: emit_2bytes", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="func: emit_2bytes", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->0 
}


entry:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 224) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 16) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 74) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 73) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 70) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 1) #1
  %density_unit = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 32
  %0 = load i8, i8* %density_unit, align 4, !tbaa !2
  %conv = zext i8 %0 to i32
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %conv) #1
  %X_density = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 33
  %1 = load i16, i16* %X_density, align 2, !tbaa !10
  %conv1 = zext i16 %1 to i32
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %conv1) #1
  %Y_density = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 34
  %2 = load i16, i16* %Y_density, align 8, !tbaa !11
  %conv2 = zext i16 %2 to i32
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %conv2) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  ret void

Done Loop Roller: 0/0
Nothing found in: emit_jfif_app0
Optimizing: emit_adobe_app14
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 65) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 100) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 111) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 98) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 101) #1
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 238) #1
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 14) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 100) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
Creating Node
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 65) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 100) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 111) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 98) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 101) #1
Match: 1
5 x 5
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 5
Final Match: 1
All the Same
Creating Node
i32 65
i32 100
i32 111
i32 98
i32 101
Match: 0
5 x 5
Final Match: 0
GEPSeq2
BinOP?
i32 65
Mismatching
Creating Node
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Match: 1
1 x 5
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 65) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 100) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 111) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 98) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 101) #1
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 65) #1
}
Count: 1
Start:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 65) #1
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 65) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 65) #1
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 100) #1
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 100) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 100) #1
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 111) #1
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 111) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 111) #1
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 98) #1
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 98) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 98) #1
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 101) #1
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 101) #1
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 101) #1
I:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 100) #1
Last:   switch i32 %0, label %sw.default [
    i32 3, label %sw.bb
    i32 5, label %sw.bb1
  ]
Schedulable: 1
Loop Rolling: emit_adobe_app14
Generating tree
Generating MATCH
Match: 
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 65) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 100) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 111) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 98) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 101) #1
Generating IDENTICAL
Generating Mismatch
Mismatched Values:
int: i32 65
int: i32 100
int: i32 111
int: i32 98
int: i32 101
All constants
Created array: @0 = private constant [5 x i32] [i32 65, i32 100, i32 111, i32 98, i32 101]
Gen:   %3 = load i32, i32* %2, align 4
Generating IDENTICAL
Operands done!
Generated:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %3) #1
Gen:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %3) #1
Graph code generated!
Root:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 65) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 100) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 111) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 98) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 101) #1
Root size: 5
digraph VTree {
0 [label="call: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="func: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->0 
}

Gains: 15 - 9 = 6; Width: 5; Profitable; emit_adobe_app14

entry:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 238) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 14) #1
  br label %rolled.pre


rolled.pre:                                       ; preds = %entry
  br label %rolled.loop


rolled.loop:                                      ; preds = %rolled.pre, %rolled.loop
  %0 = phi i8 [ 0, %rolled.pre ], [ %3, %rolled.loop ]
  %1 = getelementptr [5 x i32], [5 x i32]* @0, i8 0, i8 %0
  %2 = load i32, i32* %1, align 4
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %2) #1
  %3 = add i8 %0, 1
  %4 = icmp ne i8 %3, 5
  br i1 %4, label %rolled.loop, label %rolled.exit


rolled.exit:                                      ; preds = %rolled.loop
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 65) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 100) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 111) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 98) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 101) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 100) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  %5 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 13
  %6 = load i32, i32* %5, align 8, !tbaa !2
  switch i32 %6, label %sw.default [
    i32 3, label %sw.bb
    i32 5, label %sw.bb1
  ]

Done!
Creating Node
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 14) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 100) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #1
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 14) #1
Mismatching
Empty scheduling entries
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 1/2
Optimizing: write_file_header
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 216) #1
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 74) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 73) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv.i) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* nonnull %cinfo, i32 224) #2
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 16) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv1.i) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv2.i) #2
Creating Node
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 74) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 73) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv.i) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
Match: 1
10 x 10
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 10
Final Match: 1
All the Same
Creating Node
i32 74
i32 70
i32 73
i32 70
i32 0
i32 1
i32 1
  %conv.i = zext i8 %1 to i32
i32 0
i32 0
Match: 0
6 x 10
Final Match: 0
GEPSeq2
BinOP?
i32 74
Mismatching
Creating Node
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Function: emit_byte
Match: 1
1 x 10
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 74) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 73) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv.i) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 74) #2
}
Count: 1
Start:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 74) #2
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 74) #2
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 74) #2
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 73) #2
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 73) #2
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 73) #2
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv.i) #2
}
Non-memory:   %density_unit.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 32
Processing:   %1 = load i8, i8* %density_unit.i, align 4, !tbaa !10
Count: 1
Not found:   %1 = load i8, i8* %density_unit.i, align 4, !tbaa !10
Read/Write memory
I:   %1 = load i8, i8* %density_unit.i, align 4, !tbaa !10
Last:   br label %if.end
Schedulable: 0
digraph VTree {
0 [label="call: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="func: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->0 
}


if.then:                                          ; preds = %entry
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* nonnull %cinfo, i32 224) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 16) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 74) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 73) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
  %density_unit.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 32
  %1 = load i8, i8* %density_unit.i, align 4, !tbaa !10
  %conv.i = zext i8 %1 to i32
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv.i) #2
  %X_density.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 33
  %2 = load i16, i16* %X_density.i, align 2, !tbaa !11
  %conv1.i = zext i16 %2 to i32
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv1.i) #2
  %Y_density.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 34
  %3 = load i16, i16* %Y_density.i, align 8, !tbaa !12
  %conv2.i = zext i16 %3 to i32
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv2.i) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
  br label %if.end

Creating Node
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 16) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv1.i) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv2.i) #2
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
i32 16
  %conv1.i = zext i16 %2 to i32
  %conv2.i = zext i16 %3 to i32
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i32 16
Mismatching
Creating Node
Function: emit_2bytes
Function: emit_2bytes
Function: emit_2bytes
Match: 1
1 x 3
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 16) #2
}
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv1.i) #2
}
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv2.i) #2
}
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 16) #2
}
Count: 1
Start:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 16) #2
Processing:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 16) #2
Count: 1
Found:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 16) #2
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv1.i) #2
}
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 74) #2
Count: 1
Not found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 74) #2
Read/Write memory
I:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 74) #2
Last:   br label %if.end
Schedulable: 0
digraph VTree {
0 [label="call: emit_2bytes", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="func: emit_2bytes", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->0 
}


if.then:                                          ; preds = %entry
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* nonnull %cinfo, i32 224) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 16) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 74) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 73) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 70) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
  %density_unit.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 32
  %1 = load i8, i8* %density_unit.i, align 4, !tbaa !10
  %conv.i = zext i8 %1 to i32
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv.i) #2
  %X_density.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 33
  %2 = load i16, i16* %X_density.i, align 2, !tbaa !11
  %conv1.i = zext i16 %2 to i32
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv1.i) #2
  %Y_density.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 34
  %3 = load i16, i16* %Y_density.i, align 8, !tbaa !12
  %conv2.i = zext i16 %3 to i32
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %conv2.i) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
  br label %if.end

looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 14) #2
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* nonnull %cinfo, i32 238) #2
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 1) #2
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 2) #2
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #2
  %indvars.iv = phi i64 [ %indvars.iv.next, %rolled.loop.i ], [ 0, %if.then2 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
looking for reduction
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %6) #2
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 100) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
Creating Node
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 100) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
i32 100
i32 0
i32 0
Match: 0
2 x 3
Final Match: 0
GEPSeq2
BinOP?
i32 100
Mismatching
Creating Node
Function: emit_2bytes
Function: emit_2bytes
Function: emit_2bytes
Match: 1
1 x 3
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 100) #2
}
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
}
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
}
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 100) #2
}
Count: 1
Start:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 100) #2
Processing:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 100) #2
Count: 1
Found:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 100) #2
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
}
Processing:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
Count: 1
Found:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
}
Processing:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
Count: 1
Found:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
I:   %7 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 13
Last:   switch i32 %8, label %sw.default.i [
    i32 3, label %sw.bb.i
    i32 5, label %sw.bb1.i
  ]
Schedulable: 1
Loop Rolling: write_file_header
Generating tree
Generating MATCH
Match: 
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 100) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
Generating IDENTICAL
Generating Mismatch
Mismatched Values:
int: i32 100
int: i32 0
int: i32 0
All constants
Created array: @1 = private constant [3 x i32] [i32 100, i32 0, i32 0]
Gen:   %11 = load i32, i32* %10, align 4
Generating IDENTICAL
Operands done!
Generated:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %11) #2
Gen:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %11) #2
Graph code generated!
Root:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 100) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 0) #2
Root size: 3
digraph VTree {
0 [label="call: emit_2bytes", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="func: emit_2bytes", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->0 
}

Gains: 9 - 9 = 0; Width: 3; Unprofitable; write_file_header
looking for reduction
Done Loop Roller: 0/1
Optimizing: emit_dqt
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 51, i32* %msg_code, align 8, !tbaa !11
  store i32 %index, i32* %arrayidx3, align 4, !tbaa !14
Creating Node
  store i32 51, i32* %msg_code, align 8, !tbaa !11
  store i32 %index, i32* %arrayidx3, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 51
i32 %index
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 51
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx3 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx3 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 51, i32* %msg_code, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %index, i32* %arrayidx3, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 51, i32* %msg_code, align 8, !tbaa !11
}
Count: 1
Start:   store i32 51, i32* %msg_code, align 8, !tbaa !11
Processing:   store i32 51, i32* %msg_code, align 8, !tbaa !11
Count: 1
Found:   store i32 51, i32* %msg_code, align 8, !tbaa !11
ScheduleNode: {
  store i32 %index, i32* %arrayidx3, align 4, !tbaa !14
}
Non-memory:   %arrayidx3 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %index, i32* %arrayidx3, align 4, !tbaa !14
Count: 1
Found:   store i32 %index, i32* %arrayidx3, align 4, !tbaa !14
I:   %2 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !6
Last:   br label %if.end
Schedulable: 1
Loop Rolling: emit_dqt
Generating tree
Generating MATCH
Match: 
  store i32 51, i32* %msg_code, align 8, !tbaa !11
  store i32 %index, i32* %arrayidx3, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 51
i32 %index
Generated Version 4:
  %10 = icmp eq i8 %9, 0
  %11 = select i1 %10, i32 51, i32 %index
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx3 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %12 = select i1 %10, i32* %msg_code, i32* %arrayidx3
Operands done!
Generated:   store i32 %11, i32* %12, align 1
Gen:   store i32 %11, i32* %12, align 1
Graph code generated!
Root:
  store i32 51, i32* %msg_code, align 8, !tbaa !11
  store i32 %index, i32* %arrayidx3, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 51, %index", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx3", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; emit_dqt
Trying AGAIN
Trying AGAIN
  %indvars.iv60 = phi i64 [ %indvars.iv.next61, %for.body ], [ 0, %if.end ]
  %prec.0 = phi i32 [ %spec.select, %for.body ], [ 0, %if.end ]
looking for reduction
  %prec.0.lcssa = phi i32 [ %prec.0, %for.cond ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add = add nsw i32 %shl, %index
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %add) #2
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 219) #2
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %cond) #2
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end26 ], [ 0, %if.then12 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %shr = lshr i32 %conv23, 8
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %shr) #2
looking for reduction
looking for reduction
  %and = and i32 %conv23, 255
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %and) #2
looking for reduction
Attempting Group:
  store i32 1, i32* %sent_table, align 4, !tbaa !19
looking for reduction
Done Loop Roller: 0/1
Optimizing: emit_sof
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add2 = add nsw i32 %mul, 8
looking for reduction
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %add2) #1
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 %code) #1
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 40, i32* %msg_code, align 8, !tbaa !13
  store i32 65535, i32* %arrayidx, align 4, !tbaa !16
Creating Node
  store i32 40, i32* %msg_code, align 8, !tbaa !13
  store i32 65535, i32* %arrayidx, align 4, !tbaa !16
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 40
i32 65535
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 40
Int Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 40, i32* %msg_code, align 8, !tbaa !13
}
ScheduleNode: {
  store i32 65535, i32* %arrayidx, align 4, !tbaa !16
}
ScheduleNode: {
  store i32 40, i32* %msg_code, align 8, !tbaa !13
}
Count: 1
Start:   store i32 40, i32* %msg_code, align 8, !tbaa !13
Processing:   store i32 40, i32* %msg_code, align 8, !tbaa !13
Count: 1
Found:   store i32 40, i32* %msg_code, align 8, !tbaa !13
ScheduleNode: {
  store i32 65535, i32* %arrayidx, align 4, !tbaa !16
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 65535, i32* %arrayidx, align 4, !tbaa !16
Count: 1
Found:   store i32 65535, i32* %arrayidx, align 4, !tbaa !16
I:   %4 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !12
Last:   br label %if.end
Schedulable: 1
Loop Rolling: emit_sof
Generating tree
Generating MATCH
Match: 
  store i32 40, i32* %msg_code, align 8, !tbaa !13
  store i32 65535, i32* %arrayidx, align 4, !tbaa !16
Generating INTSEQ
Gen:   %20 = add i32 %19, 40
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %21 = icmp eq i8 %17, 0
  %22 = select i1 %21, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %20, i32* %22, align 1
Gen:   store i32 %20, i32* %22, align 1
Graph code generated!
Root:
  store i32 40, i32* %msg_code, align 8, !tbaa !13
  store i32 65535, i32* %arrayidx, align 4, !tbaa !16
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="40..65535, 65495", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; emit_sof
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %8) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %9) #1
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %7) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %10) #1
Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %8) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %9) #1
Creating Node
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %7) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %10) #1
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %7 = load i32, i32* %data_precision, align 8, !tbaa !18
  %10 = load i32, i32* %num_components, align 4, !tbaa !2
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %data_precision = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 11
  %num_components = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 12
Match: 0
2 x 2
Final Match: 0
  %data_precision = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 11
  %num_components = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 12
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %data_precision = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 11
Alt Seq
Creating Node
Function: emit_byte
Function: emit_byte
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %8) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %9) #1
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %8 = load i32, i32* %image_height, align 4, !tbaa !10
  %9 = load i32, i32* %image_width10, align 8, !tbaa !11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
  %image_width10 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
Match: 0
2 x 2
Final Match: 0
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
  %image_width10 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
Alt Seq
Creating Node
Function: emit_2bytes
Function: emit_2bytes
Match: 1
1 x 2
Final Match: 1
All the Same
Empty scheduling entries
Loop Rolling: emit_sof
Generating tree
Generating MULTI
Generating MATCH
Match: 
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %7) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %10) #1
Generating IDENTICAL
Generating MATCH
Match: 
  %7 = load i32, i32* %data_precision, align 8, !tbaa !18
  %10 = load i32, i32* %num_components, align 4, !tbaa !2
Generating ALTSEQ
Values:
  %data_precision = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 11
  %num_components = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 12
Generated Version 4:
  %18 = icmp eq i8 %17, 0
  %19 = select i1 %18, i32* %data_precision, i32* %num_components
Operands done!
Generated:   %20 = load i32, i32* %19, align 1
Gen:   %20 = load i32, i32* %19, align 1
Generating IDENTICAL
Operands done!
Generated:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %20) #1
Gen:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %20) #1
Generating MATCH
Match: 
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %8) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %9) #1
Generating IDENTICAL
Generating MATCH
Match: 
  %8 = load i32, i32* %image_height, align 4, !tbaa !10
  %9 = load i32, i32* %image_width10, align 8, !tbaa !11
Generating ALTSEQ
Values:
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
  %image_width10 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
Generated Version 4:
  %21 = select i1 %18, i32* %image_height, i32* %image_width10
Operands done!
Generated:   %22 = load i32, i32* %21, align 1
Gen:   %22 = load i32, i32* %21, align 1
Generating IDENTICAL
Operands done!
Generated:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %22) #1
Gen:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %22) #1
Graph code generated!
Root:
Root size: 0
digraph VTree {
0 [label="call: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %data_precision, %num_components", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="func: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="call: emit_2bytes", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %image_height, %image_width10", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="func: emit_2bytes", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
4->0 
3->2 
1->5 
6->5 
8->5 
7->6 
}

Gains: 20 - 15 = 5; Width: 0; Profitable; emit_sof

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %data_precision = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 11
  %7 = load i32, i32* %data_precision, align 8, !tbaa !18
  %8 = load i32, i32* %image_height, align 4, !tbaa !10
  %image_width10 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %9 = load i32, i32* %image_width10, align 8, !tbaa !11
  %10 = load i32, i32* %num_components, align 4, !tbaa !2
  br label %rolled.pre


rolled.pre:                                       ; preds = %if.end
  br label %rolled.loop


rolled.loop:                                      ; preds = %rolled.pre, %rolled.loop
  %16 = phi i8 [ 0, %rolled.pre ], [ %22, %rolled.loop ]
  %17 = icmp eq i8 %16, 0
  %18 = select i1 %17, i32* %data_precision, i32* %num_components
  %19 = load i32, i32* %18, align 1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %19) #1
  %20 = select i1 %17, i32* %image_height, i32* %image_width10
  %21 = load i32, i32* %20, align 1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %21) #1
  %22 = add i8 %16, 1
  %23 = icmp ne i8 %22, 2
  br i1 %23, label %rolled.loop, label %rolled.exit


rolled.exit:                                      ; preds = %rolled.loop
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %7) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %8) #1
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %9) #1
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %10) #1
  %24 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 14
  %25 = load %struct.jpeg_component_info*, %struct.jpeg_component_info** %24, align 8, !tbaa !26
  br label %for.cond

Done!
  %ci.0 = phi i32 [ 0, %rolled.exit ], [ %inc, %for.body ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %21, %rolled.exit ], [ %incdec.ptr, %for.body ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add15 = add nsw i32 %shl, %10
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 1/2
Optimizing: write_frame_header
  %ci.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %prec.0 = phi i32 [ 0, %entry ], [ %add, %for.body ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %0, %entry ], [ %incdec.ptr, %for.body ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  %call = tail call fastcc i32 @emit_dqt(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %2) #1
  %prec.0.lcssa = phi i32 [ %prec.0, %for.cond ]
  %.lcssa = phi i32 [ %1, %for.cond ]
looking for reduction
looking for reduction
looking for reduction
  %ci.1 = phi i32 [ 0, %if.else ], [ %inc14, %for.inc13 ]
  %is_baseline.0 = phi i32 [ 1, %if.else ], [ %is_baseline.1, %for.inc13 ]
  %compptr.1 = phi %struct.jpeg_component_info* [ %6, %if.else ], [ %incdec.ptr15, %for.inc13 ]
looking for reduction
looking for reduction
looking for reduction
  %is_baseline.1 = phi i32 [ 0, %if.then12 ], [ %is_baseline.0, %lor.lhs.false10 ]
  %is_baseline.0.lcssa = phi i32 [ %is_baseline.0, %for.cond5 ]
looking for reduction
  %or.cond = and i1 %tobool17, %tobool18
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 74, i32* %msg_code, align 8, !tbaa !22
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_sof(%struct.jpeg_compress_struct* nonnull %cinfo, i32 201) #1
  %is_baseline.2.ph.ph.ph = phi i32 [ 0, %lor.lhs.false2 ], [ %is_baseline.0.lcssa, %for.end16 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_sof(%struct.jpeg_compress_struct* nonnull %cinfo, i32 194) #1
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_sof(%struct.jpeg_compress_struct* nonnull %cinfo, i32 192) #1
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_sof(%struct.jpeg_compress_struct* nonnull %cinfo, i32 193) #1
looking for reduction
Done Loop Roller: 0/0
Nothing found in: write_frame_header
Optimizing: emit_dac
looking for reduction
Done Loop Roller: 0/0
Nothing found in: emit_dac
Optimizing: emit_dht
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 49, i32* %msg_code, align 8, !tbaa !11
  store i32 %index.addr.0, i32* %arrayidx6, align 4, !tbaa !14
Creating Node
  store i32 49, i32* %msg_code, align 8, !tbaa !11
  store i32 %index.addr.0, i32* %arrayidx6, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 49
  %index.addr.0 = select i1 %tobool.not, i32 %index, i32 %add
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 49
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 5
  %arrayidx6 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 5
  %arrayidx6 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 49, i32* %msg_code, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %index.addr.0, i32* %arrayidx6, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 49, i32* %msg_code, align 8, !tbaa !11
}
Count: 1
Start:   store i32 49, i32* %msg_code, align 8, !tbaa !11
Processing:   store i32 49, i32* %msg_code, align 8, !tbaa !11
Count: 1
Found:   store i32 49, i32* %msg_code, align 8, !tbaa !11
ScheduleNode: {
  store i32 %index.addr.0, i32* %arrayidx6, align 4, !tbaa !14
}
Non-memory:   %arrayidx6 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %index.addr.0, i32* %arrayidx6, align 4, !tbaa !14
Count: 1
Found:   store i32 %index.addr.0, i32* %arrayidx6, align 4, !tbaa !14
I:   %1 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !6
Last:   br label %if.end8
Schedulable: 1
Loop Rolling: emit_dht
Generating tree
Generating MATCH
Match: 
  store i32 49, i32* %msg_code, align 8, !tbaa !11
  store i32 %index.addr.0, i32* %arrayidx6, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 49
  %index.addr.0 = select i1 %tobool.not, i32 %index, i32 %add
Generated Version 4:
  %9 = icmp eq i8 %8, 0
  %10 = select i1 %9, i32 49, i32 %index.addr.0
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 5
  %arrayidx6 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %11 = select i1 %9, i32* %msg_code, i32* %arrayidx6
Operands done!
Generated:   store i32 %10, i32* %11, align 1
Gen:   store i32 %10, i32* %11, align 1
Graph code generated!
Root:
  store i32 49, i32* %msg_code, align 8, !tbaa !11
  store i32 %index.addr.0, i32* %arrayidx6, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 49, %index.addr.0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx6", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; emit_dht
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 196) #3
  %indvars.iv76 = phi i64 [ %indvars.iv.next77, %for.body ], [ 1, %if.then10 ]
  %length.0 = phi i32 [ %add14, %for.body ], [ 0, %if.then10 ]
looking for reduction
  %length.0.lcssa = phi i32 [ %length.0, %for.cond ]
looking for reduction
looking for reduction
  %add17 = add nuw nsw i32 %length.0.lcssa, 19
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %index.addr.0) #3
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %add17) #3
  %indvars.iv73 = phi i64 [ %indvars.iv.next74, %for.body21 ], [ 1, %for.end ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %conv25) #3
  %indvars.iv = phi i64 [ 0, %for.cond29.preheader ], [ %indvars.iv.next, %for.body32 ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %conv35) #3
looking for reduction
Attempting Group:
  store i32 1, i32* %sent_table, align 4, !tbaa !16
looking for reduction
Done Loop Roller: 0/1
Optimizing: emit_dri
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 4) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %0) #2
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 221) #2
Creating Node
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 4) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %0) #2
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
i32 4
  %0 = load i32, i32* %restart_interval, align 8, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 4
Alt Seq
Creating Node
Function: emit_2bytes
Function: emit_2bytes
Match: 1
1 x 2
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 4) #2
}
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %0) #2
}
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 4) #2
}
Count: 1
Start:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 4) #2
Processing:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 4) #2
Count: 1
Found:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 4) #2
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %0) #2
}
Non-memory:   %restart_interval = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 29
Processing:   %0 = load i32, i32* %restart_interval, align 8, !tbaa !2
Count: 1
Not found:   %0 = load i32, i32* %restart_interval, align 8, !tbaa !2
Read/Write memory
I:   %0 = load i32, i32* %restart_interval, align 8, !tbaa !2
Last:   ret void
Schedulable: 0
digraph VTree {
0 [label="call: emit_2bytes", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: 4, %0", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="func: emit_2bytes", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->0 
}


entry:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 221) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 4) #2
  %restart_interval = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 29
  %0 = load i32, i32* %restart_interval, align 8, !tbaa !2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %0) #2
  ret void

Done Loop Roller: 0/0
Nothing found in: emit_dri
Optimizing: emit_sos
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add2 = add nsw i32 %mul, 6
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* %cinfo, i32 %1) #2
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 218) #2
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* %cinfo, i32 %add2) #2
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end11 ], [ 0, %entry ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %5) #2
looking for reduction
looking for reduction
  %td.0 = phi i32 [ %6, %if.then6 ], [ %6, %for.body ], [ %spec.select, %land.lhs.true ], [ 0, %if.then ]
  %ta.0 = phi i32 [ 0, %if.then6 ], [ %7, %for.body ], [ 0, %land.lhs.true ], [ %7, %if.then ]
looking for reduction
looking for reduction
  %add12 = add nsw i32 %shl, %ta.0
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %add12) #2
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add16 = add nsw i32 %shl15, %15
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %12) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %13) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %add16) #2
Creating Node
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %12) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %13) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %add16) #2
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
  %12 = load i32, i32* %Ss, align 4, !tbaa !16
  %13 = load i32, i32* %Se, align 8, !tbaa !21
  %add16 = add nsw i32 %shl15, %15
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %12 = load i32, i32* %Ss, align 4, !tbaa !16
BinOp Seq
Creating Node
  %12 = load i32, i32* %Ss, align 4, !tbaa !16
  %13 = load i32, i32* %Se, align 8, !tbaa !21
  %shl15 = shl i32 %14, 4
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %12 = load i32, i32* %Ss, align 4, !tbaa !16
Mismatching
Creating Node
i32 0
i32 0
  %15 = load i32, i32* %Al, align 8, !tbaa !22
Match: 0
2 x 3
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
Function: emit_byte
Function: emit_byte
Function: emit_byte
Match: 1
1 x 3
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %12) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %13) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %add16) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %12) #2
}
Count: 1
Start:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %12) #2
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %12) #2
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %12) #2
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %13) #2
}
Non-memory:   %Se = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 48
Processing:   %13 = load i32, i32* %Se, align 8, !tbaa !21
Count: 1
Not found:   %13 = load i32, i32* %Se, align 8, !tbaa !21
Read/Write memory
I:   %13 = load i32, i32* %Se, align 8, !tbaa !21
Last:   ret void
Schedulable: 0
digraph VTree {
0 [label="call: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
4 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
5 [label="func: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
5->0 
3->2 
4->2 
}


for.end:                                          ; preds = %for.cond
  %12 = load i32, i32* %Ss, align 4, !tbaa !16
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %12) #2
  %Se = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 48
  %13 = load i32, i32* %Se, align 8, !tbaa !21
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %13) #2
  %14 = load i32, i32* %Ah, align 4, !tbaa !17
  %shl15 = shl i32 %14, 4
  %Al = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 50
  %15 = load i32, i32* %Al, align 8, !tbaa !22
  %add16 = add nsw i32 %shl15, %15
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %add16) #2
  ret void

Done Loop Roller: 0/0
Nothing found in: emit_sos
Optimizing: write_scan_header
looking for reduction
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %7, i32 0) #1
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %8, i32 1) #1
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %9, i32 0) #1
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %10, i32 1) #1
Creating Node
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %9, i32 0) #1
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %10, i32 1) #1
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %9 = load i32, i32* %dc_tbl_no10, align 4, !tbaa !15
  %10 = load i32, i32* %ac_tbl_no11, align 8, !tbaa !17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %dc_tbl_no10 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %3, i64 0, i32 5
  %ac_tbl_no11 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %3, i64 0, i32 6
Match: 0
2 x 2
Final Match: 0
  %dc_tbl_no10 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %3, i64 0, i32 5
  %ac_tbl_no11 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %3, i64 0, i32 6
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %dc_tbl_no10 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %3, i64 0, i32 5
Alt Seq
Creating Node
i32 0
i32 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Int Seq
Creating Node
Function: emit_dht
Function: emit_dht
Match: 1
1 x 2
Final Match: 1
All the Same
ScheduleNode: {
  %9 = load i32, i32* %dc_tbl_no10, align 4, !tbaa !15
}
ScheduleNode: {
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %9, i32 0) #1
}
ScheduleNode: {
  %10 = load i32, i32* %ac_tbl_no11, align 8, !tbaa !17
}
ScheduleNode: {
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %10, i32 1) #1
}
ScheduleNode: {
  %9 = load i32, i32* %dc_tbl_no10, align 4, !tbaa !15
}
Count: 1
Start:   %9 = load i32, i32* %dc_tbl_no10, align 4, !tbaa !15
Processing:   %9 = load i32, i32* %dc_tbl_no10, align 4, !tbaa !15
Count: 1
Found:   %9 = load i32, i32* %dc_tbl_no10, align 4, !tbaa !15
ScheduleNode: {
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %9, i32 0) #1
}
Processing:   tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %9, i32 0) #1
Count: 1
Found:   tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %9, i32 0) #1
ScheduleNode: {
  %10 = load i32, i32* %ac_tbl_no11, align 8, !tbaa !17
}
Non-memory:   %ac_tbl_no11 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %3, i64 0, i32 6
Processing:   %10 = load i32, i32* %ac_tbl_no11, align 8, !tbaa !17
Count: 1
Found:   %10 = load i32, i32* %ac_tbl_no11, align 8, !tbaa !17
ScheduleNode: {
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %10, i32 1) #1
}
Processing:   tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %10, i32 1) #1
Count: 1
Found:   tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %10, i32 1) #1
I:   br label %for.inc
Last:   br label %for.inc
Schedulable: 1
Loop Rolling: write_scan_header
Generating tree
Generating MATCH
Match: 
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %9, i32 0) #1
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %10, i32 1) #1
Generating IDENTICAL
Generating MATCH
Match: 
  %9 = load i32, i32* %dc_tbl_no10, align 4, !tbaa !15
  %10 = load i32, i32* %ac_tbl_no11, align 8, !tbaa !17
Generating ALTSEQ
Values:
  %dc_tbl_no10 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %3, i64 0, i32 5
  %ac_tbl_no11 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %3, i64 0, i32 6
Generated Version 4:
  %30 = icmp eq i8 %29, 0
  %31 = select i1 %30, i32* %dc_tbl_no10, i32* %ac_tbl_no11
Operands done!
Generated:   %32 = load i32, i32* %31, align 1
Gen:   %32 = load i32, i32* %31, align 1
Generating INTSEQ
Gen:   %33 = zext i8 %29 to i32
Generating IDENTICAL
Operands done!
Generated:   tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %32, i32 %33) #1
Gen:   tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %32, i32 %33) #1
Graph code generated!
Root:
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %9, i32 0) #1
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %10, i32 1) #1
Root size: 2
digraph VTree {
0 [label="call: emit_dht", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %dc_tbl_no10, %ac_tbl_no11", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="func: emit_dht", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
4->0 
5->0 
3->2 
}

Gains: 12 - 10 = 2; Width: 2; Unprofitable; write_scan_header
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 4) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %12) #2
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* nonnull %cinfo, i32 221) #2
Creating Node
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 4) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %12) #2
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
i32 4
  %12 = load i32, i32* %restart_interval, align 8, !tbaa !20
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 4
Alt Seq
Creating Node
Function: emit_2bytes
Function: emit_2bytes
Match: 1
1 x 2
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 4) #2
}
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %12) #2
}
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 4) #2
}
Count: 1
Start:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 4) #2
Processing:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 4) #2
Count: 1
Found:   tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 4) #2
ScheduleNode: {
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %12) #2
}
Processing:   %12 = load i32, i32* %restart_interval, align 8, !tbaa !20
Count: 1
Not found:   %12 = load i32, i32* %restart_interval, align 8, !tbaa !20
Read/Write memory
I:   %12 = load i32, i32* %restart_interval, align 8, !tbaa !20
Last:   br label %if.end16
Schedulable: 0
digraph VTree {
0 [label="call: emit_2bytes", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: 4, %12", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="func: emit_2bytes", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->0 
}


if.then15:                                        ; preds = %if.end13
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* nonnull %cinfo, i32 221) #2
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 4) #2
  %12 = load i32, i32* %restart_interval, align 8, !tbaa !20
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %12) #2
  br label %if.end16

looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add2.i = add nsw i32 %mul.i, 6
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %14) #2
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* nonnull %cinfo, i32 218) #2
Attempting Group:
  tail call fastcc void @emit_2bytes(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %add2.i) #2
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %if.end11.i ], [ 0, %if.end16 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %18) #2
looking for reduction
looking for reduction
  %td.0.i = phi i32 [ %19, %if.then6.i ], [ %19, %for.body.i ], [ %spec.select.i, %land.lhs.true.i ], [ 0, %if.then.i ]
  %ta.0.i = phi i32 [ 0, %if.then6.i ], [ %20, %for.body.i ], [ 0, %land.lhs.true.i ], [ %20, %if.then.i ]
looking for reduction
looking for reduction
  %add12.i = add nsw i32 %shl.i, %ta.0.i
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %add12.i) #2
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add16.i = add nsw i32 %shl15.i, %28
looking for reduction
Attempting Group:
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %25) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %26) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %add16.i) #2
Creating Node
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %25) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %26) #2
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %add16.i) #2
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
%struct.jpeg_compress_struct* %cinfo
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
  %25 = load i32, i32* %Ss.i, align 4, !tbaa !13
  %26 = load i32, i32* %Se.i, align 8, !tbaa !23
  %add16.i = add nsw i32 %shl15.i, %28
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %25 = load i32, i32* %Ss.i, align 4, !tbaa !13
BinOp Seq
Creating Node
  %25 = load i32, i32* %Ss.i, align 4, !tbaa !13
  %26 = load i32, i32* %Se.i, align 8, !tbaa !23
  %shl15.i = shl i32 %27, 4
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %25 = load i32, i32* %Ss.i, align 4, !tbaa !13
Mismatching
Creating Node
i32 0
i32 0
  %28 = load i32, i32* %Al.i, align 8, !tbaa !24
Match: 0
2 x 3
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
Function: emit_byte
Function: emit_byte
Function: emit_byte
Match: 1
1 x 3
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %25) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %26) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %add16.i) #2
}
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %25) #2
}
Count: 1
Start:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %25) #2
Processing:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %25) #2
Count: 1
Found:   tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %25) #2
ScheduleNode: {
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %26) #2
}
Non-memory:   %Se.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 48
Processing:   %26 = load i32, i32* %Se.i, align 8, !tbaa !23
Count: 1
Not found:   %26 = load i32, i32* %Se.i, align 8, !tbaa !23
Read/Write memory
I:   %26 = load i32, i32* %Se.i, align 8, !tbaa !23
Last:   ret void
Schedulable: 0
digraph VTree {
0 [label="call: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
4 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
5 [label="func: emit_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
5->0 
3->2 
4->2 
}


emit_sos.exit:                                    ; preds = %for.cond.i
  %25 = load i32, i32* %Ss.i, align 4, !tbaa !13
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %25) #2
  %Se.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 48
  %26 = load i32, i32* %Se.i, align 8, !tbaa !23
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %26) #2
  %27 = load i32, i32* %Ah.i, align 4, !tbaa !14
  %shl15.i = shl i32 %27, 4
  %Al.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 50
  %28 = load i32, i32* %Al.i, align 8, !tbaa !24
  %add16.i = add nsw i32 %shl15.i, %28
  tail call fastcc void @emit_byte(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %add16.i) #2
  ret void

Done Loop Roller: 0/1
Optimizing: write_file_trailer
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 217) #1
Done Loop Roller: 0/0
Nothing found in: write_file_trailer
Optimizing: write_tables_only
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* %cinfo, i32 216) #1
  %indvars.iv38 = phi i64 [ %indvars.iv.next39, %for.inc ], [ 0, %entry ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  %call = tail call fastcc i32 @emit_dqt(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %1) #1
looking for reduction
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc16 ], [ 0, %for.cond3.preheader ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %4, i32 0) #1
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_dht(%struct.jpeg_compress_struct* nonnull %cinfo, i32 %6, i32 1) #1
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_marker(%struct.jpeg_compress_struct* nonnull %cinfo, i32 217) #1
Done Loop Roller: 0/0
Nothing found in: write_tables_only
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jidctflt.c -o src/jidctflt.o   -mllvm -reroll-loops=3
Optimizing: jpeg_idct_float
looking for reduction
looking for reduction
  %inptr.0 = phi i16* [ %coef_block, %entry ], [ %inptr.1, %for.inc ]
  %quantptr.0 = phi float* [ %3, %entry ], [ %quantptr.1, %for.inc ]
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %ctr.0 = phi i32 [ 8, %entry ], [ %dec, %for.inc ]
looking for reduction
looking for reduction
looking for reduction
  %mul = fmul float %12, %conv21
looking for reduction
  %mul = fmul float %12, %conv21
looking for reduction
  %mul = fmul float %12, %conv21
looking for reduction
  %mul = fmul float %12, %conv21
looking for reduction
  %mul = fmul float %12, %conv21
Attempting Group:
  store float %mul, float* %wsptr.0, align 4, !tbaa !13
  store float %mul, float* %arrayidx24, align 4, !tbaa !13
  store float %mul, float* %arrayidx25, align 4, !tbaa !13
  store float %mul, float* %arrayidx26, align 4, !tbaa !13
  store float %mul, float* %arrayidx27, align 4, !tbaa !13
Creating Node
  store float %mul, float* %wsptr.0, align 4, !tbaa !13
  store float %mul, float* %arrayidx24, align 4, !tbaa !13
  store float %mul, float* %arrayidx25, align 4, !tbaa !13
  store float %mul, float* %arrayidx26, align 4, !tbaa !13
  store float %mul, float* %arrayidx27, align 4, !tbaa !13
Match: 1
5 x 5
Final Match: 1
Matching
Creating Node
  %mul = fmul float %12, %conv21
  %mul = fmul float %12, %conv21
  %mul = fmul float %12, %conv21
  %mul = fmul float %12, %conv21
  %mul = fmul float %12, %conv21
Match: 1
1 x 5
Final Match: 1
All the Same
Creating Node
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %arrayidx24 = getelementptr inbounds float, float* %wsptr.0, i64 8
  %arrayidx25 = getelementptr inbounds float, float* %wsptr.0, i64 16
  %arrayidx26 = getelementptr inbounds float, float* %wsptr.0, i64 24
  %arrayidx27 = getelementptr inbounds float, float* %wsptr.0, i64 32
Match: 0
5 x 5
Final Match: 0
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %arrayidx24 = getelementptr inbounds float, float* %wsptr.0, i64 8
  %arrayidx25 = getelementptr inbounds float, float* %wsptr.0, i64 16
  %arrayidx26 = getelementptr inbounds float, float* %wsptr.0, i64 24
  %arrayidx27 = getelementptr inbounds float, float* %wsptr.0, i64 32
Ptr:   %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 8
i64 16
i64 24
i64 32
Match: 0
5 x 5
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
ScheduleNode: {
  store float %mul, float* %wsptr.0, align 4, !tbaa !13
}
ScheduleNode: {
  store float %mul, float* %arrayidx24, align 4, !tbaa !13
}
ScheduleNode: {
  store float %mul, float* %arrayidx25, align 4, !tbaa !13
}
ScheduleNode: {
  store float %mul, float* %arrayidx26, align 4, !tbaa !13
}
ScheduleNode: {
  store float %mul, float* %arrayidx27, align 4, !tbaa !13
}
ScheduleNode: {
  store float %mul, float* %wsptr.0, align 4, !tbaa !13
}
Count: 1
Start:   store float %mul, float* %wsptr.0, align 4, !tbaa !13
Processing:   store float %mul, float* %wsptr.0, align 4, !tbaa !13
Count: 1
Found:   store float %mul, float* %wsptr.0, align 4, !tbaa !13
ScheduleNode: {
  store float %mul, float* %arrayidx24, align 4, !tbaa !13
}
Non-memory:   %arrayidx24 = getelementptr inbounds float, float* %wsptr.0, i64 8
Processing:   store float %mul, float* %arrayidx24, align 4, !tbaa !13
Count: 1
Found:   store float %mul, float* %arrayidx24, align 4, !tbaa !13
ScheduleNode: {
  store float %mul, float* %arrayidx25, align 4, !tbaa !13
}
Non-memory:   %arrayidx25 = getelementptr inbounds float, float* %wsptr.0, i64 16
Processing:   store float %mul, float* %arrayidx25, align 4, !tbaa !13
Count: 1
Found:   store float %mul, float* %arrayidx25, align 4, !tbaa !13
ScheduleNode: {
  store float %mul, float* %arrayidx26, align 4, !tbaa !13
}
Non-memory:   %arrayidx26 = getelementptr inbounds float, float* %wsptr.0, i64 24
Processing:   store float %mul, float* %arrayidx26, align 4, !tbaa !13
Count: 1
Found:   store float %mul, float* %arrayidx26, align 4, !tbaa !13
ScheduleNode: {
  store float %mul, float* %arrayidx27, align 4, !tbaa !13
}
Non-memory:   %arrayidx27 = getelementptr inbounds float, float* %wsptr.0, i64 32
Processing:   store float %mul, float* %arrayidx27, align 4, !tbaa !13
Count: 1
Found:   store float %mul, float* %arrayidx27, align 4, !tbaa !13
I:   br label %for.inc
Last:   br label %for.inc
Schedulable: 1
Loop Rolling: jpeg_idct_float
Generating tree
Generating MATCH
Match: 
  store float %mul, float* %wsptr.0, align 4, !tbaa !13
  store float %mul, float* %arrayidx24, align 4, !tbaa !13
  store float %mul, float* %arrayidx25, align 4, !tbaa !13
  store float %mul, float* %arrayidx26, align 4, !tbaa !13
  store float %mul, float* %arrayidx27, align 4, !tbaa !13
Generating IDENTICAL
Generating GEPSEQ
Generating INTSEQ
Gen:   %55 = add i64 %54, 0
Closing GEPSEQ
Gen:   %56 = getelementptr float, float* %wsptr.0, i64 %55
Operands done!
Generated:   store float %mul, float* %56, align 1
Gen:   store float %mul, float* %56, align 1
Graph code generated!
Root:
  store float %mul, float* %wsptr.0, align 4, !tbaa !13
  store float %mul, float* %arrayidx24, align 4, !tbaa !13
  store float %mul, float* %arrayidx25, align 4, !tbaa !13
  store float %mul, float* %arrayidx26, align 4, !tbaa !13
  store float %mul, float* %arrayidx27, align 4, !tbaa !13
Root size: 5
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="fmul", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="0..32, 8", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->2 
}

Gains: 14 - 12 = 2; Width: 5; Unprofitable; jpeg_idct_float
Trying AGAIN
Trying AGAIN
Creating Node
  store float %mul, float* %arrayidx24, align 4, !tbaa !13
  store float %mul, float* %arrayidx25, align 4, !tbaa !13
  store float %mul, float* %arrayidx26, align 4, !tbaa !13
  store float %mul, float* %arrayidx27, align 4, !tbaa !13
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %mul = fmul float %12, %conv21
  %mul = fmul float %12, %conv21
  %mul = fmul float %12, %conv21
  %mul = fmul float %12, %conv21
Match: 1
1 x 4
Final Match: 1
All the Same
Creating Node
  %arrayidx24 = getelementptr inbounds float, float* %wsptr.0, i64 8
  %arrayidx25 = getelementptr inbounds float, float* %wsptr.0, i64 16
  %arrayidx26 = getelementptr inbounds float, float* %wsptr.0, i64 24
  %arrayidx27 = getelementptr inbounds float, float* %wsptr.0, i64 32
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
Match: 0
1 x 4
Final Match: 0
All the Same
Creating Node
i64 8
i64 16
i64 24
i64 32
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
i64 8
Int Seq
ScheduleNode: {
  store float %mul, float* %arrayidx24, align 4, !tbaa !13
}
ScheduleNode: {
  store float %mul, float* %arrayidx25, align 4, !tbaa !13
}
ScheduleNode: {
  store float %mul, float* %arrayidx26, align 4, !tbaa !13
}
ScheduleNode: {
  store float %mul, float* %arrayidx27, align 4, !tbaa !13
}
ScheduleNode: {
  store float %mul, float* %arrayidx24, align 4, !tbaa !13
}
Count: 1
Start:   %arrayidx24 = getelementptr inbounds float, float* %wsptr.0, i64 8
Non-memory:   %arrayidx24 = getelementptr inbounds float, float* %wsptr.0, i64 8
Processing:   store float %mul, float* %arrayidx24, align 4, !tbaa !13
Count: 1
Found:   store float %mul, float* %arrayidx24, align 4, !tbaa !13
ScheduleNode: {
  store float %mul, float* %arrayidx25, align 4, !tbaa !13
}
Non-memory:   %arrayidx25 = getelementptr inbounds float, float* %wsptr.0, i64 16
Processing:   store float %mul, float* %arrayidx25, align 4, !tbaa !13
Count: 1
Found:   store float %mul, float* %arrayidx25, align 4, !tbaa !13
ScheduleNode: {
  store float %mul, float* %arrayidx26, align 4, !tbaa !13
}
Non-memory:   %arrayidx26 = getelementptr inbounds float, float* %wsptr.0, i64 24
Processing:   store float %mul, float* %arrayidx26, align 4, !tbaa !13
Count: 1
Found:   store float %mul, float* %arrayidx26, align 4, !tbaa !13
ScheduleNode: {
  store float %mul, float* %arrayidx27, align 4, !tbaa !13
}
Non-memory:   %arrayidx27 = getelementptr inbounds float, float* %wsptr.0, i64 32
Processing:   store float %mul, float* %arrayidx27, align 4, !tbaa !13
Count: 1
Found:   store float %mul, float* %arrayidx27, align 4, !tbaa !13
I:   br label %for.inc
Last:   br label %for.inc
Schedulable: 1
Loop Rolling: jpeg_idct_float
Generating tree
Generating MATCH
Match: 
  store float %mul, float* %arrayidx24, align 4, !tbaa !13
  store float %mul, float* %arrayidx25, align 4, !tbaa !13
  store float %mul, float* %arrayidx26, align 4, !tbaa !13
  store float %mul, float* %arrayidx27, align 4, !tbaa !13
Generating IDENTICAL
Generating MATCH
Match: 
  %arrayidx24 = getelementptr inbounds float, float* %wsptr.0, i64 8
  %arrayidx25 = getelementptr inbounds float, float* %wsptr.0, i64 16
  %arrayidx26 = getelementptr inbounds float, float* %wsptr.0, i64 24
  %arrayidx27 = getelementptr inbounds float, float* %wsptr.0, i64 32
Generating IDENTICAL
Generating INTSEQ
Gen:   %55 = add i64 %54, 8
Operands done!
Generated:   %56 = getelementptr inbounds float, float* %wsptr.0, i64 %55
Gen:   %56 = getelementptr inbounds float, float* %wsptr.0, i64 %55
Operands done!
Generated:   store float %mul, float* %56, align 1
Gen:   store float %mul, float* %56, align 1
Graph code generated!
Root:
  store float %mul, float* %arrayidx24, align 4, !tbaa !13
  store float %mul, float* %arrayidx25, align 4, !tbaa !13
  store float %mul, float* %arrayidx26, align 4, !tbaa !13
  store float %mul, float* %arrayidx27, align 4, !tbaa !13
Root size: 4
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="fmul", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="8..32, 8", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->2 
4->2 
}

Gains: 12 - 12 = 0; Width: 4; Unprofitable; jpeg_idct_float
looking for reduction
  %add89 = fadd float %add53, %add77
Found
looking for reduction
  %add93 = fadd float %add55, %sub86
Found
looking for reduction
  %add97 = fadd float %sub56, %sub87
looking for reduction
  %add101 = fadd float %sub54, %add88
Found
looking for reduction
  %sub103 = fsub float %sub54, %add88
Attempting Group:
  store float %add89, float* %wsptr.0, align 4, !tbaa !13
  store float %add93, float* %arrayidx94, align 4, !tbaa !13
  store float %add97, float* %arrayidx98, align 4, !tbaa !13
  store float %add101, float* %arrayidx102, align 4, !tbaa !13
  store float %sub103, float* %arrayidx104, align 4, !tbaa !13
Creating Node
  store float %add89, float* %wsptr.0, align 4, !tbaa !13
  store float %add93, float* %arrayidx94, align 4, !tbaa !13
  store float %add97, float* %arrayidx98, align 4, !tbaa !13
  store float %add101, float* %arrayidx102, align 4, !tbaa !13
  store float %sub103, float* %arrayidx104, align 4, !tbaa !13
Match: 1
5 x 5
Final Match: 1
Matching
Creating Node
  %add89 = fadd float %add53, %add77
  %add93 = fadd float %add55, %sub86
  %add97 = fadd float %sub56, %sub87
  %add101 = fadd float %sub54, %add88
  %sub103 = fsub float %sub54, %add88
Match: 0
5 x 5
Final Match: 0
GEPSeq2
BinOP?
  %add89 = fadd float %add53, %add77
Mismatching
Creating Node
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %arrayidx94 = getelementptr inbounds float, float* %wsptr.0, i64 8
  %arrayidx98 = getelementptr inbounds float, float* %wsptr.0, i64 16
  %arrayidx102 = getelementptr inbounds float, float* %wsptr.0, i64 32
  %arrayidx104 = getelementptr inbounds float, float* %wsptr.0, i64 24
Match: 0
5 x 5
Final Match: 0
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %arrayidx94 = getelementptr inbounds float, float* %wsptr.0, i64 8
  %arrayidx98 = getelementptr inbounds float, float* %wsptr.0, i64 16
  %arrayidx102 = getelementptr inbounds float, float* %wsptr.0, i64 32
  %arrayidx104 = getelementptr inbounds float, float* %wsptr.0, i64 24
Ptr:   %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 8
i64 16
i64 32
i64 24
Match: 0
5 x 5
Final Match: 0
GEPSeq2
BinOP?
i64 0
Mismatching
ScheduleNode: {
  store float %add89, float* %wsptr.0, align 4, !tbaa !13
}
ScheduleNode: {
  store float %add93, float* %arrayidx94, align 4, !tbaa !13
}
ScheduleNode: {
  store float %add97, float* %arrayidx98, align 4, !tbaa !13
}
ScheduleNode: {
  store float %add101, float* %arrayidx102, align 4, !tbaa !13
}
ScheduleNode: {
  store float %sub103, float* %arrayidx104, align 4, !tbaa !13
}
ScheduleNode: {
  store float %add89, float* %wsptr.0, align 4, !tbaa !13
}
Count: 1
Start:   store float %add89, float* %wsptr.0, align 4, !tbaa !13
Processing:   store float %add89, float* %wsptr.0, align 4, !tbaa !13
Count: 1
Found:   store float %add89, float* %wsptr.0, align 4, !tbaa !13
ScheduleNode: {
  store float %add93, float* %arrayidx94, align 4, !tbaa !13
}
Non-memory:   %sub91 = fsub float %add53, %add77
Non-memory:   %add93 = fadd float %add55, %sub86
Non-memory:   %arrayidx94 = getelementptr inbounds float, float* %wsptr.0, i64 8
Processing:   store float %add93, float* %arrayidx94, align 4, !tbaa !13
Count: 1
Found:   store float %add93, float* %arrayidx94, align 4, !tbaa !13
ScheduleNode: {
  store float %add97, float* %arrayidx98, align 4, !tbaa !13
}
Non-memory:   %sub95 = fsub float %add55, %sub86
Non-memory:   %add97 = fadd float %sub56, %sub87
Non-memory:   %arrayidx98 = getelementptr inbounds float, float* %wsptr.0, i64 16
Processing:   store float %add97, float* %arrayidx98, align 4, !tbaa !13
Count: 1
Found:   store float %add97, float* %arrayidx98, align 4, !tbaa !13
ScheduleNode: {
  store float %add101, float* %arrayidx102, align 4, !tbaa !13
}
Non-memory:   %sub99 = fsub float %sub56, %sub87
Non-memory:   %add101 = fadd float %sub54, %add88
Non-memory:   %arrayidx102 = getelementptr inbounds float, float* %wsptr.0, i64 32
Processing:   store float %add101, float* %arrayidx102, align 4, !tbaa !13
Count: 1
Found:   store float %add101, float* %arrayidx102, align 4, !tbaa !13
ScheduleNode: {
  store float %sub103, float* %arrayidx104, align 4, !tbaa !13
}
Non-memory:   %sub103 = fsub float %sub54, %add88
Non-memory:   %arrayidx104 = getelementptr inbounds float, float* %wsptr.0, i64 24
Processing:   store float %sub103, float* %arrayidx104, align 4, !tbaa !13
Count: 1
Found:   store float %sub103, float* %arrayidx104, align 4, !tbaa !13
I:   br label %for.inc
Last:   br label %for.inc
Schedulable: 1
Loop Rolling: jpeg_idct_float
Generating tree
Generating MATCH
Match: 
  store float %add89, float* %wsptr.0, align 4, !tbaa !13
  store float %add93, float* %arrayidx94, align 4, !tbaa !13
  store float %add97, float* %arrayidx98, align 4, !tbaa !13
  store float %add101, float* %arrayidx102, align 4, !tbaa !13
  store float %sub103, float* %arrayidx104, align 4, !tbaa !13
Generating Mismatch
Mismatched Values:
inst:   %add89 = fadd float %add53, %add77
inst:   %add93 = fadd float %add55, %sub86
inst:   %add97 = fadd float %sub56, %sub87
inst:   %add101 = fadd float %sub54, %add88
inst:   %sub103 = fsub float %sub54, %add88
Non constants
Array Type: 5:float
Created array:   %52 = alloca float, i8 5, align 4
Gen:   %60 = load float, float* %59, align 4
Generating GEPSEQ
Generating Mismatch
Mismatched Values:
int: i64 0
int: i64 8
int: i64 16
int: i64 32
int: i64 24
All constants
Created array: @0 = private constant [5 x i64] [i64 0, i64 8, i64 16, i64 32, i64 24]
Gen:   %62 = load i64, i64* %61, align 8
Closing GEPSEQ
Gen:   %63 = getelementptr float, float* %wsptr.0, i64 %62
Operands done!
Generated:   store float %60, float* %63, align 1
Gen:   store float %60, float* %63, align 1
Graph code generated!
Root:
  store float %add89, float* %wsptr.0, align 4, !tbaa !13
  store float %add93, float* %arrayidx94, align 4, !tbaa !13
  store float %add97, float* %arrayidx98, align 4, !tbaa !13
  store float %add101, float* %arrayidx102, align 4, !tbaa !13
  store float %sub103, float* %arrayidx104, align 4, !tbaa !13
Root size: 5
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
3->2 
}

Gains: 14 - 72 = -58; Width: 5; Unprofitable; jpeg_idct_float
Trying AGAIN
Trying AGAIN
Creating Node
  store float %add93, float* %arrayidx94, align 4, !tbaa !13
  store float %add97, float* %arrayidx98, align 4, !tbaa !13
  store float %add101, float* %arrayidx102, align 4, !tbaa !13
  store float %sub103, float* %arrayidx104, align 4, !tbaa !13
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %add93 = fadd float %add55, %sub86
  %add97 = fadd float %sub56, %sub87
  %add101 = fadd float %sub54, %add88
  %sub103 = fsub float %sub54, %add88
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %add93 = fadd float %add55, %sub86
Mismatching
Creating Node
  %arrayidx94 = getelementptr inbounds float, float* %wsptr.0, i64 8
  %arrayidx98 = getelementptr inbounds float, float* %wsptr.0, i64 16
  %arrayidx102 = getelementptr inbounds float, float* %wsptr.0, i64 32
  %arrayidx104 = getelementptr inbounds float, float* %wsptr.0, i64 24
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
Match: 0
1 x 4
Final Match: 0
All the Same
Creating Node
i64 8
i64 16
i64 32
i64 24
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
i64 8
Mismatching
ScheduleNode: {
  store float %add93, float* %arrayidx94, align 4, !tbaa !13
}
ScheduleNode: {
  store float %add97, float* %arrayidx98, align 4, !tbaa !13
}
ScheduleNode: {
  store float %add101, float* %arrayidx102, align 4, !tbaa !13
}
ScheduleNode: {
  store float %sub103, float* %arrayidx104, align 4, !tbaa !13
}
ScheduleNode: {
  store float %add93, float* %arrayidx94, align 4, !tbaa !13
}
Count: 1
Start:   %arrayidx94 = getelementptr inbounds float, float* %wsptr.0, i64 8
Non-memory:   %arrayidx94 = getelementptr inbounds float, float* %wsptr.0, i64 8
Processing:   store float %add93, float* %arrayidx94, align 4, !tbaa !13
Count: 1
Found:   store float %add93, float* %arrayidx94, align 4, !tbaa !13
ScheduleNode: {
  store float %add97, float* %arrayidx98, align 4, !tbaa !13
}
Non-memory:   %sub95 = fsub float %add55, %sub86
Non-memory:   %add97 = fadd float %sub56, %sub87
Non-memory:   %arrayidx98 = getelementptr inbounds float, float* %wsptr.0, i64 16
Processing:   store float %add97, float* %arrayidx98, align 4, !tbaa !13
Count: 1
Found:   store float %add97, float* %arrayidx98, align 4, !tbaa !13
ScheduleNode: {
  store float %add101, float* %arrayidx102, align 4, !tbaa !13
}
Non-memory:   %sub99 = fsub float %sub56, %sub87
Non-memory:   %add101 = fadd float %sub54, %add88
Non-memory:   %arrayidx102 = getelementptr inbounds float, float* %wsptr.0, i64 32
Processing:   store float %add101, float* %arrayidx102, align 4, !tbaa !13
Count: 1
Found:   store float %add101, float* %arrayidx102, align 4, !tbaa !13
ScheduleNode: {
  store float %sub103, float* %arrayidx104, align 4, !tbaa !13
}
Non-memory:   %sub103 = fsub float %sub54, %add88
Non-memory:   %arrayidx104 = getelementptr inbounds float, float* %wsptr.0, i64 24
Processing:   store float %sub103, float* %arrayidx104, align 4, !tbaa !13
Count: 1
Found:   store float %sub103, float* %arrayidx104, align 4, !tbaa !13
I:   br label %for.inc
Last:   br label %for.inc
Schedulable: 1
Loop Rolling: jpeg_idct_float
Generating tree
Generating MATCH
Match: 
  store float %add93, float* %arrayidx94, align 4, !tbaa !13
  store float %add97, float* %arrayidx98, align 4, !tbaa !13
  store float %add101, float* %arrayidx102, align 4, !tbaa !13
  store float %sub103, float* %arrayidx104, align 4, !tbaa !13
Generating Mismatch
Mismatched Values:
inst:   %add93 = fadd float %add55, %sub86
inst:   %add97 = fadd float %sub56, %sub87
inst:   %add101 = fadd float %sub54, %add88
inst:   %sub103 = fsub float %sub54, %add88
Non constants
Array Type: 4:float
Created array:   %52 = alloca float, i8 4, align 4
Gen:   %59 = load float, float* %58, align 4
Generating MATCH
Match: 
  %arrayidx94 = getelementptr inbounds float, float* %wsptr.0, i64 8
  %arrayidx98 = getelementptr inbounds float, float* %wsptr.0, i64 16
  %arrayidx102 = getelementptr inbounds float, float* %wsptr.0, i64 32
  %arrayidx104 = getelementptr inbounds float, float* %wsptr.0, i64 24
Generating IDENTICAL
Generating Mismatch
Mismatched Values:
int: i64 8
int: i64 16
int: i64 32
int: i64 24
All constants
Created array: @1 = private constant [4 x i64] [i64 8, i64 16, i64 32, i64 24]
Gen:   %61 = load i64, i64* %60, align 8
Operands done!
Generated:   %62 = getelementptr inbounds float, float* %wsptr.0, i64 %61
Gen:   %62 = getelementptr inbounds float, float* %wsptr.0, i64 %61
Operands done!
Generated:   store float %59, float* %62, align 1
Gen:   store float %59, float* %62, align 1
Graph code generated!
Root:
  store float %add93, float* %arrayidx94, align 4, !tbaa !13
  store float %add97, float* %arrayidx98, align 4, !tbaa !13
  store float %add101, float* %arrayidx102, align 4, !tbaa !13
  store float %sub103, float* %arrayidx104, align 4, !tbaa !13
Root size: 4
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
3->2 
4->2 
}

Gains: 12 - 60 = -48; Width: 4; Unprofitable; jpeg_idct_float
Building reduction
  store float %add101, float* %arrayidx102, align 4, !tbaa !13
  %add101 = fadd float %sub54, %add88
BOs:
  %add101 = fadd float %sub54, %add88
  %add88 = fadd float %sub83, %sub87
Operands:
  %sub54 = fsub float %add, %add49
  %sub83 = fsub float %mul82, %mul81
  %sub87 = fsub float %mul79, %sub86
Operands:
  %sub54 = fsub float %add, %add49
  %sub83 = fsub float %mul82, %mul81
  %sub87 = fsub float %mul79, %sub86
ReductionNode
Creating Node
  %sub54 = fsub float %add, %add49
  %sub83 = fsub float %mul82, %mul81
  %sub87 = fsub float %mul79, %sub86
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %add = fadd float %mul36, %mul44
  %mul82 = fmul float %sub76, 0x3FF1517A80000000
  %mul79 = fmul float %sub78, 0x3FF6A09E60000000
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %add = fadd float %mul36, %mul44
Mismatching
Creating Node
  %add49 = fadd float %mul40, %mul48
  %mul81 = fmul float %add80, 0x3FFD906BC0000000
  %sub86 = fsub float %22, %add77
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %add49 = fadd float %mul40, %mul48
Mismatching
Empty scheduling entries
Loop Rolling: jpeg_idct_float
Generating tree
Generating REDUCTION
Generating MATCH
Match: 
  %sub54 = fsub float %add, %add49
  %sub83 = fsub float %mul82, %mul81
  %sub87 = fsub float %mul79, %sub86
Generating Mismatch
Mismatched Values:
inst:   %add = fadd float %mul36, %mul44
inst:   %mul82 = fmul float %sub76, 0x3FF1517A80000000
inst:   %mul79 = fmul float %sub78, 0x3FF6A09E60000000
Non constants
Array Type: 3:float
Created array:   %52 = alloca float, i8 3, align 4
Gen:   %58 = load float, float* %57, align 4
Generating Mismatch
Mismatched Values:
inst:   %add49 = fadd float %mul40, %mul48
inst:   %mul81 = fmul float %add80, 0x3FFD906BC0000000
inst:   %sub86 = fsub float %22, %add77
Non constants
Array Type: 3:float
Created array:   %56 = alloca float, i8 3, align 4
Gen:   %64 = load float, float* %63, align 4
Operands done!
Generated:   %65 = fsub float %62, %64
Found use: 0:   %sub103 = fsub float %sub54, %add88
Found use: 2:   %sub99 = fsub float %sub56, %sub87
Extracting:   %65 = fsub float %62, %64
Gen:   %66 = fsub float %63, %65
Closing REDUCTION
Found use: 0:   store float %add101, float* %arrayidx102, align 4, !tbaa !13
Found use: 1:   %sub103 = fsub float %sub54, %add88
Extracting:   %69 = fadd float %62, %67
Gen:   %70 = fadd float %63, %68
Graph code generated!
Root:
  %add101 = fadd float %sub54, %add88
  %add88 = fadd float %sub83, %sub87
Root size: 2
digraph VTree {
0 [label="fadd red.", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="fsub", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->1 
3->1 
4 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
0->4
5 [label="fsub", style="filled" , fillcolor="#f2eb5c", shape=box];
0->5
1->5
6 [label="fsub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->6
}

Gains: 5 - 112 = -107; Width: 2; Reduction Unprofitable; jpeg_idct_float
Building reduction
  store float %add89, float* %wsptr.0, align 4, !tbaa !13
  %add89 = fadd float %add53, %add77
BOs:
  %add89 = fadd float %add53, %add77
  %add53 = fadd float %add, %add49
  %add = fadd float %mul36, %mul44
  %add49 = fadd float %mul40, %mul48
  %add77 = fadd float %add73, %add75
  %add73 = fadd float %mul64, %mul68
  %add75 = fadd float %mul60, %mul72
Operands:
  %mul36 = fmul float %16, %conv34
  %mul44 = fmul float %18, %conv42
  %mul40 = fmul float %17, %conv38
  %mul48 = fmul float %19, %conv46
  %mul64 = fmul float %21, %conv62
  %mul68 = fmul float %22, %conv66
  %mul60 = fmul float %20, %conv58
  %mul72 = fmul float %23, %conv70
Operands:
  %mul36 = fmul float %16, %conv34
  %mul40 = fmul float %17, %conv38
  %mul44 = fmul float %18, %conv42
  %mul48 = fmul float %19, %conv46
  %mul60 = fmul float %20, %conv58
  %mul64 = fmul float %21, %conv62
  %mul68 = fmul float %22, %conv66
  %mul72 = fmul float %23, %conv70
ReductionNode
Creating Node
  %mul36 = fmul float %16, %conv34
  %mul40 = fmul float %17, %conv38
  %mul44 = fmul float %18, %conv42
  %mul48 = fmul float %19, %conv46
  %mul60 = fmul float %20, %conv58
  %mul64 = fmul float %21, %conv62
  %mul68 = fmul float %22, %conv66
  %mul72 = fmul float %23, %conv70
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %16 = load float, float* %quantptr.0, align 4, !tbaa !13
  %17 = load float, float* %arrayidx39, align 4, !tbaa !13
  %18 = load float, float* %arrayidx43, align 4, !tbaa !13
  %19 = load float, float* %arrayidx47, align 4, !tbaa !13
  %20 = load float, float* %arrayidx59, align 4, !tbaa !13
  %21 = load float, float* %arrayidx63, align 4, !tbaa !13
  %22 = load float, float* %arrayidx67, align 4, !tbaa !13
  %23 = load float, float* %arrayidx71, align 4, !tbaa !13
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %quantptr.0 = phi float* [ %5, %entry ], [ %quantptr.1, %for.inc ]
  %arrayidx39 = getelementptr inbounds float, float* %quantptr.0, i64 16
  %arrayidx43 = getelementptr inbounds float, float* %quantptr.0, i64 32
  %arrayidx47 = getelementptr inbounds float, float* %quantptr.0, i64 48
  %arrayidx59 = getelementptr inbounds float, float* %quantptr.0, i64 8
  %arrayidx63 = getelementptr inbounds float, float* %quantptr.0, i64 24
  %arrayidx67 = getelementptr inbounds float, float* %quantptr.0, i64 40
  %arrayidx71 = getelementptr inbounds float, float* %quantptr.0, i64 56
Match: 0
8 x 8
Final Match: 0
  %quantptr.0 = phi float* [ %5, %entry ], [ %quantptr.1, %for.inc ]
  %arrayidx39 = getelementptr inbounds float, float* %quantptr.0, i64 16
  %arrayidx43 = getelementptr inbounds float, float* %quantptr.0, i64 32
  %arrayidx47 = getelementptr inbounds float, float* %quantptr.0, i64 48
  %arrayidx59 = getelementptr inbounds float, float* %quantptr.0, i64 8
  %arrayidx63 = getelementptr inbounds float, float* %quantptr.0, i64 24
  %arrayidx67 = getelementptr inbounds float, float* %quantptr.0, i64 40
  %arrayidx71 = getelementptr inbounds float, float* %quantptr.0, i64 56
Ptr:   %quantptr.0 = phi float* [ %5, %entry ], [ %quantptr.1, %for.inc ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 16
i64 32
i64 48
i64 8
i64 24
i64 40
i64 56
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
i64 0
Mismatching
Creating Node
  %conv34 = sitofp i16 %15 to float
  %conv38 = sitofp i16 %7 to float
  %conv42 = sitofp i16 %9 to float
  %conv46 = sitofp i16 %11 to float
  %conv58 = sitofp i16 %6 to float
  %conv62 = sitofp i16 %8 to float
  %conv66 = sitofp i16 %10 to float
  %conv70 = sitofp i16 %12 to float
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %15 = load i16, i16* %inptr.0, align 2, !tbaa !12
  %7 = load i16, i16* %arrayidx1, align 2, !tbaa !12
  %9 = load i16, i16* %arrayidx6, align 2, !tbaa !12
  %11 = load i16, i16* %arrayidx12, align 2, !tbaa !12
  %6 = load i16, i16* %arrayidx, align 2, !tbaa !12
  %8 = load i16, i16* %arrayidx3, align 2, !tbaa !12
  %10 = load i16, i16* %arrayidx9, align 2, !tbaa !12
  %12 = load i16, i16* %arrayidx15, align 2, !tbaa !12
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
  %15 = load i16, i16* %inptr.0, align 2, !tbaa !12
Mismatching
ScheduleNode: {
  %19 = load float, float* %arrayidx47, align 4, !tbaa !13
  %18 = load float, float* %arrayidx43, align 4, !tbaa !13
  %16 = load float, float* %quantptr.0, align 4, !tbaa !13
  %17 = load float, float* %arrayidx39, align 4, !tbaa !13
  %20 = load float, float* %arrayidx59, align 4, !tbaa !13
  %21 = load float, float* %arrayidx63, align 4, !tbaa !13
  %22 = load float, float* %arrayidx67, align 4, !tbaa !13
  %23 = load float, float* %arrayidx71, align 4, !tbaa !13
}
ScheduleNode: {
  %19 = load float, float* %arrayidx47, align 4, !tbaa !13
  %18 = load float, float* %arrayidx43, align 4, !tbaa !13
  %16 = load float, float* %quantptr.0, align 4, !tbaa !13
  %17 = load float, float* %arrayidx39, align 4, !tbaa !13
  %20 = load float, float* %arrayidx59, align 4, !tbaa !13
  %21 = load float, float* %arrayidx63, align 4, !tbaa !13
  %22 = load float, float* %arrayidx67, align 4, !tbaa !13
  %23 = load float, float* %arrayidx71, align 4, !tbaa !13
}
Count: 8
Start:   %conv34 = sitofp i16 %15 to float
Non-memory:   %conv34 = sitofp i16 %15 to float
Processing:   %16 = load float, float* %quantptr.0, align 4, !tbaa !13
Count: 8
Found:   %16 = load float, float* %quantptr.0, align 4, !tbaa !13
Non-memory:   %mul36 = fmul float %16, %conv34
Non-memory:   %conv38 = sitofp i16 %7 to float
Non-memory:   %arrayidx39 = getelementptr inbounds float, float* %quantptr.0, i64 16
Processing:   %17 = load float, float* %arrayidx39, align 4, !tbaa !13
Count: 7
Found:   %17 = load float, float* %arrayidx39, align 4, !tbaa !13
Non-memory:   %mul40 = fmul float %17, %conv38
Non-memory:   %conv42 = sitofp i16 %9 to float
Non-memory:   %arrayidx43 = getelementptr inbounds float, float* %quantptr.0, i64 32
Processing:   %18 = load float, float* %arrayidx43, align 4, !tbaa !13
Count: 6
Found:   %18 = load float, float* %arrayidx43, align 4, !tbaa !13
Non-memory:   %mul44 = fmul float %18, %conv42
Non-memory:   %conv46 = sitofp i16 %11 to float
Non-memory:   %arrayidx47 = getelementptr inbounds float, float* %quantptr.0, i64 48
Processing:   %19 = load float, float* %arrayidx47, align 4, !tbaa !13
Count: 5
Found:   %19 = load float, float* %arrayidx47, align 4, !tbaa !13
Non-memory:   %mul48 = fmul float %19, %conv46
Non-memory:   %add = fadd float %mul36, %mul44
Non-memory:   %sub = fsub float %mul36, %mul44
Non-memory:   %add49 = fadd float %mul40, %mul48
Non-memory:   %sub50 = fsub float %mul40, %mul48
Non-memory:   %mul51 = fmul float %sub50, 0x3FF6A09E60000000
Non-memory:   %sub52 = fsub float %mul51, %add49
Non-memory:   %add53 = fadd float %add, %add49
Non-memory:   %sub54 = fsub float %add, %add49
Non-memory:   %add55 = fadd float %sub, %sub52
Non-memory:   %sub56 = fsub float %sub, %sub52
Non-memory:   %conv58 = sitofp i16 %6 to float
Non-memory:   %arrayidx59 = getelementptr inbounds float, float* %quantptr.0, i64 8
Processing:   %20 = load float, float* %arrayidx59, align 4, !tbaa !13
Count: 4
Found:   %20 = load float, float* %arrayidx59, align 4, !tbaa !13
Non-memory:   %mul60 = fmul float %20, %conv58
Non-memory:   %conv62 = sitofp i16 %8 to float
Non-memory:   %arrayidx63 = getelementptr inbounds float, float* %quantptr.0, i64 24
Processing:   %21 = load float, float* %arrayidx63, align 4, !tbaa !13
Count: 3
Found:   %21 = load float, float* %arrayidx63, align 4, !tbaa !13
Non-memory:   %mul64 = fmul float %21, %conv62
Non-memory:   %conv66 = sitofp i16 %10 to float
Non-memory:   %arrayidx67 = getelementptr inbounds float, float* %quantptr.0, i64 40
Processing:   %22 = load float, float* %arrayidx67, align 4, !tbaa !13
Count: 2
Found:   %22 = load float, float* %arrayidx67, align 4, !tbaa !13
Non-memory:   %mul68 = fmul float %22, %conv66
Non-memory:   %conv70 = sitofp i16 %12 to float
Non-memory:   %arrayidx71 = getelementptr inbounds float, float* %quantptr.0, i64 56
Processing:   %23 = load float, float* %arrayidx71, align 4, !tbaa !13
Count: 1
Found:   %23 = load float, float* %arrayidx71, align 4, !tbaa !13
I:   %mul72 = fmul float %23, %conv70
Last:   br label %for.inc
Schedulable: 1
Loop Rolling: jpeg_idct_float
Generating tree
Generating REDUCTION
Generating MATCH
Match: 
  %mul36 = fmul float %16, %conv34
  %mul40 = fmul float %17, %conv38
  %mul44 = fmul float %18, %conv42
  %mul48 = fmul float %19, %conv46
  %mul60 = fmul float %20, %conv58
  %mul64 = fmul float %21, %conv62
  %mul68 = fmul float %22, %conv66
  %mul72 = fmul float %23, %conv70
Generating MATCH
Match: 
  %16 = load float, float* %quantptr.0, align 4, !tbaa !13
  %17 = load float, float* %arrayidx39, align 4, !tbaa !13
  %18 = load float, float* %arrayidx43, align 4, !tbaa !13
  %19 = load float, float* %arrayidx47, align 4, !tbaa !13
  %20 = load float, float* %arrayidx59, align 4, !tbaa !13
  %21 = load float, float* %arrayidx63, align 4, !tbaa !13
  %22 = load float, float* %arrayidx67, align 4, !tbaa !13
  %23 = load float, float* %arrayidx71, align 4, !tbaa !13
Generating GEPSEQ
Generating Mismatch
Mismatched Values:
int: i64 0
int: i64 16
int: i64 32
int: i64 48
int: i64 8
int: i64 24
int: i64 40
int: i64 56
All constants
Created array: @2 = private constant [8 x i64] [i64 0, i64 16, i64 32, i64 48, i64 8, i64 24, i64 40, i64 56]
Gen:   %56 = load i64, i64* %55, align 8
Closing GEPSEQ
Gen:   %57 = getelementptr float, float* %quantptr.0, i64 %56
Operands done!
Generated:   %58 = load float, float* %57, align 1
Gen:   %58 = load float, float* %57, align 1
Generating MATCH
Match: 
  %conv34 = sitofp i16 %15 to float
  %conv38 = sitofp i16 %7 to float
  %conv42 = sitofp i16 %9 to float
  %conv46 = sitofp i16 %11 to float
  %conv58 = sitofp i16 %6 to float
  %conv62 = sitofp i16 %8 to float
  %conv66 = sitofp i16 %10 to float
  %conv70 = sitofp i16 %12 to float
Generating Mismatch
Mismatched Values:
inst:   %15 = load i16, i16* %inptr.0, align 2, !tbaa !12
inst:   %7 = load i16, i16* %arrayidx1, align 2, !tbaa !12
inst:   %9 = load i16, i16* %arrayidx6, align 2, !tbaa !12
inst:   %11 = load i16, i16* %arrayidx12, align 2, !tbaa !12
inst:   %6 = load i16, i16* %arrayidx, align 2, !tbaa !12
inst:   %8 = load i16, i16* %arrayidx3, align 2, !tbaa !12
inst:   %10 = load i16, i16* %arrayidx9, align 2, !tbaa !12
inst:   %12 = load i16, i16* %arrayidx15, align 2, !tbaa !12
Non constants
Array Type: 8:i16
Created array:   %54 = alloca i16, i8 8, align 2
Gen:   %69 = load i16, i16* %68, align 2
Operands done!
Generated:   %70 = sitofp i16 %69 to float
Gen:   %70 = sitofp i16 %69 to float
Operands done!
Generated:   %71 = fmul float %67, %70
Found use: 0:   %sub = fsub float %mul36, %mul44
Found use: 1:   %sub50 = fsub float %mul40, %mul48
Found use: 2:   %sub = fsub float %mul36, %mul44
Found use: 3:   %sub50 = fsub float %mul40, %mul48
Found use: 4:   %sub76 = fsub float %mul60, %mul72
Found use: 5:   %sub74 = fsub float %mul68, %mul64
Found use: 6:   %sub74 = fsub float %mul68, %mul64
Found use: 7:   %sub76 = fsub float %mul60, %mul72
Extracting:   %71 = fmul float %67, %70
Gen:   %72 = fmul float %68, %71
Closing REDUCTION
Found use: 0:   store float %add89, float* %wsptr.0, align 4, !tbaa !13
Found use: 1:   %sub91 = fsub float %add53, %add77
Found use: 2:   %sub54 = fsub float %add, %add49
Found use: 3:   %sub54 = fsub float %add, %add49
Found use: 4:   %sub91 = fsub float %add53, %add77
Found use: 5:   %sub78 = fsub float %add75, %add73
Found use: 6:   %sub78 = fsub float %add75, %add73
Extracting:   %75 = fadd float %65, %73
Gen:   %76 = fadd float %66, %74
Graph code generated!
Root:
  %add89 = fadd float %add53, %add77
  %add53 = fadd float %add, %add49
  %add = fadd float %mul36, %mul44
  %add49 = fadd float %mul40, %mul48
  %add77 = fadd float %add73, %add75
  %add73 = fadd float %mul64, %mul68
  %add75 = fadd float %mul60, %mul72
Root size: 7
digraph VTree {
0 [label="fadd red.", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="fmul", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
5 [label="sitofp", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->1 
5->1 
3->2 
4->3 
6->5 
7 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
0->7
8 [label="fsub", style="filled" , fillcolor="#f2eb5c", shape=box];
0->8
9 [label="fsub", style="filled" , fillcolor="#f2eb5c", shape=box];
0->9
0->9
0->8
10 [label="fsub", style="filled" , fillcolor="#f2eb5c", shape=box];
0->10
0->10
11 [label="fsub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->11
12 [label="fsub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->12
1->11
1->12
13 [label="fsub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->13
14 [label="fsub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->14
1->14
1->13
}

Gains: 46 - 207 = -161; Width: 7; Reduction Unprofitable; jpeg_idct_float
Building reduction
  store float %add93, float* %arrayidx94, align 4, !tbaa !13
  %add93 = fadd float %add55, %sub86
BOs:
  %add93 = fadd float %add55, %sub86
  %add55 = fadd float %sub, %sub52
Operands:
  %sub = fsub float %mul36, %mul44
  %sub52 = fsub float %mul51, %add49
  %sub86 = fsub float %26, %add77
Operands:
  %sub = fsub float %mul36, %mul44
  %sub52 = fsub float %mul51, %add49
  %sub86 = fsub float %26, %add77
ReductionNode
Creating Node
  %sub = fsub float %mul36, %mul44
  %sub52 = fsub float %mul51, %add49
  %sub86 = fsub float %26, %add77
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %mul36 = fmul float %18, %conv34
  %mul51 = fmul float %sub50, 0x3FF6A09E60000000
  %26 = fsub float %mul81, %mul84
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %mul36 = fmul float %18, %conv34
Mismatching
Creating Node
  %mul44 = fmul float %20, %conv42
  %add49 = fadd float %mul40, %mul48
  %add77 = fadd float %add73, %add75
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %mul44 = fmul float %20, %conv42
Mismatching
Empty scheduling entries
Loop Rolling: jpeg_idct_float
Generating tree
Generating REDUCTION
Generating MATCH
Match: 
  %sub = fsub float %mul36, %mul44
  %sub52 = fsub float %mul51, %add49
  %sub86 = fsub float %26, %add77
Generating Mismatch
Mismatched Values:
inst:   %mul36 = fmul float %18, %conv34
inst:   %mul51 = fmul float %sub50, 0x3FF6A09E60000000
inst:   %26 = fsub float %mul81, %mul84
Non constants
Array Type: 3:float
Created array:   %56 = alloca float, i8 3, align 4
Gen:   %62 = load float, float* %61, align 4
Generating Mismatch
Mismatched Values:
inst:   %mul44 = fmul float %20, %conv42
inst:   %add49 = fadd float %mul40, %mul48
inst:   %add77 = fadd float %add73, %add75
Non constants
Array Type: 3:float
Created array:   %60 = alloca float, i8 3, align 4
Gen:   %68 = load float, float* %67, align 4
Operands done!
Generated:   %69 = fsub float %66, %68
Found use: 0:   %sub56 = fsub float %sub, %sub52
Found use: 1:   %sub56 = fsub float %sub, %sub52
Found use: 2:   %sub95 = fsub float %add55, %sub86
Extracting:   %69 = fsub float %66, %68
Gen:   %70 = fsub float %67, %69
Closing REDUCTION
Found use: 0:   store float %add93, float* %arrayidx94, align 4, !tbaa !13
Found use: 1:   %sub95 = fsub float %add55, %sub86
Extracting:   %73 = fadd float %66, %71
Gen:   %74 = fadd float %67, %72
Graph code generated!
Root:
  %add93 = fadd float %add55, %sub86
  %add55 = fadd float %sub, %sub52
Root size: 2
digraph VTree {
0 [label="fadd red.", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="fsub", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->1 
3->1 
4 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
0->4
5 [label="fsub", style="filled" , fillcolor="#f2eb5c", shape=box];
0->5
6 [label="fsub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->6
1->6
1->5
}

Gains: 5 - 118 = -113; Width: 2; Reduction Unprofitable; jpeg_idct_float
  %sub99.sink = phi float [ %mul, %if.then ], [ %sub99, %if.end ]
  %sub95.sink = phi float [ %mul, %if.then ], [ %sub95, %if.end ]
  %sub91.sink = phi float [ %mul, %if.then ], [ %sub91, %if.end ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store float %sub99.sink, float* %29, align 4
  store float %sub95.sink, float* %30, align 4
  store float %sub91.sink, float* %31, align 4
Creating Node
  store float %sub99.sink, float* %29, align 4
  store float %sub95.sink, float* %30, align 4
  store float %sub91.sink, float* %31, align 4
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %sub99.sink = phi float [ %mul, %if.then ], [ %sub99, %if.end ]
  %sub95.sink = phi float [ %mul, %if.then ], [ %sub95, %if.end ]
  %sub91.sink = phi float [ %mul, %if.then ], [ %sub91, %if.end ]
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %sub99.sink = phi float [ %mul, %if.then ], [ %sub99, %if.end ]
Mismatching
Creating Node
  %29 = getelementptr inbounds float, float* %wsptr.0, i64 40
  %30 = getelementptr inbounds float, float* %wsptr.0, i64 48
  %31 = getelementptr inbounds float, float* %wsptr.0, i64 56
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
Match: 0
1 x 3
Final Match: 0
All the Same
Creating Node
i64 40
i64 48
i64 56
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 40
Int Seq
ScheduleNode: {
  store float %sub99.sink, float* %29, align 4
}
ScheduleNode: {
  store float %sub95.sink, float* %30, align 4
}
ScheduleNode: {
  store float %sub91.sink, float* %31, align 4
}
ScheduleNode: {
  store float %sub99.sink, float* %29, align 4
}
Count: 1
Start:   %29 = getelementptr inbounds float, float* %wsptr.0, i64 40
Non-memory:   %29 = getelementptr inbounds float, float* %wsptr.0, i64 40
Processing:   store float %sub99.sink, float* %29, align 4
Count: 1
Found:   store float %sub99.sink, float* %29, align 4
ScheduleNode: {
  store float %sub95.sink, float* %30, align 4
}
Non-memory:   %30 = getelementptr inbounds float, float* %wsptr.0, i64 48
Processing:   store float %sub95.sink, float* %30, align 4
Count: 1
Found:   store float %sub95.sink, float* %30, align 4
ScheduleNode: {
  store float %sub91.sink, float* %31, align 4
}
Non-memory:   %31 = getelementptr inbounds float, float* %wsptr.0, i64 56
Processing:   store float %sub91.sink, float* %31, align 4
Count: 1
Found:   store float %sub91.sink, float* %31, align 4
I:   %wsptr.1 = getelementptr inbounds float, float* %wsptr.0, i64 1
Last:   br label %for.cond, !llvm.loop !15
Schedulable: 1
Loop Rolling: jpeg_idct_float
Generating tree
Generating MATCH
Match: 
  store float %sub99.sink, float* %29, align 4
  store float %sub95.sink, float* %30, align 4
  store float %sub91.sink, float* %31, align 4
Generating Mismatch
Mismatched Values:
inst:   %sub99.sink = phi float [ %mul, %if.then ], [ %sub99, %if.end ]
inst:   %sub95.sink = phi float [ %mul, %if.then ], [ %sub95, %if.end ]
inst:   %sub91.sink = phi float [ %mul, %if.then ], [ %sub91, %if.end ]
Non constants
Array Type: 3:float
Created array:   %58 = alloca float, i8 3, align 4
Gen:   %64 = load float, float* %63, align 4
Generating MATCH
Match: 
  %29 = getelementptr inbounds float, float* %wsptr.0, i64 40
  %30 = getelementptr inbounds float, float* %wsptr.0, i64 48
  %31 = getelementptr inbounds float, float* %wsptr.0, i64 56
Generating IDENTICAL
Generating INTSEQ
Gen:   %67 = add i64 %66, 40
Operands done!
Generated:   %68 = getelementptr inbounds float, float* %wsptr.0, i64 %67
Gen:   %68 = getelementptr inbounds float, float* %wsptr.0, i64 %67
Operands done!
Generated:   store float %64, float* %68, align 1
Gen:   store float %64, float* %68, align 1
Graph code generated!
Root:
  store float %sub99.sink, float* %29, align 4
  store float %sub95.sink, float* %30, align 4
  store float %sub91.sink, float* %31, align 4
Root size: 3
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="40..56, 8", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->2 
4->2 
}

Gains: 9 - 51 = -42; Width: 3; Unprofitable; jpeg_idct_float
Trying AGAIN
Creating Node
  store float %sub99.sink, float* %29, align 4
  store float %sub95.sink, float* %30, align 4
  store float %sub91.sink, float* %31, align 4
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %sub99.sink = phi float [ %mul, %if.then ], [ %sub99, %if.end ]
  %sub95.sink = phi float [ %mul, %if.then ], [ %sub95, %if.end ]
  %sub91.sink = phi float [ %mul, %if.then ], [ %sub91, %if.end ]
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %sub99.sink = phi float [ %mul, %if.then ], [ %sub99, %if.end ]
Mismatching
Creating Node
  %29 = getelementptr inbounds float, float* %wsptr.0, i64 40
  %30 = getelementptr inbounds float, float* %wsptr.0, i64 48
  %31 = getelementptr inbounds float, float* %wsptr.0, i64 56
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %wsptr.0 = phi float* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
Match: 0
1 x 3
Final Match: 0
All the Same
Creating Node
i64 40
i64 48
i64 56
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 40
Int Seq
ScheduleNode: {
  store float %sub99.sink, float* %29, align 4
}
ScheduleNode: {
  store float %sub95.sink, float* %30, align 4
}
ScheduleNode: {
  store float %sub91.sink, float* %31, align 4
}
ScheduleNode: {
  store float %sub99.sink, float* %29, align 4
}
Count: 1
Start:   %29 = getelementptr inbounds float, float* %wsptr.0, i64 40
Non-memory:   %29 = getelementptr inbounds float, float* %wsptr.0, i64 40
Processing:   store float %sub99.sink, float* %29, align 4
Count: 1
Found:   store float %sub99.sink, float* %29, align 4
ScheduleNode: {
  store float %sub95.sink, float* %30, align 4
}
Non-memory:   %30 = getelementptr inbounds float, float* %wsptr.0, i64 48
Processing:   store float %sub95.sink, float* %30, align 4
Count: 1
Found:   store float %sub95.sink, float* %30, align 4
ScheduleNode: {
  store float %sub91.sink, float* %31, align 4
}
Non-memory:   %31 = getelementptr inbounds float, float* %wsptr.0, i64 56
Processing:   store float %sub91.sink, float* %31, align 4
Count: 1
Found:   store float %sub91.sink, float* %31, align 4
I:   %wsptr.1 = getelementptr inbounds float, float* %wsptr.0, i64 1
Last:   br label %for.cond, !llvm.loop !15
Schedulable: 1
Loop Rolling: jpeg_idct_float
Generating tree
Generating MATCH
Match: 
  store float %sub99.sink, float* %29, align 4
  store float %sub95.sink, float* %30, align 4
  store float %sub91.sink, float* %31, align 4
Generating Mismatch
Mismatched Values:
inst:   %sub99.sink = phi float [ %mul, %if.then ], [ %sub99, %if.end ]
inst:   %sub95.sink = phi float [ %mul, %if.then ], [ %sub95, %if.end ]
inst:   %sub91.sink = phi float [ %mul, %if.then ], [ %sub91, %if.end ]
Non constants
Array Type: 3:float
Created array:   %58 = alloca float, i8 3, align 4
Gen:   %64 = load float, float* %63, align 4
Generating MATCH
Match: 
  %29 = getelementptr inbounds float, float* %wsptr.0, i64 40
  %30 = getelementptr inbounds float, float* %wsptr.0, i64 48
  %31 = getelementptr inbounds float, float* %wsptr.0, i64 56
Generating IDENTICAL
Generating INTSEQ
Gen:   %67 = add i64 %66, 40
Operands done!
Generated:   %68 = getelementptr inbounds float, float* %wsptr.0, i64 %67
Gen:   %68 = getelementptr inbounds float, float* %wsptr.0, i64 %67
Operands done!
Generated:   store float %64, float* %68, align 1
Gen:   store float %64, float* %68, align 1
Graph code generated!
Root:
  store float %sub99.sink, float* %29, align 4
  store float %sub95.sink, float* %30, align 4
  store float %sub91.sink, float* %31, align 4
Root size: 3
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="40..56, 8", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->2 
4->2 
}

Gains: 9 - 51 = -42; Width: 3; Unprofitable; jpeg_idct_float
  %indvars.iv = phi i64 [ 0, %for.cond109.preheader ], [ %indvars.iv.next, %for.body112 ]
  %wsptr.2 = phi float* [ %arraydecay, %for.cond109.preheader ], [ %add.ptr227, %for.body112 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %43, i8* %add.ptr114, align 1, !tbaa !18
  store i8 %45, i8* %arrayidx172, align 1, !tbaa !18
  store i8 %47, i8* %arrayidx181, align 1, !tbaa !18
  store i8 %49, i8* %arrayidx190, align 1, !tbaa !18
  store i8 %51, i8* %arrayidx199, align 1, !tbaa !18
  store i8 %53, i8* %arrayidx208, align 1, !tbaa !18
  store i8 %55, i8* %arrayidx217, align 1, !tbaa !18
  store i8 %57, i8* %arrayidx226, align 1, !tbaa !18
Creating Node
  store i8 %43, i8* %add.ptr114, align 1, !tbaa !18
  store i8 %45, i8* %arrayidx172, align 1, !tbaa !18
  store i8 %47, i8* %arrayidx181, align 1, !tbaa !18
  store i8 %49, i8* %arrayidx190, align 1, !tbaa !18
  store i8 %51, i8* %arrayidx199, align 1, !tbaa !18
  store i8 %53, i8* %arrayidx208, align 1, !tbaa !18
  store i8 %55, i8* %arrayidx217, align 1, !tbaa !18
  store i8 %57, i8* %arrayidx226, align 1, !tbaa !18
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %43 = load i8, i8* %arrayidx162, align 1, !tbaa !18
  %45 = load i8, i8* %arrayidx171, align 1, !tbaa !18
  %47 = load i8, i8* %arrayidx180, align 1, !tbaa !18
  %49 = load i8, i8* %arrayidx189, align 1, !tbaa !18
  %51 = load i8, i8* %arrayidx198, align 1, !tbaa !18
  %53 = load i8, i8* %arrayidx207, align 1, !tbaa !18
  %55 = load i8, i8* %arrayidx216, align 1, !tbaa !18
  %57 = load i8, i8* %arrayidx225, align 1, !tbaa !18
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %arrayidx162 = getelementptr inbounds i8, i8* %add.ptr, i64 %and
  %arrayidx171 = getelementptr inbounds i8, i8* %add.ptr, i64 %and169
  %arrayidx180 = getelementptr inbounds i8, i8* %add.ptr, i64 %and178
  %arrayidx189 = getelementptr inbounds i8, i8* %add.ptr, i64 %and187
  %arrayidx198 = getelementptr inbounds i8, i8* %add.ptr, i64 %and196
  %arrayidx207 = getelementptr inbounds i8, i8* %add.ptr, i64 %and205
  %arrayidx216 = getelementptr inbounds i8, i8* %add.ptr, i64 %and214
  %arrayidx225 = getelementptr inbounds i8, i8* %add.ptr, i64 %and223
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
Match: 0
1 x 8
Final Match: 0
All the Same
Creating Node
  %and = and i64 %42, 1023
  %and169 = and i64 %44, 1023
  %and178 = and i64 %46, 1023
  %and187 = and i64 %48, 1023
  %and196 = and i64 %50, 1023
  %and205 = and i64 %52, 1023
  %and214 = and i64 %54, 1023
  %and223 = and i64 %56, 1023
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %42 = lshr i64 %add159, 3
  %44 = lshr i64 %add166, 3
  %46 = lshr i64 %add175, 3
  %48 = lshr i64 %add184, 3
  %50 = lshr i64 %add193, 3
  %52 = lshr i64 %add202, 3
  %54 = lshr i64 %add211, 3
  %56 = lshr i64 %add220, 3
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %add159 = add nsw i64 %conv158, 4
  %add166 = add nsw i64 %conv165, 4
  %add175 = add nsw i64 %conv174, 4
  %add184 = add nsw i64 %conv183, 4
  %add193 = add nsw i64 %conv192, 4
  %add202 = add nsw i64 %conv201, 4
  %add211 = add nsw i64 %conv210, 4
  %add220 = add nsw i64 %conv219, 4
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %conv158 = fptosi float %add157 to i64
  %conv165 = fptosi float %sub164 to i64
  %conv174 = fptosi float %add173 to i64
  %conv183 = fptosi float %sub182 to i64
  %conv192 = fptosi float %add191 to i64
  %conv201 = fptosi float %sub200 to i64
  %conv210 = fptosi float %add209 to i64
  %conv219 = fptosi float %sub218 to i64
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %add157 = fadd float %add129, %add145
  %sub164 = fsub float %add129, %add145
  %add173 = fadd float %add131, %sub154
  %sub182 = fsub float %add131, %sub154
  %add191 = fadd float %sub132, %sub155
  %sub200 = fsub float %sub132, %sub155
  %add209 = fadd float %sub130, %add156
  %sub218 = fsub float %sub130, %add156
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add157 = fadd float %add129, %add145
New Alternating Pattern:
1:  %add157 = fadd float %add129, %add145
1:  %add173 = fadd float %add131, %sub154
1:  %add191 = fadd float %sub132, %sub155
1:  %add209 = fadd float %sub130, %add156
2:  %sub164 = fsub float %add129, %add145
2:  %sub182 = fsub float %add131, %sub154
2:  %sub200 = fsub float %sub132, %sub155
2:  %sub218 = fsub float %sub130, %add156

for.body112:                                      ; preds = %for.cond109
  %arrayidx113 = getelementptr inbounds i8*, i8** %output_buf, i64 %indvars.iv
  %32 = load i8*, i8** %arrayidx113, align 8, !tbaa !17
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %33 = load float, float* %wsptr.2, align 4, !tbaa !13
  %arrayidx116 = getelementptr inbounds float, float* %wsptr.2, i64 4
  %34 = load float, float* %arrayidx116, align 4, !tbaa !13
  %add117 = fadd float %33, %34
  %sub120 = fsub float %33, %34
  %arrayidx121 = getelementptr inbounds float, float* %wsptr.2, i64 2
  %35 = load float, float* %arrayidx121, align 4, !tbaa !13
  %arrayidx122 = getelementptr inbounds float, float* %wsptr.2, i64 6
  %36 = load float, float* %arrayidx122, align 4, !tbaa !13
  %add123 = fadd float %35, %36
  %sub126 = fsub float %35, %36
  %mul127 = fmul float %sub126, 0x3FF6A09E60000000
  %sub128 = fsub float %mul127, %add123
  %add129 = fadd float %add117, %add123
  %sub130 = fsub float %add117, %add123
  %add131 = fadd float %sub120, %sub128
  %sub132 = fsub float %sub120, %sub128
  %arrayidx133 = getelementptr inbounds float, float* %wsptr.2, i64 5
  %37 = load float, float* %arrayidx133, align 4, !tbaa !13
  %arrayidx134 = getelementptr inbounds float, float* %wsptr.2, i64 3
  %38 = load float, float* %arrayidx134, align 4, !tbaa !13
  %add135 = fadd float %37, %38
  %sub138 = fsub float %37, %38
  %arrayidx139 = getelementptr inbounds float, float* %wsptr.2, i64 1
  %39 = load float, float* %arrayidx139, align 4, !tbaa !13
  %arrayidx140 = getelementptr inbounds float, float* %wsptr.2, i64 7
  %40 = load float, float* %arrayidx140, align 4, !tbaa !13
  %add141 = fadd float %39, %40
  %sub144 = fsub float %39, %40
  %add145 = fadd float %add135, %add141
  %sub146 = fsub float %add141, %add135
  %mul147 = fmul float %sub146, 0x3FF6A09E60000000
  %add148 = fadd float %sub138, %sub144
  %mul149 = fmul float %add148, 0x3FFD906BC0000000
  %mul150 = fmul float %sub144, 0x3FF1517A80000000
  %sub151 = fsub float %mul150, %mul149
  %mul152 = fmul float %sub138, 0x4004E7AEA0000000
  %41 = fsub float %mul149, %mul152
  %sub154 = fsub float %41, %add145
  %sub155 = fsub float %mul147, %sub154
  %add156 = fadd float %sub151, %sub155
  %add157 = fadd float %add129, %add145
  %conv158 = fptosi float %add157 to i64
  %add159 = add nsw i64 %conv158, 4
  %42 = lshr i64 %add159, 3
  %and = and i64 %42, 1023
  %arrayidx162 = getelementptr inbounds i8, i8* %add.ptr, i64 %and
  %43 = load i8, i8* %arrayidx162, align 1, !tbaa !18
  store i8 %43, i8* %add.ptr114, align 1, !tbaa !18
  %sub164 = fsub float %add129, %add145
  %conv165 = fptosi float %sub164 to i64
  %add166 = add nsw i64 %conv165, 4
  %44 = lshr i64 %add166, 3
  %and169 = and i64 %44, 1023
  %arrayidx171 = getelementptr inbounds i8, i8* %add.ptr, i64 %and169
  %45 = load i8, i8* %arrayidx171, align 1, !tbaa !18
  %arrayidx172 = getelementptr inbounds i8, i8* %add.ptr114, i64 7
  store i8 %45, i8* %arrayidx172, align 1, !tbaa !18
  %add173 = fadd float %add131, %sub154
  %conv174 = fptosi float %add173 to i64
  %add175 = add nsw i64 %conv174, 4
  %46 = lshr i64 %add175, 3
  %and178 = and i64 %46, 1023
  %arrayidx180 = getelementptr inbounds i8, i8* %add.ptr, i64 %and178
  %47 = load i8, i8* %arrayidx180, align 1, !tbaa !18
  %arrayidx181 = getelementptr inbounds i8, i8* %add.ptr114, i64 1
  store i8 %47, i8* %arrayidx181, align 1, !tbaa !18
  %sub182 = fsub float %add131, %sub154
  %conv183 = fptosi float %sub182 to i64
  %add184 = add nsw i64 %conv183, 4
  %48 = lshr i64 %add184, 3
  %and187 = and i64 %48, 1023
  %arrayidx189 = getelementptr inbounds i8, i8* %add.ptr, i64 %and187
  %49 = load i8, i8* %arrayidx189, align 1, !tbaa !18
  %arrayidx190 = getelementptr inbounds i8, i8* %add.ptr114, i64 6
  store i8 %49, i8* %arrayidx190, align 1, !tbaa !18
  %add191 = fadd float %sub132, %sub155
  %conv192 = fptosi float %add191 to i64
  %add193 = add nsw i64 %conv192, 4
  %50 = lshr i64 %add193, 3
  %and196 = and i64 %50, 1023
  %arrayidx198 = getelementptr inbounds i8, i8* %add.ptr, i64 %and196
  %51 = load i8, i8* %arrayidx198, align 1, !tbaa !18
  %arrayidx199 = getelementptr inbounds i8, i8* %add.ptr114, i64 2
  store i8 %51, i8* %arrayidx199, align 1, !tbaa !18
  %sub200 = fsub float %sub132, %sub155
  %conv201 = fptosi float %sub200 to i64
  %add202 = add nsw i64 %conv201, 4
  %52 = lshr i64 %add202, 3
  %and205 = and i64 %52, 1023
  %arrayidx207 = getelementptr inbounds i8, i8* %add.ptr, i64 %and205
  %53 = load i8, i8* %arrayidx207, align 1, !tbaa !18
  %arrayidx208 = getelementptr inbounds i8, i8* %add.ptr114, i64 5
  store i8 %53, i8* %arrayidx208, align 1, !tbaa !18
  %add209 = fadd float %sub130, %add156
  %conv210 = fptosi float %add209 to i64
  %add211 = add nsw i64 %conv210, 4
  %54 = lshr i64 %add211, 3
  %and214 = and i64 %54, 1023
  %arrayidx216 = getelementptr inbounds i8, i8* %add.ptr, i64 %and214
  %55 = load i8, i8* %arrayidx216, align 1, !tbaa !18
  %arrayidx217 = getelementptr inbounds i8, i8* %add.ptr114, i64 4
  store i8 %55, i8* %arrayidx217, align 1, !tbaa !18
  %sub218 = fsub float %sub130, %add156
  %conv219 = fptosi float %sub218 to i64
  %add220 = add nsw i64 %conv219, 4
  %56 = lshr i64 %add220, 3
  %and223 = and i64 %56, 1023
  %arrayidx225 = getelementptr inbounds i8, i8* %add.ptr, i64 %and223
  %57 = load i8, i8* %arrayidx225, align 1, !tbaa !18
  %arrayidx226 = getelementptr inbounds i8, i8* %add.ptr114, i64 3
  store i8 %57, i8* %arrayidx226, align 1, !tbaa !18
  %add.ptr227 = getelementptr inbounds float, float* %wsptr.2, i64 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond109, !llvm.loop !19

Mismatching
Creating Node
i64 4
i64 4
i64 4
i64 4
i64 4
i64 4
i64 4
i64 4
Match: 1
1 x 8
Final Match: 1
All the Same
Creating Node
i64 3
i64 3
i64 3
i64 3
i64 3
i64 3
i64 3
i64 3
Match: 1
1 x 8
Final Match: 1
All the Same
Creating Node
i64 1023
i64 1023
i64 1023
i64 1023
i64 1023
i64 1023
i64 1023
i64 1023
Match: 1
1 x 8
Final Match: 1
All the Same
Creating Node
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %arrayidx172 = getelementptr inbounds i8, i8* %add.ptr114, i64 7
  %arrayidx181 = getelementptr inbounds i8, i8* %add.ptr114, i64 1
  %arrayidx190 = getelementptr inbounds i8, i8* %add.ptr114, i64 6
  %arrayidx199 = getelementptr inbounds i8, i8* %add.ptr114, i64 2
  %arrayidx208 = getelementptr inbounds i8, i8* %add.ptr114, i64 5
  %arrayidx217 = getelementptr inbounds i8, i8* %add.ptr114, i64 4
  %arrayidx226 = getelementptr inbounds i8, i8* %add.ptr114, i64 3
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %32 = load i8*, i8** %arrayidx113, align 8, !tbaa !17
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
Match: 0
2 x 8
Final Match: 0
  %32 = load i8*, i8** %arrayidx113, align 8, !tbaa !17
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
Ptr:   %32 = load i8*, i8** %arrayidx113, align 8, !tbaa !17
AllGEPs: 0
GEP Seq
Creating Node
i64 0
  %idx.ext = zext i32 %output_col to i64
  %idx.ext = zext i32 %output_col to i64
  %idx.ext = zext i32 %output_col to i64
  %idx.ext = zext i32 %output_col to i64
  %idx.ext = zext i32 %output_col to i64
  %idx.ext = zext i32 %output_col to i64
  %idx.ext = zext i32 %output_col to i64
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
i64 0
Mismatching
Creating Node
  %idx.ext = zext i32 %output_col to i64
i64 7
i64 1
i64 6
i64 2
i64 5
i64 4
i64 3
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
  %idx.ext = zext i32 %output_col to i64
Mismatching
ScheduleNode: {
  %43 = load i8, i8* %arrayidx162, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %43, i8* %add.ptr114, align 1, !tbaa !18
}
ScheduleNode: {
  %45 = load i8, i8* %arrayidx171, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %45, i8* %arrayidx172, align 1, !tbaa !18
}
ScheduleNode: {
  %47 = load i8, i8* %arrayidx180, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %47, i8* %arrayidx181, align 1, !tbaa !18
}
ScheduleNode: {
  %49 = load i8, i8* %arrayidx189, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %49, i8* %arrayidx190, align 1, !tbaa !18
}
ScheduleNode: {
  %51 = load i8, i8* %arrayidx198, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %51, i8* %arrayidx199, align 1, !tbaa !18
}
ScheduleNode: {
  %53 = load i8, i8* %arrayidx207, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %53, i8* %arrayidx208, align 1, !tbaa !18
}
ScheduleNode: {
  %55 = load i8, i8* %arrayidx216, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %55, i8* %arrayidx217, align 1, !tbaa !18
}
ScheduleNode: {
  %57 = load i8, i8* %arrayidx225, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %57, i8* %arrayidx226, align 1, !tbaa !18
}
ScheduleNode: {
  %43 = load i8, i8* %arrayidx162, align 1, !tbaa !18
}
Count: 1
Start:   %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
Non-memory:   %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
Processing:   %33 = load float, float* %wsptr.2, align 4, !tbaa !13
Count: 1
Not found:   %33 = load float, float* %wsptr.2, align 4, !tbaa !13
Read/Write memory
I:   %33 = load float, float* %wsptr.2, align 4, !tbaa !13
Last:   br label %for.cond109, !llvm.loop !19
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="and", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="lshr", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="fptosi", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
9 [label="4", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="3", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="1023", style="filled" , fillcolor="#8ae18a", shape=box];
12 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
13 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
15 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
12->0 
2->1 
3->2 
4->2 
5->4 
11->4 
6->5 
10->5 
7->6 
9->6 
8->7 
13->12 
15->12 
14->13 
}


for.body112:                                      ; preds = %for.cond109
  %arrayidx113 = getelementptr inbounds i8*, i8** %output_buf, i64 %indvars.iv
  %32 = load i8*, i8** %arrayidx113, align 8, !tbaa !17
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %33 = load float, float* %wsptr.2, align 4, !tbaa !13
  %arrayidx116 = getelementptr inbounds float, float* %wsptr.2, i64 4
  %34 = load float, float* %arrayidx116, align 4, !tbaa !13
  %add117 = fadd float %33, %34
  %sub120 = fsub float %33, %34
  %arrayidx121 = getelementptr inbounds float, float* %wsptr.2, i64 2
  %35 = load float, float* %arrayidx121, align 4, !tbaa !13
  %arrayidx122 = getelementptr inbounds float, float* %wsptr.2, i64 6
  %36 = load float, float* %arrayidx122, align 4, !tbaa !13
  %add123 = fadd float %35, %36
  %sub126 = fsub float %35, %36
  %mul127 = fmul float %sub126, 0x3FF6A09E60000000
  %sub128 = fsub float %mul127, %add123
  %add129 = fadd float %add117, %add123
  %sub130 = fsub float %add117, %add123
  %add131 = fadd float %sub120, %sub128
  %sub132 = fsub float %sub120, %sub128
  %arrayidx133 = getelementptr inbounds float, float* %wsptr.2, i64 5
  %37 = load float, float* %arrayidx133, align 4, !tbaa !13
  %arrayidx134 = getelementptr inbounds float, float* %wsptr.2, i64 3
  %38 = load float, float* %arrayidx134, align 4, !tbaa !13
  %add135 = fadd float %37, %38
  %sub138 = fsub float %37, %38
  %arrayidx139 = getelementptr inbounds float, float* %wsptr.2, i64 1
  %39 = load float, float* %arrayidx139, align 4, !tbaa !13
  %arrayidx140 = getelementptr inbounds float, float* %wsptr.2, i64 7
  %40 = load float, float* %arrayidx140, align 4, !tbaa !13
  %add141 = fadd float %39, %40
  %sub144 = fsub float %39, %40
  %add145 = fadd float %add135, %add141
  %sub146 = fsub float %add141, %add135
  %mul147 = fmul float %sub146, 0x3FF6A09E60000000
  %add148 = fadd float %sub138, %sub144
  %mul149 = fmul float %add148, 0x3FFD906BC0000000
  %mul150 = fmul float %sub144, 0x3FF1517A80000000
  %sub151 = fsub float %mul150, %mul149
  %mul152 = fmul float %sub138, 0x4004E7AEA0000000
  %41 = fsub float %mul149, %mul152
  %sub154 = fsub float %41, %add145
  %sub155 = fsub float %mul147, %sub154
  %add156 = fadd float %sub151, %sub155
  %add157 = fadd float %add129, %add145
  %conv158 = fptosi float %add157 to i64
  %add159 = add nsw i64 %conv158, 4
  %42 = lshr i64 %add159, 3
  %and = and i64 %42, 1023
  %arrayidx162 = getelementptr inbounds i8, i8* %add.ptr, i64 %and
  %43 = load i8, i8* %arrayidx162, align 1, !tbaa !18
  store i8 %43, i8* %add.ptr114, align 1, !tbaa !18
  %sub164 = fsub float %add129, %add145
  %conv165 = fptosi float %sub164 to i64
  %add166 = add nsw i64 %conv165, 4
  %44 = lshr i64 %add166, 3
  %and169 = and i64 %44, 1023
  %arrayidx171 = getelementptr inbounds i8, i8* %add.ptr, i64 %and169
  %45 = load i8, i8* %arrayidx171, align 1, !tbaa !18
  %arrayidx172 = getelementptr inbounds i8, i8* %add.ptr114, i64 7
  store i8 %45, i8* %arrayidx172, align 1, !tbaa !18
  %add173 = fadd float %add131, %sub154
  %conv174 = fptosi float %add173 to i64
  %add175 = add nsw i64 %conv174, 4
  %46 = lshr i64 %add175, 3
  %and178 = and i64 %46, 1023
  %arrayidx180 = getelementptr inbounds i8, i8* %add.ptr, i64 %and178
  %47 = load i8, i8* %arrayidx180, align 1, !tbaa !18
  %arrayidx181 = getelementptr inbounds i8, i8* %add.ptr114, i64 1
  store i8 %47, i8* %arrayidx181, align 1, !tbaa !18
  %sub182 = fsub float %add131, %sub154
  %conv183 = fptosi float %sub182 to i64
  %add184 = add nsw i64 %conv183, 4
  %48 = lshr i64 %add184, 3
  %and187 = and i64 %48, 1023
  %arrayidx189 = getelementptr inbounds i8, i8* %add.ptr, i64 %and187
  %49 = load i8, i8* %arrayidx189, align 1, !tbaa !18
  %arrayidx190 = getelementptr inbounds i8, i8* %add.ptr114, i64 6
  store i8 %49, i8* %arrayidx190, align 1, !tbaa !18
  %add191 = fadd float %sub132, %sub155
  %conv192 = fptosi float %add191 to i64
  %add193 = add nsw i64 %conv192, 4
  %50 = lshr i64 %add193, 3
  %and196 = and i64 %50, 1023
  %arrayidx198 = getelementptr inbounds i8, i8* %add.ptr, i64 %and196
  %51 = load i8, i8* %arrayidx198, align 1, !tbaa !18
  %arrayidx199 = getelementptr inbounds i8, i8* %add.ptr114, i64 2
  store i8 %51, i8* %arrayidx199, align 1, !tbaa !18
  %sub200 = fsub float %sub132, %sub155
  %conv201 = fptosi float %sub200 to i64
  %add202 = add nsw i64 %conv201, 4
  %52 = lshr i64 %add202, 3
  %and205 = and i64 %52, 1023
  %arrayidx207 = getelementptr inbounds i8, i8* %add.ptr, i64 %and205
  %53 = load i8, i8* %arrayidx207, align 1, !tbaa !18
  %arrayidx208 = getelementptr inbounds i8, i8* %add.ptr114, i64 5
  store i8 %53, i8* %arrayidx208, align 1, !tbaa !18
  %add209 = fadd float %sub130, %add156
  %conv210 = fptosi float %add209 to i64
  %add211 = add nsw i64 %conv210, 4
  %54 = lshr i64 %add211, 3
  %and214 = and i64 %54, 1023
  %arrayidx216 = getelementptr inbounds i8, i8* %add.ptr, i64 %and214
  %55 = load i8, i8* %arrayidx216, align 1, !tbaa !18
  %arrayidx217 = getelementptr inbounds i8, i8* %add.ptr114, i64 4
  store i8 %55, i8* %arrayidx217, align 1, !tbaa !18
  %sub218 = fsub float %sub130, %add156
  %conv219 = fptosi float %sub218 to i64
  %add220 = add nsw i64 %conv219, 4
  %56 = lshr i64 %add220, 3
  %and223 = and i64 %56, 1023
  %arrayidx225 = getelementptr inbounds i8, i8* %add.ptr, i64 %and223
  %57 = load i8, i8* %arrayidx225, align 1, !tbaa !18
  %arrayidx226 = getelementptr inbounds i8, i8* %add.ptr114, i64 3
  store i8 %57, i8* %arrayidx226, align 1, !tbaa !18
  %add.ptr227 = getelementptr inbounds float, float* %wsptr.2, i64 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond109, !llvm.loop !19

Trying AGAIN
Creating Node
  store i8 %43, i8* %add.ptr114, align 1, !tbaa !18
  store i8 %45, i8* %arrayidx172, align 1, !tbaa !18
  store i8 %47, i8* %arrayidx181, align 1, !tbaa !18
  store i8 %49, i8* %arrayidx190, align 1, !tbaa !18
  store i8 %51, i8* %arrayidx199, align 1, !tbaa !18
  store i8 %53, i8* %arrayidx208, align 1, !tbaa !18
  store i8 %55, i8* %arrayidx217, align 1, !tbaa !18
  store i8 %57, i8* %arrayidx226, align 1, !tbaa !18
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %43 = load i8, i8* %arrayidx162, align 1, !tbaa !18
  %45 = load i8, i8* %arrayidx171, align 1, !tbaa !18
  %47 = load i8, i8* %arrayidx180, align 1, !tbaa !18
  %49 = load i8, i8* %arrayidx189, align 1, !tbaa !18
  %51 = load i8, i8* %arrayidx198, align 1, !tbaa !18
  %53 = load i8, i8* %arrayidx207, align 1, !tbaa !18
  %55 = load i8, i8* %arrayidx216, align 1, !tbaa !18
  %57 = load i8, i8* %arrayidx225, align 1, !tbaa !18
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %arrayidx162 = getelementptr inbounds i8, i8* %add.ptr, i64 %and
  %arrayidx171 = getelementptr inbounds i8, i8* %add.ptr, i64 %and169
  %arrayidx180 = getelementptr inbounds i8, i8* %add.ptr, i64 %and178
  %arrayidx189 = getelementptr inbounds i8, i8* %add.ptr, i64 %and187
  %arrayidx198 = getelementptr inbounds i8, i8* %add.ptr, i64 %and196
  %arrayidx207 = getelementptr inbounds i8, i8* %add.ptr, i64 %and205
  %arrayidx216 = getelementptr inbounds i8, i8* %add.ptr, i64 %and214
  %arrayidx225 = getelementptr inbounds i8, i8* %add.ptr, i64 %and223
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 128
Match: 0
1 x 8
Final Match: 0
All the Same
Creating Node
  %and = and i64 %42, 1023
  %and169 = and i64 %44, 1023
  %and178 = and i64 %46, 1023
  %and187 = and i64 %48, 1023
  %and196 = and i64 %50, 1023
  %and205 = and i64 %52, 1023
  %and214 = and i64 %54, 1023
  %and223 = and i64 %56, 1023
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %42 = lshr i64 %add159, 3
  %44 = lshr i64 %add166, 3
  %46 = lshr i64 %add175, 3
  %48 = lshr i64 %add184, 3
  %50 = lshr i64 %add193, 3
  %52 = lshr i64 %add202, 3
  %54 = lshr i64 %add211, 3
  %56 = lshr i64 %add220, 3
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %add159 = add nsw i64 %conv158, 4
  %add166 = add nsw i64 %conv165, 4
  %add175 = add nsw i64 %conv174, 4
  %add184 = add nsw i64 %conv183, 4
  %add193 = add nsw i64 %conv192, 4
  %add202 = add nsw i64 %conv201, 4
  %add211 = add nsw i64 %conv210, 4
  %add220 = add nsw i64 %conv219, 4
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %conv158 = fptosi float %add157 to i64
  %conv165 = fptosi float %sub164 to i64
  %conv174 = fptosi float %add173 to i64
  %conv183 = fptosi float %sub182 to i64
  %conv192 = fptosi float %add191 to i64
  %conv201 = fptosi float %sub200 to i64
  %conv210 = fptosi float %add209 to i64
  %conv219 = fptosi float %sub218 to i64
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %add157 = fadd float %add129, %add145
  %sub164 = fsub float %add129, %add145
  %add173 = fadd float %add131, %sub154
  %sub182 = fsub float %add131, %sub154
  %add191 = fadd float %sub132, %sub155
  %sub200 = fsub float %sub132, %sub155
  %add209 = fadd float %sub130, %add156
  %sub218 = fsub float %sub130, %add156
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add157 = fadd float %add129, %add145
New Alternating Pattern:
1:  %add157 = fadd float %add129, %add145
1:  %add173 = fadd float %add131, %sub154
1:  %add191 = fadd float %sub132, %sub155
1:  %add209 = fadd float %sub130, %add156
2:  %sub164 = fsub float %add129, %add145
2:  %sub182 = fsub float %add131, %sub154
2:  %sub200 = fsub float %sub132, %sub155
2:  %sub218 = fsub float %sub130, %add156

for.body112:                                      ; preds = %for.cond109
  %arrayidx113 = getelementptr inbounds i8*, i8** %output_buf, i64 %indvars.iv
  %32 = load i8*, i8** %arrayidx113, align 8, !tbaa !17
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %33 = load float, float* %wsptr.2, align 4, !tbaa !13
  %arrayidx116 = getelementptr inbounds float, float* %wsptr.2, i64 4
  %34 = load float, float* %arrayidx116, align 4, !tbaa !13
  %add117 = fadd float %33, %34
  %sub120 = fsub float %33, %34
  %arrayidx121 = getelementptr inbounds float, float* %wsptr.2, i64 2
  %35 = load float, float* %arrayidx121, align 4, !tbaa !13
  %arrayidx122 = getelementptr inbounds float, float* %wsptr.2, i64 6
  %36 = load float, float* %arrayidx122, align 4, !tbaa !13
  %add123 = fadd float %35, %36
  %sub126 = fsub float %35, %36
  %mul127 = fmul float %sub126, 0x3FF6A09E60000000
  %sub128 = fsub float %mul127, %add123
  %add129 = fadd float %add117, %add123
  %sub130 = fsub float %add117, %add123
  %add131 = fadd float %sub120, %sub128
  %sub132 = fsub float %sub120, %sub128
  %arrayidx133 = getelementptr inbounds float, float* %wsptr.2, i64 5
  %37 = load float, float* %arrayidx133, align 4, !tbaa !13
  %arrayidx134 = getelementptr inbounds float, float* %wsptr.2, i64 3
  %38 = load float, float* %arrayidx134, align 4, !tbaa !13
  %add135 = fadd float %37, %38
  %sub138 = fsub float %37, %38
  %arrayidx139 = getelementptr inbounds float, float* %wsptr.2, i64 1
  %39 = load float, float* %arrayidx139, align 4, !tbaa !13
  %arrayidx140 = getelementptr inbounds float, float* %wsptr.2, i64 7
  %40 = load float, float* %arrayidx140, align 4, !tbaa !13
  %add141 = fadd float %39, %40
  %sub144 = fsub float %39, %40
  %add145 = fadd float %add135, %add141
  %sub146 = fsub float %add141, %add135
  %mul147 = fmul float %sub146, 0x3FF6A09E60000000
  %add148 = fadd float %sub138, %sub144
  %mul149 = fmul float %add148, 0x3FFD906BC0000000
  %mul150 = fmul float %sub144, 0x3FF1517A80000000
  %sub151 = fsub float %mul150, %mul149
  %mul152 = fmul float %sub138, 0x4004E7AEA0000000
  %41 = fsub float %mul149, %mul152
  %sub154 = fsub float %41, %add145
  %sub155 = fsub float %mul147, %sub154
  %add156 = fadd float %sub151, %sub155
  %add157 = fadd float %add129, %add145
  %conv158 = fptosi float %add157 to i64
  %add159 = add nsw i64 %conv158, 4
  %42 = lshr i64 %add159, 3
  %and = and i64 %42, 1023
  %arrayidx162 = getelementptr inbounds i8, i8* %add.ptr, i64 %and
  %43 = load i8, i8* %arrayidx162, align 1, !tbaa !18
  store i8 %43, i8* %add.ptr114, align 1, !tbaa !18
  %sub164 = fsub float %add129, %add145
  %conv165 = fptosi float %sub164 to i64
  %add166 = add nsw i64 %conv165, 4
  %44 = lshr i64 %add166, 3
  %and169 = and i64 %44, 1023
  %arrayidx171 = getelementptr inbounds i8, i8* %add.ptr, i64 %and169
  %45 = load i8, i8* %arrayidx171, align 1, !tbaa !18
  %arrayidx172 = getelementptr inbounds i8, i8* %add.ptr114, i64 7
  store i8 %45, i8* %arrayidx172, align 1, !tbaa !18
  %add173 = fadd float %add131, %sub154
  %conv174 = fptosi float %add173 to i64
  %add175 = add nsw i64 %conv174, 4
  %46 = lshr i64 %add175, 3
  %and178 = and i64 %46, 1023
  %arrayidx180 = getelementptr inbounds i8, i8* %add.ptr, i64 %and178
  %47 = load i8, i8* %arrayidx180, align 1, !tbaa !18
  %arrayidx181 = getelementptr inbounds i8, i8* %add.ptr114, i64 1
  store i8 %47, i8* %arrayidx181, align 1, !tbaa !18
  %sub182 = fsub float %add131, %sub154
  %conv183 = fptosi float %sub182 to i64
  %add184 = add nsw i64 %conv183, 4
  %48 = lshr i64 %add184, 3
  %and187 = and i64 %48, 1023
  %arrayidx189 = getelementptr inbounds i8, i8* %add.ptr, i64 %and187
  %49 = load i8, i8* %arrayidx189, align 1, !tbaa !18
  %arrayidx190 = getelementptr inbounds i8, i8* %add.ptr114, i64 6
  store i8 %49, i8* %arrayidx190, align 1, !tbaa !18
  %add191 = fadd float %sub132, %sub155
  %conv192 = fptosi float %add191 to i64
  %add193 = add nsw i64 %conv192, 4
  %50 = lshr i64 %add193, 3
  %and196 = and i64 %50, 1023
  %arrayidx198 = getelementptr inbounds i8, i8* %add.ptr, i64 %and196
  %51 = load i8, i8* %arrayidx198, align 1, !tbaa !18
  %arrayidx199 = getelementptr inbounds i8, i8* %add.ptr114, i64 2
  store i8 %51, i8* %arrayidx199, align 1, !tbaa !18
  %sub200 = fsub float %sub132, %sub155
  %conv201 = fptosi float %sub200 to i64
  %add202 = add nsw i64 %conv201, 4
  %52 = lshr i64 %add202, 3
  %and205 = and i64 %52, 1023
  %arrayidx207 = getelementptr inbounds i8, i8* %add.ptr, i64 %and205
  %53 = load i8, i8* %arrayidx207, align 1, !tbaa !18
  %arrayidx208 = getelementptr inbounds i8, i8* %add.ptr114, i64 5
  store i8 %53, i8* %arrayidx208, align 1, !tbaa !18
  %add209 = fadd float %sub130, %add156
  %conv210 = fptosi float %add209 to i64
  %add211 = add nsw i64 %conv210, 4
  %54 = lshr i64 %add211, 3
  %and214 = and i64 %54, 1023
  %arrayidx216 = getelementptr inbounds i8, i8* %add.ptr, i64 %and214
  %55 = load i8, i8* %arrayidx216, align 1, !tbaa !18
  %arrayidx217 = getelementptr inbounds i8, i8* %add.ptr114, i64 4
  store i8 %55, i8* %arrayidx217, align 1, !tbaa !18
  %sub218 = fsub float %sub130, %add156
  %conv219 = fptosi float %sub218 to i64
  %add220 = add nsw i64 %conv219, 4
  %56 = lshr i64 %add220, 3
  %and223 = and i64 %56, 1023
  %arrayidx225 = getelementptr inbounds i8, i8* %add.ptr, i64 %and223
  %57 = load i8, i8* %arrayidx225, align 1, !tbaa !18
  %arrayidx226 = getelementptr inbounds i8, i8* %add.ptr114, i64 3
  store i8 %57, i8* %arrayidx226, align 1, !tbaa !18
  %add.ptr227 = getelementptr inbounds float, float* %wsptr.2, i64 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond109, !llvm.loop !19

Mismatching
Creating Node
i64 4
i64 4
i64 4
i64 4
i64 4
i64 4
i64 4
i64 4
Match: 1
1 x 8
Final Match: 1
All the Same
Creating Node
i64 3
i64 3
i64 3
i64 3
i64 3
i64 3
i64 3
i64 3
Match: 1
1 x 8
Final Match: 1
All the Same
Creating Node
i64 1023
i64 1023
i64 1023
i64 1023
i64 1023
i64 1023
i64 1023
i64 1023
Match: 1
1 x 8
Final Match: 1
All the Same
Creating Node
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %arrayidx172 = getelementptr inbounds i8, i8* %add.ptr114, i64 7
  %arrayidx181 = getelementptr inbounds i8, i8* %add.ptr114, i64 1
  %arrayidx190 = getelementptr inbounds i8, i8* %add.ptr114, i64 6
  %arrayidx199 = getelementptr inbounds i8, i8* %add.ptr114, i64 2
  %arrayidx208 = getelementptr inbounds i8, i8* %add.ptr114, i64 5
  %arrayidx217 = getelementptr inbounds i8, i8* %add.ptr114, i64 4
  %arrayidx226 = getelementptr inbounds i8, i8* %add.ptr114, i64 3
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %32 = load i8*, i8** %arrayidx113, align 8, !tbaa !17
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
Match: 0
2 x 8
Final Match: 0
  %32 = load i8*, i8** %arrayidx113, align 8, !tbaa !17
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
Ptr:   %32 = load i8*, i8** %arrayidx113, align 8, !tbaa !17
AllGEPs: 0
GEP Seq
Creating Node
i64 0
  %idx.ext = zext i32 %output_col to i64
  %idx.ext = zext i32 %output_col to i64
  %idx.ext = zext i32 %output_col to i64
  %idx.ext = zext i32 %output_col to i64
  %idx.ext = zext i32 %output_col to i64
  %idx.ext = zext i32 %output_col to i64
  %idx.ext = zext i32 %output_col to i64
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
i64 0
Mismatching
Creating Node
  %idx.ext = zext i32 %output_col to i64
i64 7
i64 1
i64 6
i64 2
i64 5
i64 4
i64 3
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
  %idx.ext = zext i32 %output_col to i64
Mismatching
ScheduleNode: {
  %43 = load i8, i8* %arrayidx162, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %43, i8* %add.ptr114, align 1, !tbaa !18
}
ScheduleNode: {
  %45 = load i8, i8* %arrayidx171, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %45, i8* %arrayidx172, align 1, !tbaa !18
}
ScheduleNode: {
  %47 = load i8, i8* %arrayidx180, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %47, i8* %arrayidx181, align 1, !tbaa !18
}
ScheduleNode: {
  %49 = load i8, i8* %arrayidx189, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %49, i8* %arrayidx190, align 1, !tbaa !18
}
ScheduleNode: {
  %51 = load i8, i8* %arrayidx198, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %51, i8* %arrayidx199, align 1, !tbaa !18
}
ScheduleNode: {
  %53 = load i8, i8* %arrayidx207, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %53, i8* %arrayidx208, align 1, !tbaa !18
}
ScheduleNode: {
  %55 = load i8, i8* %arrayidx216, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %55, i8* %arrayidx217, align 1, !tbaa !18
}
ScheduleNode: {
  %57 = load i8, i8* %arrayidx225, align 1, !tbaa !18
}
ScheduleNode: {
  store i8 %57, i8* %arrayidx226, align 1, !tbaa !18
}
ScheduleNode: {
  %43 = load i8, i8* %arrayidx162, align 1, !tbaa !18
}
Count: 1
Start:   %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
Non-memory:   %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
Processing:   %33 = load float, float* %wsptr.2, align 4, !tbaa !13
Count: 1
Not found:   %33 = load float, float* %wsptr.2, align 4, !tbaa !13
Read/Write memory
I:   %33 = load float, float* %wsptr.2, align 4, !tbaa !13
Last:   br label %for.cond109, !llvm.loop !19
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="and", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="lshr", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="fptosi", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
9 [label="4", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="3", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="1023", style="filled" , fillcolor="#8ae18a", shape=box];
12 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
13 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
15 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
12->0 
2->1 
3->2 
4->2 
5->4 
11->4 
6->5 
10->5 
7->6 
9->6 
8->7 
13->12 
15->12 
14->13 
}


for.body112:                                      ; preds = %for.cond109
  %arrayidx113 = getelementptr inbounds i8*, i8** %output_buf, i64 %indvars.iv
  %32 = load i8*, i8** %arrayidx113, align 8, !tbaa !17
  %add.ptr114 = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %33 = load float, float* %wsptr.2, align 4, !tbaa !13
  %arrayidx116 = getelementptr inbounds float, float* %wsptr.2, i64 4
  %34 = load float, float* %arrayidx116, align 4, !tbaa !13
  %add117 = fadd float %33, %34
  %sub120 = fsub float %33, %34
  %arrayidx121 = getelementptr inbounds float, float* %wsptr.2, i64 2
  %35 = load float, float* %arrayidx121, align 4, !tbaa !13
  %arrayidx122 = getelementptr inbounds float, float* %wsptr.2, i64 6
  %36 = load float, float* %arrayidx122, align 4, !tbaa !13
  %add123 = fadd float %35, %36
  %sub126 = fsub float %35, %36
  %mul127 = fmul float %sub126, 0x3FF6A09E60000000
  %sub128 = fsub float %mul127, %add123
  %add129 = fadd float %add117, %add123
  %sub130 = fsub float %add117, %add123
  %add131 = fadd float %sub120, %sub128
  %sub132 = fsub float %sub120, %sub128
  %arrayidx133 = getelementptr inbounds float, float* %wsptr.2, i64 5
  %37 = load float, float* %arrayidx133, align 4, !tbaa !13
  %arrayidx134 = getelementptr inbounds float, float* %wsptr.2, i64 3
  %38 = load float, float* %arrayidx134, align 4, !tbaa !13
  %add135 = fadd float %37, %38
  %sub138 = fsub float %37, %38
  %arrayidx139 = getelementptr inbounds float, float* %wsptr.2, i64 1
  %39 = load float, float* %arrayidx139, align 4, !tbaa !13
  %arrayidx140 = getelementptr inbounds float, float* %wsptr.2, i64 7
  %40 = load float, float* %arrayidx140, align 4, !tbaa !13
  %add141 = fadd float %39, %40
  %sub144 = fsub float %39, %40
  %add145 = fadd float %add135, %add141
  %sub146 = fsub float %add141, %add135
  %mul147 = fmul float %sub146, 0x3FF6A09E60000000
  %add148 = fadd float %sub138, %sub144
  %mul149 = fmul float %add148, 0x3FFD906BC0000000
  %mul150 = fmul float %sub144, 0x3FF1517A80000000
  %sub151 = fsub float %mul150, %mul149
  %mul152 = fmul float %sub138, 0x4004E7AEA0000000
  %41 = fsub float %mul149, %mul152
  %sub154 = fsub float %41, %add145
  %sub155 = fsub float %mul147, %sub154
  %add156 = fadd float %sub151, %sub155
  %add157 = fadd float %add129, %add145
  %conv158 = fptosi float %add157 to i64
  %add159 = add nsw i64 %conv158, 4
  %42 = lshr i64 %add159, 3
  %and = and i64 %42, 1023
  %arrayidx162 = getelementptr inbounds i8, i8* %add.ptr, i64 %and
  %43 = load i8, i8* %arrayidx162, align 1, !tbaa !18
  store i8 %43, i8* %add.ptr114, align 1, !tbaa !18
  %sub164 = fsub float %add129, %add145
  %conv165 = fptosi float %sub164 to i64
  %add166 = add nsw i64 %conv165, 4
  %44 = lshr i64 %add166, 3
  %and169 = and i64 %44, 1023
  %arrayidx171 = getelementptr inbounds i8, i8* %add.ptr, i64 %and169
  %45 = load i8, i8* %arrayidx171, align 1, !tbaa !18
  %arrayidx172 = getelementptr inbounds i8, i8* %add.ptr114, i64 7
  store i8 %45, i8* %arrayidx172, align 1, !tbaa !18
  %add173 = fadd float %add131, %sub154
  %conv174 = fptosi float %add173 to i64
  %add175 = add nsw i64 %conv174, 4
  %46 = lshr i64 %add175, 3
  %and178 = and i64 %46, 1023
  %arrayidx180 = getelementptr inbounds i8, i8* %add.ptr, i64 %and178
  %47 = load i8, i8* %arrayidx180, align 1, !tbaa !18
  %arrayidx181 = getelementptr inbounds i8, i8* %add.ptr114, i64 1
  store i8 %47, i8* %arrayidx181, align 1, !tbaa !18
  %sub182 = fsub float %add131, %sub154
  %conv183 = fptosi float %sub182 to i64
  %add184 = add nsw i64 %conv183, 4
  %48 = lshr i64 %add184, 3
  %and187 = and i64 %48, 1023
  %arrayidx189 = getelementptr inbounds i8, i8* %add.ptr, i64 %and187
  %49 = load i8, i8* %arrayidx189, align 1, !tbaa !18
  %arrayidx190 = getelementptr inbounds i8, i8* %add.ptr114, i64 6
  store i8 %49, i8* %arrayidx190, align 1, !tbaa !18
  %add191 = fadd float %sub132, %sub155
  %conv192 = fptosi float %add191 to i64
  %add193 = add nsw i64 %conv192, 4
  %50 = lshr i64 %add193, 3
  %and196 = and i64 %50, 1023
  %arrayidx198 = getelementptr inbounds i8, i8* %add.ptr, i64 %and196
  %51 = load i8, i8* %arrayidx198, align 1, !tbaa !18
  %arrayidx199 = getelementptr inbounds i8, i8* %add.ptr114, i64 2
  store i8 %51, i8* %arrayidx199, align 1, !tbaa !18
  %sub200 = fsub float %sub132, %sub155
  %conv201 = fptosi float %sub200 to i64
  %add202 = add nsw i64 %conv201, 4
  %52 = lshr i64 %add202, 3
  %and205 = and i64 %52, 1023
  %arrayidx207 = getelementptr inbounds i8, i8* %add.ptr, i64 %and205
  %53 = load i8, i8* %arrayidx207, align 1, !tbaa !18
  %arrayidx208 = getelementptr inbounds i8, i8* %add.ptr114, i64 5
  store i8 %53, i8* %arrayidx208, align 1, !tbaa !18
  %add209 = fadd float %sub130, %add156
  %conv210 = fptosi float %add209 to i64
  %add211 = add nsw i64 %conv210, 4
  %54 = lshr i64 %add211, 3
  %and214 = and i64 %54, 1023
  %arrayidx216 = getelementptr inbounds i8, i8* %add.ptr, i64 %and214
  %55 = load i8, i8* %arrayidx216, align 1, !tbaa !18
  %arrayidx217 = getelementptr inbounds i8, i8* %add.ptr114, i64 4
  store i8 %55, i8* %arrayidx217, align 1, !tbaa !18
  %sub218 = fsub float %sub130, %add156
  %conv219 = fptosi float %sub218 to i64
  %add220 = add nsw i64 %conv219, 4
  %56 = lshr i64 %add220, 3
  %and223 = and i64 %56, 1023
  %arrayidx225 = getelementptr inbounds i8, i8* %add.ptr, i64 %and223
  %57 = load i8, i8* %arrayidx225, align 1, !tbaa !18
  %arrayidx226 = getelementptr inbounds i8, i8* %add.ptr114, i64 3
  store i8 %57, i8* %arrayidx226, align 1, !tbaa !18
  %add.ptr227 = getelementptr inbounds float, float* %wsptr.2, i64 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond109, !llvm.loop !19

looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 0/9
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/rdtarga.c -o src/rdtarga.o   -mllvm -reroll-loops=3
Optimizing: jinit_read_targa
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store %struct.jpeg_compress_struct* %cinfo, %struct.jpeg_compress_struct** %3, align 8, !tbaa !13
Done Loop Roller: 0/0
Nothing found in: jinit_read_targa
Optimizing: read_byte
looking for reduction
looking for reduction
Attempting Group:
  %call = tail call i32 @_IO_getc(%struct._IO_FILE* %0) #3
looking for reduction
looking for reduction
Attempting Group:
  store i32 42, i32* %msg_code, align 8, !tbaa !14
looking for reduction
Done Loop Roller: 0/0
Nothing found in: read_byte
Optimizing: read_colormap
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1032, i32* %msg_code, align 8, !tbaa !13
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %if.end ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv13, i8* %arrayidx17, align 1, !tbaa !19
Attempting Group:
  store i8 %conv, i8* %arrayidx5, align 1, !tbaa !19
Attempting Group:
  store i8 %conv7, i8* %arrayidx11, align 1, !tbaa !19
Attempting Group:
  %call = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
  %call6 = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
  %call12 = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
Creating Node
  %call = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
  %call6 = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
  %call12 = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
%struct._tga_source_struct* %sinfo
%struct._tga_source_struct* %sinfo
%struct._tga_source_struct* %sinfo
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
Function: read_byte
Function: read_byte
Function: read_byte
Match: 1
1 x 3
Final Match: 1
All the Same
ScheduleNode: {
  %call = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
}
ScheduleNode: {
  %call6 = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
}
ScheduleNode: {
  %call12 = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
}
ScheduleNode: {
  %call = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
}
Count: 1
Start:   %call = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
Processing:   %call = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
Count: 1
Found:   %call = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
ScheduleNode: {
  %call6 = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
}
Non-memory:   %conv = trunc i32 %call to i8
Processing:   %5 = load i8**, i8*** %colormap, align 8, !tbaa !17
Count: 1
Not found:   %5 = load i8**, i8*** %colormap, align 8, !tbaa !17
Read/Write memory
I:   %5 = load i8**, i8*** %colormap, align 8, !tbaa !17
Last:   br label %for.cond, !llvm.loop !20
Schedulable: 0
digraph VTree {
0 [label="call: read_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="func: read_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->3
4 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->4
5 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->5
}


for.body:                                         ; preds = %for.cond
  %call = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
  %conv = trunc i32 %call to i8
  %5 = load i8**, i8*** %colormap, align 8, !tbaa !17
  %arrayidx = getelementptr inbounds i8*, i8** %5, i64 2
  %6 = load i8*, i8** %arrayidx, align 8, !tbaa !18
  %arrayidx5 = getelementptr inbounds i8, i8* %6, i64 %indvars.iv
  store i8 %conv, i8* %arrayidx5, align 1, !tbaa !19
  %call6 = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
  %conv7 = trunc i32 %call6 to i8
  %7 = load i8**, i8*** %colormap, align 8, !tbaa !17
  %arrayidx9 = getelementptr inbounds i8*, i8** %7, i64 1
  %8 = load i8*, i8** %arrayidx9, align 8, !tbaa !18
  %arrayidx11 = getelementptr inbounds i8, i8* %8, i64 %indvars.iv
  store i8 %conv7, i8* %arrayidx11, align 1, !tbaa !19
  %call12 = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %sinfo) #4
  %conv13 = trunc i32 %call12 to i8
  %9 = load i8**, i8*** %colormap, align 8, !tbaa !17
  %10 = load i8*, i8** %9, align 8, !tbaa !18
  %arrayidx17 = getelementptr inbounds i8, i8* %10, i64 %indvars.iv
  store i8 %conv13, i8* %arrayidx17, align 1, !tbaa !19
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond, !llvm.loop !20

looking for reduction
Done Loop Roller: 0/0
Nothing found in: read_colormap
Optimizing: start_input_tga
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  %call = call i64 @fread(i8* nonnull %1, i64 1, i64 18, %struct._IO_FILE* %2) #4
looking for reduction
looking for reduction
Attempting Group:
  store i32 42, i32* %msg_code, align 8, !tbaa !13
looking for reduction
looking for reduction
Attempting Group:
  store i8 16, i8* %arrayidx, align 16, !tbaa !17
  %7 = phi i8 [ 16, %if.then4 ], [ %6, %if.end ]
looking for reduction
looking for reduction
  %or.cond313 = or i1 %cmp43, %or.cond312
Found
Attempting Group:
  store i32 %18, i32* %pixel_size, align 4, !tbaa !18
Building reduction
  br i1 %or.cond313, label %if.then54, label %lor.lhs.false45
  %or.cond313 = or i1 %cmp43, %or.cond312
BOs:
  %or.cond313 = or i1 %cmp43, %or.cond312
  %or.cond312 = or i1 %cmp36, %cmp39
Operands:
  %cmp43 = icmp ugt i8 %7, 39
  %cmp36 = icmp ugt i8 %9, 1
  %cmp39 = icmp eq i8 %17, 0
Operands:
  %cmp36 = icmp ugt i8 %9, 1
  %cmp43 = icmp ugt i8 %7, 39
  %cmp39 = icmp eq i8 %17, 0
ReductionNode
Creating Node
  %cmp36 = icmp ugt i8 %9, 1
  %cmp43 = icmp ugt i8 %7, 39
  %cmp39 = icmp eq i8 %17, 0
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %9 = load i8, i8* %arrayidx9, align 1, !tbaa !17
  %7 = phi i8 [ 16, %if.then4 ], [ %6, %if.end ]
  %17 = lshr i8 %7, 3
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %9 = load i8, i8* %arrayidx9, align 1, !tbaa !17
Mismatching
Creating Node
i8 1
i8 39
i8 0
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i8 1
Mismatching
Empty scheduling entries
Loop Rolling: start_input_tga
Generating tree
Generating REDUCTION
Generating MATCH
Match: 
  %cmp36 = icmp ugt i8 %9, 1
  %cmp43 = icmp ugt i8 %7, 39
  %cmp39 = icmp eq i8 %17, 0
Generating Mismatch
Mismatched Values:
inst:   %9 = load i8, i8* %arrayidx9, align 1, !tbaa !17
inst:   %7 = phi i8 [ 16, %if.then4 ], [ %6, %if.end ]
inst:   %17 = lshr i8 %7, 3
Non constants
Array Type: 3:i8
Created array:   %97 = alloca i8, i8 3, align 1
Gen:   %103 = load i8, i8* %102, align 1
Generating Mismatch
Mismatched Values:
int: i8 1
int: i8 39
int: i8 0
All constants
Created array: @0 = private constant [3 x i8] c"\01'\00"
Gen:   %105 = load i8, i8* %104, align 1
Operands done!
Generated:   %106 = icmp ugt i8 %103, %105
Gen:   %106 = icmp ugt i8 %103, %105
Closing REDUCTION
Found use: 0:   br i1 %or.cond313, label %if.then54, label %lor.lhs.false45
Extracting:   %108 = or i1 %102, %107
Gen:   %108 = or i1 %102, %107
Graph code generated!
Root:
  %or.cond313 = or i1 %cmp43, %or.cond312
  %or.cond312 = or i1 %cmp36, %cmp39
Root size: 2
digraph VTree {
0 [label="or red.", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="icmp", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->1 
3->1 
4 [label="br", style="filled" , fillcolor="#f2eb5c", shape=box];
0->4
}

Gains: 5 - 47 = -42; Width: 2; Reduction Unprofitable; start_input_tga
looking for reduction
  %or.cond = or i1 %cmp49, %cmp52
looking for reduction
looking for reduction
Attempting Group:
  store i32 1033, i32* %msg_code56, align 8, !tbaa !13
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct._tga_source_struct*)* @read_rle_pixel, void (%struct._tga_source_struct*)** %24, align 8, !tbaa !19
looking for reduction
Attempting Group:
  store void (%struct._tga_source_struct*)* @read_non_rle_pixel, void (%struct._tga_source_struct*)** %26, align 8, !tbaa !19
  %subtype.0 = phi i32 [ %sub, %if.then62 ], [ %conv12, %if.else ]
looking for reduction
Attempting Group:
  store i32 2, i32* %in_color_space, align 4, !tbaa !22
looking for reduction
  %or.cond201 = and i1 %cmp68, %cmp66
looking for reduction
Attempting Group:
  store i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)* @get_8bit_row, i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)** %28, align 8, !tbaa !23
looking for reduction
looking for reduction
Attempting Group:
  store i32 1033, i32* %msg_code73, align 8, !tbaa !13
  %.pre-phi = phi %struct.jpeg_common_struct* [ %31, %if.else71 ], [ %.pre, %if.then70 ]
looking for reduction
looking for reduction
  %add22 = or i32 %shl21, %conv18
looking for reduction
  %add28 = or i32 %shl27, %conv24
looking for reduction
looking for reduction
Attempting Group:
  store i32 %add28, i32* %arrayidx84, align 4, !tbaa !17
Attempting Group:
  store i32 1037, i32* %msg_code78, align 8, !tbaa !13
  store i32 %add22, i32* %arrayidx80, align 4, !tbaa !17
Creating Node
  store i32 1037, i32* %msg_code78, align 8, !tbaa !13
  store i32 %add22, i32* %arrayidx80, align 4, !tbaa !17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 1037
  %add22 = or i32 %shl21, %conv18
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1037
BinOp Seq
Creating Node
i32 1037
  %shl21 = shl nuw nsw i32 %conv20, 8
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1037
Alt Seq
Creating Node
i32 0
  %conv18 = zext i8 %13 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
  %msg_code78 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %32, i64 0, i32 5
  %arrayidx80 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %32, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code78 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %32, i64 0, i32 5
  %arrayidx80 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %32, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code78 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %32, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 1037, i32* %msg_code78, align 8, !tbaa !13
}
ScheduleNode: {
  store i32 %add22, i32* %arrayidx80, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 1037, i32* %msg_code78, align 8, !tbaa !13
}
Count: 1
Start:   store i32 1037, i32* %msg_code78, align 8, !tbaa !13
Processing:   store i32 1037, i32* %msg_code78, align 8, !tbaa !13
Count: 1
Found:   store i32 1037, i32* %msg_code78, align 8, !tbaa !13
ScheduleNode: {
  store i32 %add22, i32* %arrayidx80, align 4, !tbaa !17
}
Non-memory:   %arrayidx80 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %32, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %add22, i32* %arrayidx80, align 4, !tbaa !17
Count: 1
Found:   store i32 %add22, i32* %arrayidx80, align 4, !tbaa !17
I:   %33 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err77, align 8, !tbaa !9
Last:   br label %sw.epilog140
Schedulable: 1
Loop Rolling: start_input_tga
Generating tree
Generating MATCH
Match: 
  store i32 1037, i32* %msg_code78, align 8, !tbaa !13
  store i32 %add22, i32* %arrayidx80, align 4, !tbaa !17
Generating BINOP
Generating ALTSEQ
Values:
i32 1037
  %shl21 = shl nuw nsw i32 %conv20, 8
Generated Version 4:
  %98 = icmp eq i8 %97, 0
  %99 = select i1 %98, i32 1037, i32 %shl21
Generating ALTSEQ
Values:
i32 0
  %conv18 = zext i8 %13 to i32
Generated Version 4:
  %100 = select i1 %98, i32 0, i32 %conv18
Closing BINOP
Gen:   %101 = or i32 %99, %100
Generating ALTSEQ
Values:
  %msg_code78 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %32, i64 0, i32 5
  %arrayidx80 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %32, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %102 = select i1 %98, i32* %msg_code78, i32* %arrayidx80
Operands done!
Generated:   store i32 %101, i32* %102, align 1
Gen:   store i32 %101, i32* %102, align 1
Graph code generated!
Root:
  store i32 1037, i32* %msg_code78, align 8, !tbaa !13
  store i32 %add22, i32* %arrayidx80, align 4, !tbaa !17
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="or seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: 1037, %shl21", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: 0, %conv18", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %msg_code78, %arrayidx80", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
5 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
1->5
}

Gains: 5 - 8 = -3; Width: 2; Unprofitable; start_input_tga
Trying AGAIN
Trying AGAIN
looking for reduction
Attempting Group:
  store i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)* @get_16bit_row, i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)** %37, align 8, !tbaa !23
looking for reduction
Attempting Group:
  store i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)* @get_24bit_row, i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)** %38, align 8, !tbaa !23
looking for reduction
Attempting Group:
  store i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)* @get_24bit_row, i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)** %39, align 8, !tbaa !23
looking for reduction
looking for reduction
Attempting Group:
  store i32 1033, i32* %msg_code95, align 8, !tbaa !13
looking for reduction
looking for reduction
  %add22 = or i32 %shl21, %conv18
looking for reduction
  %add28 = or i32 %shl27, %conv24
looking for reduction
looking for reduction
Attempting Group:
  store i32 %add28, i32* %arrayidx107, align 4, !tbaa !17
Attempting Group:
  store i32 1035, i32* %msg_code99, align 8, !tbaa !13
  store i32 %add22, i32* %arrayidx103, align 4, !tbaa !17
Creating Node
  store i32 1035, i32* %msg_code99, align 8, !tbaa !13
  store i32 %add22, i32* %arrayidx103, align 4, !tbaa !17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 1035
  %add22 = or i32 %shl21, %conv18
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1035
BinOp Seq
Creating Node
i32 1035
  %shl21 = shl nuw nsw i32 %conv20, 8
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1035
Alt Seq
Creating Node
i32 0
  %conv18 = zext i8 %13 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
  %msg_code99 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 5
  %arrayidx103 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code99 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 5
  %arrayidx103 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code99 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 1035, i32* %msg_code99, align 8, !tbaa !13
}
ScheduleNode: {
  store i32 %add22, i32* %arrayidx103, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 1035, i32* %msg_code99, align 8, !tbaa !13
}
Count: 1
Start:   store i32 1035, i32* %msg_code99, align 8, !tbaa !13
Processing:   store i32 1035, i32* %msg_code99, align 8, !tbaa !13
Count: 1
Found:   store i32 1035, i32* %msg_code99, align 8, !tbaa !13
ScheduleNode: {
  store i32 %add22, i32* %arrayidx103, align 4, !tbaa !17
}
Non-memory:   %arrayidx103 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %add22, i32* %arrayidx103, align 4, !tbaa !17
Count: 1
Found:   store i32 %add22, i32* %arrayidx103, align 4, !tbaa !17
I:   %44 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err98, align 8, !tbaa !9
Last:   br label %sw.epilog140
Schedulable: 1
Loop Rolling: start_input_tga
Generating tree
Generating MATCH
Match: 
  store i32 1035, i32* %msg_code99, align 8, !tbaa !13
  store i32 %add22, i32* %arrayidx103, align 4, !tbaa !17
Generating BINOP
Generating ALTSEQ
Values:
i32 1035
  %shl21 = shl nuw nsw i32 %conv20, 8
Generated Version 4:
  %98 = icmp eq i8 %97, 0
  %99 = select i1 %98, i32 1035, i32 %shl21
Generating ALTSEQ
Values:
i32 0
  %conv18 = zext i8 %13 to i32
Generated Version 4:
  %100 = select i1 %98, i32 0, i32 %conv18
Closing BINOP
Gen:   %101 = or i32 %99, %100
Generating ALTSEQ
Values:
  %msg_code99 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 5
  %arrayidx103 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %102 = select i1 %98, i32* %msg_code99, i32* %arrayidx103
Operands done!
Generated:   store i32 %101, i32* %102, align 1
Gen:   store i32 %101, i32* %102, align 1
Graph code generated!
Root:
  store i32 1035, i32* %msg_code99, align 8, !tbaa !13
  store i32 %add22, i32* %arrayidx103, align 4, !tbaa !17
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="or seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: 1035, %shl21", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: 0, %conv18", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %msg_code99, %arrayidx103", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
5 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
1->5
}

Gains: 5 - 8 = -3; Width: 2; Unprofitable; start_input_tga
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %in_color_space, align 4, !tbaa !22
looking for reduction
Attempting Group:
  store i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)* @get_8bit_gray_row, i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)** %49, align 8, !tbaa !23
looking for reduction
looking for reduction
Attempting Group:
  store i32 1033, i32* %msg_code119, align 8, !tbaa !13
  %.pre-phi315 = phi %struct.jpeg_common_struct* [ %52, %if.else117 ], [ %.pre314, %if.then115 ]
looking for reduction
looking for reduction
  %add22 = or i32 %shl21, %conv18
looking for reduction
  %add28 = or i32 %shl27, %conv24
looking for reduction
looking for reduction
Attempting Group:
  store i32 %add28, i32* %arrayidx132, align 4, !tbaa !17
Attempting Group:
  store i32 1036, i32* %msg_code124, align 8, !tbaa !13
  store i32 %add22, i32* %arrayidx128, align 4, !tbaa !17
Creating Node
  store i32 1036, i32* %msg_code124, align 8, !tbaa !13
  store i32 %add22, i32* %arrayidx128, align 4, !tbaa !17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 1036
  %add22 = or i32 %shl21, %conv18
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1036
BinOp Seq
Creating Node
i32 1036
  %shl21 = shl nuw nsw i32 %conv20, 8
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1036
Alt Seq
Creating Node
i32 0
  %conv18 = zext i8 %13 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
  %msg_code124 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %53, i64 0, i32 5
  %arrayidx128 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %53, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code124 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %53, i64 0, i32 5
  %arrayidx128 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %53, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code124 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %53, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 1036, i32* %msg_code124, align 8, !tbaa !13
}
ScheduleNode: {
  store i32 %add22, i32* %arrayidx128, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 1036, i32* %msg_code124, align 8, !tbaa !13
}
Count: 1
Start:   store i32 1036, i32* %msg_code124, align 8, !tbaa !13
Processing:   store i32 1036, i32* %msg_code124, align 8, !tbaa !13
Count: 1
Found:   store i32 1036, i32* %msg_code124, align 8, !tbaa !13
ScheduleNode: {
  store i32 %add22, i32* %arrayidx128, align 4, !tbaa !17
}
Non-memory:   %arrayidx128 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %53, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %add22, i32* %arrayidx128, align 4, !tbaa !17
Count: 1
Found:   store i32 %add22, i32* %arrayidx128, align 4, !tbaa !17
I:   %54 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err123, align 8, !tbaa !9
Last:   br label %sw.epilog140
Schedulable: 1
Loop Rolling: start_input_tga
Generating tree
Generating MATCH
Match: 
  store i32 1036, i32* %msg_code124, align 8, !tbaa !13
  store i32 %add22, i32* %arrayidx128, align 4, !tbaa !17
Generating BINOP
Generating ALTSEQ
Values:
i32 1036
  %shl21 = shl nuw nsw i32 %conv20, 8
Generated Version 4:
  %98 = icmp eq i8 %97, 0
  %99 = select i1 %98, i32 1036, i32 %shl21
Generating ALTSEQ
Values:
i32 0
  %conv18 = zext i8 %13 to i32
Generated Version 4:
  %100 = select i1 %98, i32 0, i32 %conv18
Closing BINOP
Gen:   %101 = or i32 %99, %100
Generating ALTSEQ
Values:
  %msg_code124 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %53, i64 0, i32 5
  %arrayidx128 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %53, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %102 = select i1 %98, i32* %msg_code124, i32* %arrayidx128
Operands done!
Generated:   store i32 %101, i32* %102, align 1
Gen:   store i32 %101, i32* %102, align 1
Graph code generated!
Root:
  store i32 1036, i32* %msg_code124, align 8, !tbaa !13
  store i32 %add22, i32* %arrayidx128, align 4, !tbaa !17
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="or seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: 1036, %shl21", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: 0, %conv18", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %msg_code124, %arrayidx128", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
5 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
1->5
}

Gains: 5 - 8 = -3; Width: 2; Unprofitable; start_input_tga
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
Attempting Group:
  store i32 1033, i32* %msg_code137, align 8, !tbaa !13
  %components.0 = phi i32 [ 3, %sw.default135 ], [ 1, %if.end122 ], [ 3, %sw.epilog ], [ 3, %if.end76 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul = mul nuw nsw i32 %components.0, %add22
looking for reduction
  %add28 = or i32 %shl27, %conv24
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store %struct.jvirt_sarray_control* %call142, %struct.jvirt_sarray_control** %63, align 8, !tbaa !28
looking for reduction
  %inc = add nsw i32 %66, 1
Attempting Group:
  store i32 %inc, i32* %total_extra_passes, align 4, !tbaa !30
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %buffer_height, align 8, !tbaa !33
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul155 = mul nuw nsw i32 %components.0, %add22
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store %struct.jvirt_sarray_control* null, %struct.jvirt_sarray_control** %67, align 8, !tbaa !28
  %idlen.0 = phi i32 [ %conv8, %if.end163 ], [ %dec, %while.body ]
looking for reduction
looking for reduction
Attempting Group:
  %call165 = tail call fastcc i32 @read_byte(%struct._tga_source_struct* %0) #4
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1032, i32* %msg_code182, align 8, !tbaa !13
  %.pre-phi317 = phi %struct.jpeg_common_struct* [ %.pre316, %lor.lhs.false171.if.end185_crit_edge ], [ %77, %if.then180 ]
looking for reduction
looking for reduction
looking for reduction
  %add = or i32 %shl, %conv14
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8** %call188, i8*** %80, align 8, !tbaa !39
looking for reduction
looking for reduction
Attempting Group:
  store i32 1032, i32* %msg_code.i, align 8, !tbaa !13
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body.i ], [ 0, %if.end.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv.i, i8* %arrayidx5.i, align 1, !tbaa !17
Attempting Group:
  store i8 %conv13.i, i8* %arrayidx17.i, align 1, !tbaa !17
Attempting Group:
  store i8 %conv7.i, i8* %arrayidx11.i, align 1, !tbaa !17
Attempting Group:
  %call.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
  %call6.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
  %call12.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
Creating Node
  %call.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
  %call6.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
  %call12.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %0 = bitcast %struct.cjpeg_source_struct* %sinfo to %struct._tga_source_struct*
  %0 = bitcast %struct.cjpeg_source_struct* %sinfo to %struct._tga_source_struct*
  %0 = bitcast %struct.cjpeg_source_struct* %sinfo to %struct._tga_source_struct*
Match: 0
1 x 3
Final Match: 0
All the Same
Creating Node
Function: read_byte
Function: read_byte
Function: read_byte
Match: 1
1 x 3
Final Match: 1
All the Same
ScheduleNode: {
  %call.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
}
ScheduleNode: {
  %call6.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
}
ScheduleNode: {
  %call12.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
}
ScheduleNode: {
  %call.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
}
Count: 1
Start:   %call.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
Processing:   %call.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
Count: 1
Found:   %call.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
ScheduleNode: {
  %call6.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
}
Non-memory:   %conv.i = trunc i32 %call.i to i8
Processing:   %87 = load i8**, i8*** %80, align 8, !tbaa !39
Count: 1
Not found:   %87 = load i8**, i8*** %80, align 8, !tbaa !39
Read/Write memory
I:   %87 = load i8**, i8*** %80, align 8, !tbaa !39
Last:   br label %for.cond.i, !llvm.loop !42
Schedulable: 0
digraph VTree {
0 [label="call: read_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="func: read_byte", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->3
4 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->4
5 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->5
}


for.body.i:                                       ; preds = %for.cond.i
  %call.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
  %conv.i = trunc i32 %call.i to i8
  %87 = load i8**, i8*** %80, align 8, !tbaa !39
  %arrayidx.i = getelementptr inbounds i8*, i8** %87, i64 2
  %88 = load i8*, i8** %arrayidx.i, align 8, !tbaa !41
  %arrayidx5.i = getelementptr inbounds i8, i8* %88, i64 %indvars.iv.i
  store i8 %conv.i, i8* %arrayidx5.i, align 1, !tbaa !17
  %call6.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
  %conv7.i = trunc i32 %call6.i to i8
  %89 = load i8**, i8*** %80, align 8, !tbaa !39
  %arrayidx9.i = getelementptr inbounds i8*, i8** %89, i64 1
  %90 = load i8*, i8** %arrayidx9.i, align 8, !tbaa !41
  %arrayidx11.i = getelementptr inbounds i8, i8* %90, i64 %indvars.iv.i
  store i8 %conv7.i, i8* %arrayidx11.i, align 1, !tbaa !17
  %call12.i = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %0) #5
  %conv13.i = trunc i32 %call12.i to i8
  %91 = load i8**, i8*** %80, align 8, !tbaa !39
  %92 = load i8*, i8** %91, align 8, !tbaa !41
  %arrayidx17.i = getelementptr inbounds i8, i8* %92, i64 %indvars.iv.i
  store i8 %conv13.i, i8* %arrayidx17.i, align 1, !tbaa !17
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  br label %for.cond.i, !llvm.loop !42

looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1033, i32* %msg_code195, align 8, !tbaa !13
looking for reduction
Attempting Group:
  store i8** null, i8*** %96, align 8, !tbaa !39
looking for reduction
looking for reduction
looking for reduction
  %add22 = or i32 %shl21, %conv18
looking for reduction
  %add28 = or i32 %shl27, %conv24
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %components.0, i32* %input_components, align 8, !tbaa !43
  store i32 8, i32* %data_precision, align 8, !tbaa !44
  store i32 %add22, i32* %image_width, align 8, !tbaa !45
  store i32 %add28, i32* %image_height, align 4, !tbaa !46
Creating Node
  store i32 %components.0, i32* %input_components, align 8, !tbaa !43
  store i32 8, i32* %data_precision, align 8, !tbaa !44
  store i32 %add22, i32* %image_width, align 8, !tbaa !45
  store i32 %add28, i32* %image_height, align 4, !tbaa !46
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %components.0 = phi i32 [ 3, %sw.default135 ], [ 1, %if.end122 ], [ 3, %sw.epilog ], [ 3, %if.end76 ]
i32 8
  %add22 = or i32 %shl21, %conv18
  %add28 = or i32 %shl27, %conv24
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %components.0 = phi i32 [ 3, %sw.default135 ], [ 1, %if.end122 ], [ 3, %sw.epilog ], [ 3, %if.end76 ]
BinOp Seq
Creating Node
  %components.0 = phi i32 [ 3, %sw.default135 ], [ 1, %if.end122 ], [ 3, %sw.epilog ], [ 3, %if.end76 ]
i32 8
  %shl21 = shl nuw nsw i32 %conv20, 8
  %shl27 = shl nuw nsw i32 %conv26, 8
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %components.0 = phi i32 [ 3, %sw.default135 ], [ 1, %if.end122 ], [ 3, %sw.epilog ], [ 3, %if.end76 ]
Mismatching
Creating Node
i32 0
i32 0
  %conv18 = zext i8 %13 to i32
  %conv24 = zext i8 %15 to i32
Match: 0
3 x 4
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %input_components = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 8
  %data_precision = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 11
  %image_width = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
Match: 0
4 x 4
Final Match: 0
  %input_components = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 8
  %data_precision = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 11
  %image_width = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %input_components = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 8
Mismatching
ScheduleNode: {
  store i32 %components.0, i32* %input_components, align 8, !tbaa !43
}
ScheduleNode: {
  store i32 8, i32* %data_precision, align 8, !tbaa !44
}
ScheduleNode: {
  store i32 %add22, i32* %image_width, align 8, !tbaa !45
}
ScheduleNode: {
  store i32 %add28, i32* %image_height, align 4, !tbaa !46
}
ScheduleNode: {
  store i32 %components.0, i32* %input_components, align 8, !tbaa !43
}
Count: 1
Start:   store i32 %components.0, i32* %input_components, align 8, !tbaa !43
Processing:   store i32 %components.0, i32* %input_components, align 8, !tbaa !43
Count: 1
Found:   store i32 %components.0, i32* %input_components, align 8, !tbaa !43
ScheduleNode: {
  store i32 8, i32* %data_precision, align 8, !tbaa !44
}
Non-memory:   %data_precision = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 11
Processing:   store i32 8, i32* %data_precision, align 8, !tbaa !44
Count: 1
Found:   store i32 8, i32* %data_precision, align 8, !tbaa !44
ScheduleNode: {
  store i32 %add22, i32* %image_width, align 8, !tbaa !45
}
Non-memory:   %image_width = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
Processing:   store i32 %add22, i32* %image_width, align 8, !tbaa !45
Count: 1
Found:   store i32 %add22, i32* %image_width, align 8, !tbaa !45
ScheduleNode: {
  store i32 %add28, i32* %image_height, align 4, !tbaa !46
}
Non-memory:   %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
Processing:   store i32 %add28, i32* %image_height, align 4, !tbaa !46
Count: 1
Found:   store i32 %add28, i32* %image_height, align 4, !tbaa !46
I:   call void @llvm.lifetime.end.p0i8(i64 18, i8* nonnull %1) #3
Last:   ret void
Schedulable: 1
Loop Rolling: start_input_tga
Generating tree
Generating MATCH
Match: 
  store i32 %components.0, i32* %input_components, align 8, !tbaa !43
  store i32 8, i32* %data_precision, align 8, !tbaa !44
  store i32 %add22, i32* %image_width, align 8, !tbaa !45
  store i32 %add28, i32* %image_height, align 4, !tbaa !46
Generating BINOP
Generating Mismatch
Mismatched Values:
inst:   %components.0 = phi i32 [ 3, %sw.default135 ], [ 1, %if.end122 ], [ 3, %sw.epilog ], [ 3, %if.end76 ]
int: i32 8
inst:   %shl21 = shl nuw nsw i32 %conv20, 8
inst:   %shl27 = shl nuw nsw i32 %conv26, 8
Non constants
Array Type: 4:i32
Created array:   %97 = alloca i32, i8 4, align 4
Gen:   %104 = load i32, i32* %103, align 4
Generating Mismatch
Mismatched Values:
int: i32 0
int: i32 0
inst:   %conv18 = zext i8 %13 to i32
inst:   %conv24 = zext i8 %15 to i32
Non constants
Array Type: 4:i32
Created array:   %102 = alloca i32, i8 4, align 4
Gen:   %111 = load i32, i32* %110, align 4
Closing BINOP
Gen:   %112 = or i32 %109, %111
Generating Mismatch
Mismatched Values:
inst:   %input_components = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 8
inst:   %data_precision = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 11
inst:   %image_width = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
inst:   %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
Non constants
Array Type: 4:i32*
Created array:   %107 = alloca i32*, i8 4, align 8
Gen:   %119 = load i32*, i32** %118, align 8
Operands done!
Generated:   store i32 %117, i32* %119, align 1
Gen:   store i32 %117, i32* %119, align 1
Graph code generated!
Root:
  store i32 %components.0, i32* %input_components, align 8, !tbaa !43
  store i32 8, i32* %data_precision, align 8, !tbaa !44
  store i32 %add22, i32* %image_width, align 8, !tbaa !45
  store i32 %add28, i32* %image_height, align 4, !tbaa !46
Root size: 4
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="or seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
4 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
4->0 
2->1 
3->1 
5 [label="mul", style="filled" , fillcolor="#f2eb5c", shape=box];
1->5
6 [label="call", style="filled" , fillcolor="#f2eb5c", shape=box];
1->6
}

Gains: 10 - 158 = -148; Width: 4; Unprofitable; start_input_tga
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Done Loop Roller: 0/5
Optimizing: finish_input_tga
looking for reduction
Done Loop Roller: 0/0
Nothing found in: finish_input_tga
Optimizing: read_rle_pixel
looking for reduction
looking for reduction
  %dec = add nsw i32 %1, -1
Attempting Group:
  store i32 %dec, i32* %dup_pixel_count, align 4, !tbaa !9
looking for reduction
  %dec2 = add nsw i32 %2, -1
looking for reduction
Attempting Group:
  store i32 %dec2, i32* %block_count, align 8, !tbaa !10
looking for reduction
looking for reduction
Attempting Group:
  %call = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %sinfo) #4
looking for reduction
  %and6 = and i32 %call, 127
looking for reduction
Attempting Group:
  store i32 %and6, i32* %dup_pixel_count, align 4, !tbaa !9
  store i32 0, i32* %block_count, align 8, !tbaa !10
Creating Node
  store i32 %and6, i32* %dup_pixel_count, align 4, !tbaa !9
  store i32 0, i32* %block_count, align 8, !tbaa !10
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %and6 = and i32 %call, 127
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %and6 = and i32 %call, 127
BinOp Seq
Creating Node
  %call = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %sinfo) #4
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %call = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %sinfo) #4
Alt Seq
Creating Node
i32 127
i32 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 127
Int Seq
Creating Node
  %dup_pixel_count = getelementptr inbounds %struct._tga_source_struct, %struct._tga_source_struct* %sinfo, i64 0, i32 9
  %block_count = getelementptr inbounds %struct._tga_source_struct, %struct._tga_source_struct* %sinfo, i64 0, i32 8
Match: 0
2 x 2
Final Match: 0
  %dup_pixel_count = getelementptr inbounds %struct._tga_source_struct, %struct._tga_source_struct* %sinfo, i64 0, i32 9
  %block_count = getelementptr inbounds %struct._tga_source_struct, %struct._tga_source_struct* %sinfo, i64 0, i32 8
GEPSeq2
%struct._tga_source_struct = type { %struct.cjpeg_source_struct, %struct.jpeg_compress_struct*, i8**, %struct.jvirt_sarray_control*, i32, void (%struct._tga_source_struct*)*, [4 x i8], i32, i32, i32, i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)* }
BinOP?
  %dup_pixel_count = getelementptr inbounds %struct._tga_source_struct, %struct._tga_source_struct* %sinfo, i64 0, i32 9
Alt Seq
ScheduleNode: {
  store i32 %and6, i32* %dup_pixel_count, align 4, !tbaa !9
}
ScheduleNode: {
  store i32 0, i32* %block_count, align 8, !tbaa !10
}
ScheduleNode: {
  store i32 %and6, i32* %dup_pixel_count, align 4, !tbaa !9
}
Count: 1
Start:   %and6 = and i32 %call, 127
Non-memory:   %and6 = and i32 %call, 127
Processing:   store i32 %and6, i32* %dup_pixel_count, align 4, !tbaa !9
Count: 1
Found:   store i32 %and6, i32* %dup_pixel_count, align 4, !tbaa !9
ScheduleNode: {
  store i32 0, i32* %block_count, align 8, !tbaa !10
}
Processing:   store i32 0, i32* %block_count, align 8, !tbaa !10
Count: 1
Found:   store i32 0, i32* %block_count, align 8, !tbaa !10
I:   br label %if.end12
Last:   br label %if.end12
Schedulable: 1
Loop Rolling: read_rle_pixel
Generating tree
Generating MATCH
Match: 
  store i32 %and6, i32* %dup_pixel_count, align 4, !tbaa !9
  store i32 0, i32* %block_count, align 8, !tbaa !10
Generating BINOP
Generating ALTSEQ
Values:
  %call = tail call fastcc i32 @read_byte(%struct._tga_source_struct* nonnull %sinfo) #4
i32 0
Generated Version 4:
  %7 = icmp eq i8 %6, 0
  %8 = select i1 %7, i32 %call, i32 0
Generating INTSEQ
Gen:   %11 = add i32 %10, 127
Closing BINOP
Gen:   %12 = and i32 %8, %11
Generating ALTSEQ
Values:
  %dup_pixel_count = getelementptr inbounds %struct._tga_source_struct, %struct._tga_source_struct* %sinfo, i64 0, i32 9
  %block_count = getelementptr inbounds %struct._tga_source_struct, %struct._tga_source_struct* %sinfo, i64 0, i32 8
Generated Version 4:
  %13 = select i1 %7, i32* %dup_pixel_count, i32* %block_count
Operands done!
Generated:   store i32 %12, i32* %13, align 1
Gen:   store i32 %12, i32* %13, align 1
Graph code generated!
Root:
  store i32 %and6, i32* %dup_pixel_count, align 4, !tbaa !9
  store i32 0, i32* %block_count, align 8, !tbaa !10
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="and seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %call, 0", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="127..1, -126", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %dup_pixel_count, %block_count", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
}

Gains: 6 - 12 = -6; Width: 2; Unprofitable; read_rle_pixel
Trying AGAIN
Trying AGAIN
looking for reduction
  %and9 = and i32 %call, 127
Attempting Group:
  store i32 %and9, i32* %block_count, align 8, !tbaa !10
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %if.end12 ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv, i8* %arrayidx, align 1, !tbaa !12
Attempting Group:
  %call14 = tail call i32 @_IO_getc(%struct._IO_FILE* %0) #4
looking for reduction
Done Loop Roller: 0/1
Optimizing: read_non_rle_pixel
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv, i8* %arrayidx, align 1, !tbaa !10
Attempting Group:
  %call = tail call i32 @_IO_getc(%struct._IO_FILE* %0) #5
looking for reduction
Done Loop Roller: 0/0
Nothing found in: read_non_rle_pixel
Optimizing: get_8bit_row
  %col.0 = phi i32 [ %5, %entry ], [ %dec, %for.body ]
  %ptr.0 = phi i8* [ %4, %entry ], [ %incdec.ptr12, %for.body ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %10, i8* %ptr.0, align 1, !tbaa !16
  store i8 %12, i8* %incdec.ptr, align 1, !tbaa !16
  store i8 %14, i8* %incdec.ptr8, align 1, !tbaa !16
Creating Node
  store i8 %10, i8* %ptr.0, align 1, !tbaa !16
  store i8 %12, i8* %incdec.ptr, align 1, !tbaa !16
  store i8 %14, i8* %incdec.ptr8, align 1, !tbaa !16
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %10 = load i8, i8* %arrayidx4, align 1, !tbaa !16
  %12 = load i8, i8* %arrayidx7, align 1, !tbaa !16
  %14 = load i8, i8* %arrayidx11, align 1, !tbaa !16
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %arrayidx4 = getelementptr inbounds i8, i8* %9, i64 %idxprom
  %arrayidx7 = getelementptr inbounds i8, i8* %11, i64 %idxprom
  %arrayidx11 = getelementptr inbounds i8, i8* %13, i64 %idxprom
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %9 = load i8*, i8** %2, align 8, !tbaa !10
  %11 = load i8*, i8** %arrayidx5, align 8, !tbaa !10
  %13 = load i8*, i8** %arrayidx9, align 8, !tbaa !10
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %2 = load i8**, i8*** %1, align 8, !tbaa !2
  %arrayidx5 = getelementptr inbounds i8*, i8** %2, i64 1
  %arrayidx9 = getelementptr inbounds i8*, i8** %2, i64 2
Match: 0
3 x 3
Final Match: 0
  %2 = load i8**, i8*** %1, align 8, !tbaa !2
  %arrayidx5 = getelementptr inbounds i8*, i8** %2, i64 1
  %arrayidx9 = getelementptr inbounds i8*, i8** %2, i64 2
GEPSeq2
BinOP?
  %2 = load i8**, i8*** %1, align 8, !tbaa !2
Mismatching
Creating Node
  %idxprom = zext i8 %8 to i64
  %idxprom = zext i8 %8 to i64
  %idxprom = zext i8 %8 to i64
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
  %ptr.0 = phi i8* [ %4, %entry ], [ %incdec.ptr12, %for.body ]
  %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
  %incdec.ptr8 = getelementptr inbounds i8, i8* %ptr.0, i64 2
Match: 0
3 x 3
Final Match: 0
  %ptr.0 = phi i8* [ %4, %entry ], [ %incdec.ptr12, %for.body ]
  %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
  %incdec.ptr8 = getelementptr inbounds i8, i8* %ptr.0, i64 2
Ptr:   %ptr.0 = phi i8* [ %4, %entry ], [ %incdec.ptr12, %for.body ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 1
i64 2
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
ScheduleNode: {
  %9 = load i8*, i8** %2, align 8, !tbaa !10
  %10 = load i8, i8* %arrayidx4, align 1, !tbaa !16
}
ScheduleNode: {
  store i8 %10, i8* %ptr.0, align 1, !tbaa !16
}
ScheduleNode: {
  %11 = load i8*, i8** %arrayidx5, align 8, !tbaa !10
  %12 = load i8, i8* %arrayidx7, align 1, !tbaa !16
}
ScheduleNode: {
  store i8 %12, i8* %incdec.ptr, align 1, !tbaa !16
}
ScheduleNode: {
  %13 = load i8*, i8** %arrayidx9, align 8, !tbaa !10
  %14 = load i8, i8* %arrayidx11, align 1, !tbaa !16
}
ScheduleNode: {
  store i8 %14, i8* %incdec.ptr8, align 1, !tbaa !16
}
ScheduleNode: {
  %9 = load i8*, i8** %2, align 8, !tbaa !10
  %10 = load i8, i8* %arrayidx4, align 1, !tbaa !16
}
Count: 2
Start:   %9 = load i8*, i8** %2, align 8, !tbaa !10
Processing:   %9 = load i8*, i8** %2, align 8, !tbaa !10
Count: 2
Found:   %9 = load i8*, i8** %2, align 8, !tbaa !10
Non-memory:   %idxprom = zext i8 %8 to i64
Non-memory:   %arrayidx4 = getelementptr inbounds i8, i8* %9, i64 %idxprom
Processing:   %10 = load i8, i8* %arrayidx4, align 1, !tbaa !16
Count: 1
Found:   %10 = load i8, i8* %arrayidx4, align 1, !tbaa !16
ScheduleNode: {
  store i8 %10, i8* %ptr.0, align 1, !tbaa !16
}
Non-memory:   %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
Processing:   store i8 %10, i8* %ptr.0, align 1, !tbaa !16
Count: 1
Found:   store i8 %10, i8* %ptr.0, align 1, !tbaa !16
ScheduleNode: {
  %11 = load i8*, i8** %arrayidx5, align 8, !tbaa !10
  %12 = load i8, i8* %arrayidx7, align 1, !tbaa !16
}
Processing:   %11 = load i8*, i8** %arrayidx5, align 8, !tbaa !10
Count: 2
Found:   %11 = load i8*, i8** %arrayidx5, align 8, !tbaa !10
Non-memory:   %arrayidx7 = getelementptr inbounds i8, i8* %11, i64 %idxprom
Processing:   %12 = load i8, i8* %arrayidx7, align 1, !tbaa !16
Count: 1
Found:   %12 = load i8, i8* %arrayidx7, align 1, !tbaa !16
ScheduleNode: {
  store i8 %12, i8* %incdec.ptr, align 1, !tbaa !16
}
Non-memory:   %incdec.ptr8 = getelementptr inbounds i8, i8* %ptr.0, i64 2
Processing:   store i8 %12, i8* %incdec.ptr, align 1, !tbaa !16
Count: 1
Found:   store i8 %12, i8* %incdec.ptr, align 1, !tbaa !16
ScheduleNode: {
  %13 = load i8*, i8** %arrayidx9, align 8, !tbaa !10
  %14 = load i8, i8* %arrayidx11, align 1, !tbaa !16
}
Processing:   %13 = load i8*, i8** %arrayidx9, align 8, !tbaa !10
Count: 2
Found:   %13 = load i8*, i8** %arrayidx9, align 8, !tbaa !10
Non-memory:   %arrayidx11 = getelementptr inbounds i8, i8* %13, i64 %idxprom
Processing:   %14 = load i8, i8* %arrayidx11, align 1, !tbaa !16
Count: 1
Found:   %14 = load i8, i8* %arrayidx11, align 1, !tbaa !16
ScheduleNode: {
  store i8 %14, i8* %incdec.ptr8, align 1, !tbaa !16
}
Non-memory:   %incdec.ptr12 = getelementptr inbounds i8, i8* %ptr.0, i64 3
Processing:   store i8 %14, i8* %incdec.ptr8, align 1, !tbaa !16
Count: 1
Found:   store i8 %14, i8* %incdec.ptr8, align 1, !tbaa !16
I:   %dec = add i32 %col.0, -1
Last:   br label %for.cond, !llvm.loop !17
Schedulable: 1
Loop Rolling: get_8bit_row
Generating tree
Generating MATCH
Match: 
  store i8 %10, i8* %ptr.0, align 1, !tbaa !16
  store i8 %12, i8* %incdec.ptr, align 1, !tbaa !16
  store i8 %14, i8* %incdec.ptr8, align 1, !tbaa !16
Generating MATCH
Match: 
  %10 = load i8, i8* %arrayidx4, align 1, !tbaa !16
  %12 = load i8, i8* %arrayidx7, align 1, !tbaa !16
  %14 = load i8, i8* %arrayidx11, align 1, !tbaa !16
Generating MATCH
Match: 
  %arrayidx4 = getelementptr inbounds i8, i8* %9, i64 %idxprom
  %arrayidx7 = getelementptr inbounds i8, i8* %11, i64 %idxprom
  %arrayidx11 = getelementptr inbounds i8, i8* %13, i64 %idxprom
Generating MATCH
Match: 
  %9 = load i8*, i8** %2, align 8, !tbaa !10
  %11 = load i8*, i8** %arrayidx5, align 8, !tbaa !10
  %13 = load i8*, i8** %arrayidx9, align 8, !tbaa !10
Generating Mismatch
Mismatched Values:
inst:   %2 = load i8**, i8*** %1, align 8, !tbaa !2
inst:   %arrayidx5 = getelementptr inbounds i8*, i8** %2, i64 1
inst:   %arrayidx9 = getelementptr inbounds i8*, i8** %2, i64 2
Non constants
Array Type: 3:i8**
Created array:   %15 = alloca i8**, i8 3, align 8
Gen:   %21 = load i8**, i8*** %20, align 8
Operands done!
Generated:   %22 = load i8*, i8** %21, align 1
Gen:   %22 = load i8*, i8** %21, align 1
Generating IDENTICAL
Operands done!
Generated:   %23 = getelementptr inbounds i8, i8* %22, i64 %idxprom
Gen:   %23 = getelementptr inbounds i8, i8* %22, i64 %idxprom
Operands done!
Generated:   %24 = load i8, i8* %23, align 1
Gen:   %24 = load i8, i8* %23, align 1
Generating GEPSEQ
Generating INTSEQ
Gen:   %25 = zext i8 %19 to i64
Closing GEPSEQ
Gen:   %26 = getelementptr i8, i8* %ptr.0, i64 %25
Operands done!
Generated:   store i8 %24, i8* %26, align 1
Gen:   store i8 %24, i8* %26, align 1
Graph code generated!
Root:
  store i8 %10, i8* %ptr.0, align 1, !tbaa !16
  store i8 %12, i8* %incdec.ptr, align 1, !tbaa !16
  store i8 %14, i8* %incdec.ptr8, align 1, !tbaa !16
Root size: 3
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
5 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="0..2, 1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
6->0 
2->1 
3->2 
5->2 
4->3 
7->6 
}

Gains: 23 - 50 = -27; Width: 3; Unprofitable; get_8bit_row
Trying AGAIN
Trying AGAIN
Creating Node
  store i8 %12, i8* %incdec.ptr, align 1, !tbaa !16
  store i8 %14, i8* %incdec.ptr8, align 1, !tbaa !16
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %12 = load i8, i8* %arrayidx7, align 1, !tbaa !16
  %14 = load i8, i8* %arrayidx11, align 1, !tbaa !16
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx7 = getelementptr inbounds i8, i8* %11, i64 %idxprom
  %arrayidx11 = getelementptr inbounds i8, i8* %13, i64 %idxprom
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %11 = load i8*, i8** %arrayidx5, align 8, !tbaa !10
  %13 = load i8*, i8** %arrayidx9, align 8, !tbaa !10
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx5 = getelementptr inbounds i8*, i8** %2, i64 1
  %arrayidx9 = getelementptr inbounds i8*, i8** %2, i64 2
Match: 0
2 x 2
Final Match: 0
  %arrayidx5 = getelementptr inbounds i8*, i8** %2, i64 1
  %arrayidx9 = getelementptr inbounds i8*, i8** %2, i64 2
GEPSeq2
i8*
BinOP?
  %arrayidx5 = getelementptr inbounds i8*, i8** %2, i64 1
Alt Seq
Creating Node
  %idxprom = zext i8 %8 to i64
  %idxprom = zext i8 %8 to i64
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
  %incdec.ptr8 = getelementptr inbounds i8, i8* %ptr.0, i64 2
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %ptr.0 = phi i8* [ %4, %entry ], [ %incdec.ptr12, %for.body ]
  %ptr.0 = phi i8* [ %4, %entry ], [ %incdec.ptr12, %for.body ]
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
i64 1
i64 2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 1
Int Seq
ScheduleNode: {
  %11 = load i8*, i8** %arrayidx5, align 8, !tbaa !10
  %12 = load i8, i8* %arrayidx7, align 1, !tbaa !16
}
ScheduleNode: {
  store i8 %12, i8* %incdec.ptr, align 1, !tbaa !16
}
ScheduleNode: {
  %13 = load i8*, i8** %arrayidx9, align 8, !tbaa !10
  %14 = load i8, i8* %arrayidx11, align 1, !tbaa !16
}
ScheduleNode: {
  store i8 %14, i8* %incdec.ptr8, align 1, !tbaa !16
}
ScheduleNode: {
  %11 = load i8*, i8** %arrayidx5, align 8, !tbaa !10
  %12 = load i8, i8* %arrayidx7, align 1, !tbaa !16
}
Count: 2
Start:   %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
Non-memory:   %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
Processing:   store i8 %10, i8* %ptr.0, align 1, !tbaa !16
Count: 2
Not found:   store i8 %10, i8* %ptr.0, align 1, !tbaa !16
Read/Write memory
I:   store i8 %10, i8* %ptr.0, align 1, !tbaa !16
Last:   br label %for.cond, !llvm.loop !17
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %arrayidx5, %arrayidx9", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="1..2, 1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
6->0 
2->1 
3->2 
5->2 
4->3 
7->6 
8->6 
}


for.body:                                         ; preds = %for.cond
  %7 = load void (%struct._tga_source_struct*)*, void (%struct._tga_source_struct*)** %6, align 8, !tbaa !15
  tail call void %7(%struct._tga_source_struct* nonnull %0) #5
  %8 = load i8, i8* %arrayidx2, align 8, !tbaa !16
  %9 = load i8*, i8** %2, align 8, !tbaa !10
  %idxprom = zext i8 %8 to i64
  %arrayidx4 = getelementptr inbounds i8, i8* %9, i64 %idxprom
  %10 = load i8, i8* %arrayidx4, align 1, !tbaa !16
  %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
  store i8 %10, i8* %ptr.0, align 1, !tbaa !16
  %11 = load i8*, i8** %arrayidx5, align 8, !tbaa !10
  %arrayidx7 = getelementptr inbounds i8, i8* %11, i64 %idxprom
  %12 = load i8, i8* %arrayidx7, align 1, !tbaa !16
  %incdec.ptr8 = getelementptr inbounds i8, i8* %ptr.0, i64 2
  store i8 %12, i8* %incdec.ptr, align 1, !tbaa !16
  %13 = load i8*, i8** %arrayidx9, align 8, !tbaa !10
  %arrayidx11 = getelementptr inbounds i8, i8* %13, i64 %idxprom
  %14 = load i8, i8* %arrayidx11, align 1, !tbaa !16
  %incdec.ptr12 = getelementptr inbounds i8, i8* %ptr.0, i64 3
  store i8 %14, i8* %incdec.ptr8, align 1, !tbaa !16
  %dec = add i32 %col.0, -1
  br label %for.cond, !llvm.loop !17

looking for reduction
Done Loop Roller: 0/1
Optimizing: get_16bit_row
  %ptr.0 = phi i8* [ %2, %entry ], [ %add.ptr, %for.body ]
  %col.0 = phi i32 [ %3, %entry ], [ %dec, %for.body ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
  store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
  store i8 %16, i8* %ptr.0, align 1, !tbaa !15
Creating Node
  store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
  store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
  store i8 %16, i8* %ptr.0, align 1, !tbaa !15
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %10 = load i8, i8* %arrayidx5, align 1, !tbaa !15
  %13 = load i8, i8* %arrayidx9, align 1, !tbaa !15
  %16 = load i8, i8* %arrayidx14, align 1, !tbaa !15
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %arrayidx5 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %9
  %arrayidx9 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %12
  %arrayidx14 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %15
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
@c5to8bits = internal unnamed_addr constant [32 x i8] c"\00\08\10\19!)1:BJRZcks{\84\8C\94\9C\A5\AD\B5\BD\C5\CE\D6\DE\E6\EF\F7\FF", align 16
@c5to8bits = internal unnamed_addr constant [32 x i8] c"\00\08\10\19!)1:BJRZcks{\84\8C\94\9C\A5\AD\B5\BD\C5\CE\D6\DE\E6\EF\F7\FF", align 16
@c5to8bits = internal unnamed_addr constant [32 x i8] c"\00\08\10\19!)1:BJRZcks{\84\8C\94\9C\A5\AD\B5\BD\C5\CE\D6\DE\E6\EF\F7\FF", align 16
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
i64 0
i64 0
i64 0
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
  %9 = zext i32 %and to i64
  %12 = zext i32 %and7 to i64
  %15 = zext i32 %and12 to i64
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %and = and i32 %conv, 31
  %and7 = and i32 %11, 31
  %and12 = and i32 %14, 31
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %conv = zext i8 %7 to i32
  %11 = lshr i32 %add, 5
  %14 = lshr i32 %conv4, 2
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %conv = zext i8 %7 to i32
Mismatching
Creating Node
i32 31
i32 31
i32 31
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
  %arrayidx6 = getelementptr inbounds i8, i8* %ptr.0, i64 2
  %arrayidx10 = getelementptr inbounds i8, i8* %ptr.0, i64 1
  %ptr.0 = phi i8* [ %2, %entry ], [ %add.ptr, %for.body ]
Match: 0
3 x 3
Final Match: 0
  %arrayidx6 = getelementptr inbounds i8, i8* %ptr.0, i64 2
  %arrayidx10 = getelementptr inbounds i8, i8* %ptr.0, i64 1
  %ptr.0 = phi i8* [ %2, %entry ], [ %add.ptr, %for.body ]
Ptr:   %ptr.0 = phi i8* [ %2, %entry ], [ %add.ptr, %for.body ]
AllGEPs: 0
GEP Seq
Creating Node
i64 2
i64 1
i64 0
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 2
Int Seq
ScheduleNode: {
  %10 = load i8, i8* %arrayidx5, align 1, !tbaa !15
}
ScheduleNode: {
  store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
}
ScheduleNode: {
  %13 = load i8, i8* %arrayidx9, align 1, !tbaa !15
}
ScheduleNode: {
  store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
}
ScheduleNode: {
  %16 = load i8, i8* %arrayidx14, align 1, !tbaa !15
}
ScheduleNode: {
  store i8 %16, i8* %ptr.0, align 1, !tbaa !15
}
ScheduleNode: {
  %10 = load i8, i8* %arrayidx5, align 1, !tbaa !15
}
Count: 1
Start:   %and = and i32 %conv, 31
Non-memory:   %and = and i32 %conv, 31
Non-memory:   %9 = zext i32 %and to i64
Non-memory:   %arrayidx5 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %9
Processing:   %10 = load i8, i8* %arrayidx5, align 1, !tbaa !15
Count: 1
Found:   %10 = load i8, i8* %arrayidx5, align 1, !tbaa !15
ScheduleNode: {
  store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
}
Non-memory:   %arrayidx6 = getelementptr inbounds i8, i8* %ptr.0, i64 2
Processing:   store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
Count: 1
Found:   store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
ScheduleNode: {
  %13 = load i8, i8* %arrayidx9, align 1, !tbaa !15
}
Non-memory:   %11 = lshr i32 %add, 5
Non-memory:   %and7 = and i32 %11, 31
Non-memory:   %12 = zext i32 %and7 to i64
Non-memory:   %arrayidx9 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %12
Processing:   %13 = load i8, i8* %arrayidx9, align 1, !tbaa !15
Count: 1
Found:   %13 = load i8, i8* %arrayidx9, align 1, !tbaa !15
ScheduleNode: {
  store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
}
Non-memory:   %arrayidx10 = getelementptr inbounds i8, i8* %ptr.0, i64 1
Processing:   store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
Count: 1
Found:   store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
ScheduleNode: {
  %16 = load i8, i8* %arrayidx14, align 1, !tbaa !15
}
Non-memory:   %14 = lshr i32 %conv4, 2
Non-memory:   %and12 = and i32 %14, 31
Non-memory:   %15 = zext i32 %and12 to i64
Non-memory:   %arrayidx14 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %15
Processing:   %16 = load i8, i8* %arrayidx14, align 1, !tbaa !15
Count: 1
Found:   %16 = load i8, i8* %arrayidx14, align 1, !tbaa !15
ScheduleNode: {
  store i8 %16, i8* %ptr.0, align 1, !tbaa !15
}
Processing:   store i8 %16, i8* %ptr.0, align 1, !tbaa !15
Count: 1
Found:   store i8 %16, i8* %ptr.0, align 1, !tbaa !15
I:   %add.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 3
Last:   br label %for.cond, !llvm.loop !16
Schedulable: 1
Loop Rolling: get_16bit_row
Generating tree
Generating MATCH
Match: 
  store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
  store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
  store i8 %16, i8* %ptr.0, align 1, !tbaa !15
Generating MATCH
Match: 
  %10 = load i8, i8* %arrayidx5, align 1, !tbaa !15
  %13 = load i8, i8* %arrayidx9, align 1, !tbaa !15
  %16 = load i8, i8* %arrayidx14, align 1, !tbaa !15
Generating MATCH
Match: 
  %arrayidx5 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %9
  %arrayidx9 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %12
  %arrayidx14 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %15
Generating IDENTICAL
Generating IDENTICAL
Generating MATCH
Match: 
  %9 = zext i32 %and to i64
  %12 = zext i32 %and7 to i64
  %15 = zext i32 %and12 to i64
Generating MATCH
Match: 
  %and = and i32 %conv, 31
  %and7 = and i32 %11, 31
  %and12 = and i32 %14, 31
Generating Mismatch
Mismatched Values:
inst:   %conv = zext i8 %7 to i32
inst:   %11 = lshr i32 %add, 5
inst:   %14 = lshr i32 %conv4, 2
Non constants
Array Type: 3:i32
Created array:   %17 = alloca i32, i8 3, align 4
Gen:   %23 = load i32, i32* %22, align 4
Generating IDENTICAL
Operands done!
Generated:   %24 = and i32 %23, 31
Gen:   %24 = and i32 %23, 31
Operands done!
Generated:   %25 = zext i32 %24 to i64
Gen:   %25 = zext i32 %24 to i64
Operands done!
Generated:   %26 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %25
Gen:   %26 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %25
Operands done!
Generated:   %27 = load i8, i8* %26, align 1
Gen:   %27 = load i8, i8* %26, align 1
Generating GEPSEQ
Generating INTSEQ
Gen:   %30 = add i64 %29, 2
Closing GEPSEQ
Gen:   %31 = getelementptr i8, i8* %ptr.0, i64 %30
Operands done!
Generated:   store i8 %27, i8* %31, align 1
Gen:   store i8 %27, i8* %31, align 1
Graph code generated!
Root:
  store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
  store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
  store i8 %16, i8* %ptr.0, align 1, !tbaa !15
Root size: 3
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="const", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="and", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
8 [label="31", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="2..0, -1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
9->0 
2->1 
3->2 
4->2 
5->2 
6->5 
7->6 
8->6 
10->9 
}

Gains: 29 - 58 = -29; Width: 3; Unprofitable; get_16bit_row
Trying AGAIN
Creating Node
  store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
  store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %10 = load i8, i8* %arrayidx5, align 1, !tbaa !15
  %13 = load i8, i8* %arrayidx9, align 1, !tbaa !15
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx5 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %9
  %arrayidx9 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %12
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
@c5to8bits = internal unnamed_addr constant [32 x i8] c"\00\08\10\19!)1:BJRZcks{\84\8C\94\9C\A5\AD\B5\BD\C5\CE\D6\DE\E6\EF\F7\FF", align 16
@c5to8bits = internal unnamed_addr constant [32 x i8] c"\00\08\10\19!)1:BJRZcks{\84\8C\94\9C\A5\AD\B5\BD\C5\CE\D6\DE\E6\EF\F7\FF", align 16
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
i64 0
i64 0
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %9 = zext i32 %and to i64
  %12 = zext i32 %and7 to i64
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %and = and i32 %conv, 31
  %and7 = and i32 %11, 31
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv = zext i8 %7 to i32
  %11 = lshr i32 %add, 5
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %conv = zext i8 %7 to i32
Alt Seq
Creating Node
i32 31
i32 31
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %arrayidx6 = getelementptr inbounds i8, i8* %ptr.0, i64 2
  %arrayidx10 = getelementptr inbounds i8, i8* %ptr.0, i64 1
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %ptr.0 = phi i8* [ %2, %entry ], [ %add.ptr, %for.body ]
  %ptr.0 = phi i8* [ %2, %entry ], [ %add.ptr, %for.body ]
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
i64 2
i64 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 2
Int Seq
ScheduleNode: {
  %10 = load i8, i8* %arrayidx5, align 1, !tbaa !15
}
ScheduleNode: {
  store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
}
ScheduleNode: {
  %13 = load i8, i8* %arrayidx9, align 1, !tbaa !15
}
ScheduleNode: {
  store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
}
ScheduleNode: {
  %10 = load i8, i8* %arrayidx5, align 1, !tbaa !15
}
Count: 1
Start:   %and = and i32 %conv, 31
Non-memory:   %and = and i32 %conv, 31
Non-memory:   %9 = zext i32 %and to i64
Non-memory:   %arrayidx5 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %9
Processing:   %10 = load i8, i8* %arrayidx5, align 1, !tbaa !15
Count: 1
Found:   %10 = load i8, i8* %arrayidx5, align 1, !tbaa !15
ScheduleNode: {
  store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
}
Non-memory:   %arrayidx6 = getelementptr inbounds i8, i8* %ptr.0, i64 2
Processing:   store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
Count: 1
Found:   store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
ScheduleNode: {
  %13 = load i8, i8* %arrayidx9, align 1, !tbaa !15
}
Non-memory:   %11 = lshr i32 %add, 5
Non-memory:   %and7 = and i32 %11, 31
Non-memory:   %12 = zext i32 %and7 to i64
Non-memory:   %arrayidx9 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %12
Processing:   %13 = load i8, i8* %arrayidx9, align 1, !tbaa !15
Count: 1
Found:   %13 = load i8, i8* %arrayidx9, align 1, !tbaa !15
ScheduleNode: {
  store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
}
Non-memory:   %arrayidx10 = getelementptr inbounds i8, i8* %ptr.0, i64 1
Processing:   store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
Count: 1
Found:   store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
I:   %14 = lshr i32 %conv4, 2
Last:   br label %for.cond, !llvm.loop !16
Schedulable: 1
Loop Rolling: get_16bit_row
Generating tree
Generating MATCH
Match: 
  store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
  store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
Generating MATCH
Match: 
  %10 = load i8, i8* %arrayidx5, align 1, !tbaa !15
  %13 = load i8, i8* %arrayidx9, align 1, !tbaa !15
Generating MATCH
Match: 
  %arrayidx5 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %9
  %arrayidx9 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %12
Generating IDENTICAL
Generating IDENTICAL
Generating MATCH
Match: 
  %9 = zext i32 %and to i64
  %12 = zext i32 %and7 to i64
Generating MATCH
Match: 
  %and = and i32 %conv, 31
  %and7 = and i32 %11, 31
Generating ALTSEQ
Values:
  %conv = zext i8 %7 to i32
  %11 = lshr i32 %add, 5
Generated Version 4:
  %18 = icmp eq i8 %17, 0
  %19 = select i1 %18, i32 %conv, i32 %11
Generating IDENTICAL
Operands done!
Generated:   %20 = and i32 %19, 31
Gen:   %20 = and i32 %19, 31
Operands done!
Generated:   %21 = zext i32 %20 to i64
Gen:   %21 = zext i32 %20 to i64
Operands done!
Generated:   %22 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %21
Gen:   %22 = getelementptr inbounds [32 x i8], [32 x i8]* @c5to8bits, i64 0, i64 %21
Operands done!
Generated:   %23 = load i8, i8* %22, align 1
Gen:   %23 = load i8, i8* %22, align 1
Generating MATCH
Match: 
  %arrayidx6 = getelementptr inbounds i8, i8* %ptr.0, i64 2
  %arrayidx10 = getelementptr inbounds i8, i8* %ptr.0, i64 1
Generating IDENTICAL
Generating INTSEQ
Gen:   %26 = add i64 %25, 2
Operands done!
Generated:   %27 = getelementptr inbounds i8, i8* %ptr.0, i64 %26
Gen:   %27 = getelementptr inbounds i8, i8* %ptr.0, i64 %26
Operands done!
Generated:   store i8 %23, i8* %27, align 1
Gen:   store i8 %23, i8* %27, align 1
Graph code generated!
Root:
  store i8 %10, i8* %arrayidx6, align 1, !tbaa !15
  store i8 %13, i8* %arrayidx10, align 1, !tbaa !15
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="const", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="and", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %conv, %11", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="31", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="2..1, -1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
9->0 
2->1 
3->2 
4->2 
5->2 
6->5 
7->6 
8->6 
10->9 
11->9 
}

Gains: 20 - 20 = 0; Width: 2; Unprofitable; get_16bit_row
Trying AGAIN
looking for reduction
Done Loop Roller: 0/2
Optimizing: get_24bit_row
  %ptr.0 = phi i8* [ %2, %entry ], [ %incdec.ptr12, %for.body ]
  %col.0 = phi i32 [ %3, %entry ], [ %dec, %for.body ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %7, i8* %ptr.0, align 1, !tbaa !15
  store i8 %8, i8* %incdec.ptr, align 1, !tbaa !15
  store i8 %9, i8* %incdec.ptr7, align 1, !tbaa !15
Creating Node
  store i8 %7, i8* %ptr.0, align 1, !tbaa !15
  store i8 %8, i8* %incdec.ptr, align 1, !tbaa !15
  store i8 %9, i8* %incdec.ptr7, align 1, !tbaa !15
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %7 = load i8, i8* %arrayidx1, align 2, !tbaa !15
  %8 = load i8, i8* %arrayidx4, align 1, !tbaa !15
  %9 = load i8, i8* %arrayidx9, align 8, !tbaa !15
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %5, i64 0, i64 2
  %arrayidx4 = getelementptr inbounds [4 x i8], [4 x i8]* %5, i64 0, i64 1
  %arrayidx9 = bitcast i32* %tga_pixel to i8*
Match: 0
3 x 3
Final Match: 0
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %5, i64 0, i64 2
  %arrayidx4 = getelementptr inbounds [4 x i8], [4 x i8]* %5, i64 0, i64 1
  %arrayidx9 = bitcast i32* %tga_pixel to i8*
GEPSeq2
BinOP?
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %5, i64 0, i64 2
Mismatching
Creating Node
  %ptr.0 = phi i8* [ %2, %entry ], [ %incdec.ptr12, %for.body ]
  %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
  %incdec.ptr7 = getelementptr inbounds i8, i8* %ptr.0, i64 2
Match: 0
3 x 3
Final Match: 0
  %ptr.0 = phi i8* [ %2, %entry ], [ %incdec.ptr12, %for.body ]
  %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
  %incdec.ptr7 = getelementptr inbounds i8, i8* %ptr.0, i64 2
Ptr:   %ptr.0 = phi i8* [ %2, %entry ], [ %incdec.ptr12, %for.body ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 1
i64 2
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
ScheduleNode: {
  %7 = load i8, i8* %arrayidx1, align 2, !tbaa !15
}
ScheduleNode: {
  store i8 %7, i8* %ptr.0, align 1, !tbaa !15
}
ScheduleNode: {
  %8 = load i8, i8* %arrayidx4, align 1, !tbaa !15
}
ScheduleNode: {
  store i8 %8, i8* %incdec.ptr, align 1, !tbaa !15
}
ScheduleNode: {
  %9 = load i8, i8* %arrayidx9, align 8, !tbaa !15
}
ScheduleNode: {
  store i8 %9, i8* %incdec.ptr7, align 1, !tbaa !15
}
ScheduleNode: {
  %7 = load i8, i8* %arrayidx1, align 2, !tbaa !15
}
Count: 1
Start:   %7 = load i8, i8* %arrayidx1, align 2, !tbaa !15
Processing:   %7 = load i8, i8* %arrayidx1, align 2, !tbaa !15
Count: 1
Found:   %7 = load i8, i8* %arrayidx1, align 2, !tbaa !15
ScheduleNode: {
  store i8 %7, i8* %ptr.0, align 1, !tbaa !15
}
Non-memory:   %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
Processing:   store i8 %7, i8* %ptr.0, align 1, !tbaa !15
Count: 1
Found:   store i8 %7, i8* %ptr.0, align 1, !tbaa !15
ScheduleNode: {
  %8 = load i8, i8* %arrayidx4, align 1, !tbaa !15
}
Processing:   %8 = load i8, i8* %arrayidx4, align 1, !tbaa !15
Count: 1
Found:   %8 = load i8, i8* %arrayidx4, align 1, !tbaa !15
ScheduleNode: {
  store i8 %8, i8* %incdec.ptr, align 1, !tbaa !15
}
Non-memory:   %incdec.ptr7 = getelementptr inbounds i8, i8* %ptr.0, i64 2
Processing:   store i8 %8, i8* %incdec.ptr, align 1, !tbaa !15
Count: 1
Found:   store i8 %8, i8* %incdec.ptr, align 1, !tbaa !15
ScheduleNode: {
  %9 = load i8, i8* %arrayidx9, align 8, !tbaa !15
}
Processing:   %9 = load i8, i8* %arrayidx9, align 8, !tbaa !15
Count: 1
Found:   %9 = load i8, i8* %arrayidx9, align 8, !tbaa !15
ScheduleNode: {
  store i8 %9, i8* %incdec.ptr7, align 1, !tbaa !15
}
Non-memory:   %incdec.ptr12 = getelementptr inbounds i8, i8* %ptr.0, i64 3
Processing:   store i8 %9, i8* %incdec.ptr7, align 1, !tbaa !15
Count: 1
Found:   store i8 %9, i8* %incdec.ptr7, align 1, !tbaa !15
I:   %dec = add i32 %col.0, -1
Last:   br label %for.cond, !llvm.loop !16
Schedulable: 1
Loop Rolling: get_24bit_row
Generating tree
Generating MATCH
Match: 
  store i8 %7, i8* %ptr.0, align 1, !tbaa !15
  store i8 %8, i8* %incdec.ptr, align 1, !tbaa !15
  store i8 %9, i8* %incdec.ptr7, align 1, !tbaa !15
Generating MATCH
Match: 
  %7 = load i8, i8* %arrayidx1, align 2, !tbaa !15
  %8 = load i8, i8* %arrayidx4, align 1, !tbaa !15
  %9 = load i8, i8* %arrayidx9, align 8, !tbaa !15
Generating Mismatch
Mismatched Values:
inst:   %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %5, i64 0, i64 2
inst:   %arrayidx4 = getelementptr inbounds [4 x i8], [4 x i8]* %5, i64 0, i64 1
inst:   %arrayidx9 = bitcast i32* %tga_pixel to i8*
Non constants
Array Type: 3:i8*
Created array:   %10 = alloca i8*, i8 3, align 8
Gen:   %16 = load i8*, i8** %15, align 8
Operands done!
Generated:   %17 = load i8, i8* %16, align 1
Gen:   %17 = load i8, i8* %16, align 1
Generating GEPSEQ
Generating INTSEQ
Gen:   %18 = zext i8 %14 to i64
Closing GEPSEQ
Gen:   %19 = getelementptr i8, i8* %ptr.0, i64 %18
Operands done!
Generated:   store i8 %17, i8* %19, align 1
Gen:   store i8 %17, i8* %19, align 1
Graph code generated!
Root:
  store i8 %7, i8* %ptr.0, align 1, !tbaa !15
  store i8 %8, i8* %incdec.ptr, align 1, !tbaa !15
  store i8 %9, i8* %incdec.ptr7, align 1, !tbaa !15
Root size: 3
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0..2, 1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
3->0 
2->1 
4->3 
}

Gains: 14 - 47 = -33; Width: 3; Unprofitable; get_24bit_row
Trying AGAIN
Trying AGAIN
Creating Node
  store i8 %8, i8* %incdec.ptr, align 1, !tbaa !15
  store i8 %9, i8* %incdec.ptr7, align 1, !tbaa !15
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %8 = load i8, i8* %arrayidx4, align 1, !tbaa !15
  %9 = load i8, i8* %arrayidx9, align 8, !tbaa !15
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx4 = getelementptr inbounds [4 x i8], [4 x i8]* %5, i64 0, i64 1
  %arrayidx9 = bitcast i32* %tga_pixel to i8*
Match: 0
2 x 2
Final Match: 0
  %arrayidx4 = getelementptr inbounds [4 x i8], [4 x i8]* %5, i64 0, i64 1
  %arrayidx9 = bitcast i32* %tga_pixel to i8*
GEPSeq2
BinOP?
  %arrayidx4 = getelementptr inbounds [4 x i8], [4 x i8]* %5, i64 0, i64 1
Alt Seq
Creating Node
  %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
  %incdec.ptr7 = getelementptr inbounds i8, i8* %ptr.0, i64 2
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %ptr.0 = phi i8* [ %2, %entry ], [ %incdec.ptr12, %for.body ]
  %ptr.0 = phi i8* [ %2, %entry ], [ %incdec.ptr12, %for.body ]
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
i64 1
i64 2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 1
Int Seq
ScheduleNode: {
  %8 = load i8, i8* %arrayidx4, align 1, !tbaa !15
}
ScheduleNode: {
  store i8 %8, i8* %incdec.ptr, align 1, !tbaa !15
}
ScheduleNode: {
  %9 = load i8, i8* %arrayidx9, align 8, !tbaa !15
}
ScheduleNode: {
  store i8 %9, i8* %incdec.ptr7, align 1, !tbaa !15
}
ScheduleNode: {
  %8 = load i8, i8* %arrayidx4, align 1, !tbaa !15
}
Count: 1
Start:   %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
Non-memory:   %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
Processing:   store i8 %7, i8* %ptr.0, align 1, !tbaa !15
Count: 1
Not found:   store i8 %7, i8* %ptr.0, align 1, !tbaa !15
Read/Write memory
I:   store i8 %7, i8* %ptr.0, align 1, !tbaa !15
Last:   br label %for.cond, !llvm.loop !16
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %arrayidx4, %arrayidx9", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="1..2, 1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
3->0 
2->1 
4->3 
5->3 
}


for.body:                                         ; preds = %for.cond
  %6 = load void (%struct._tga_source_struct*)*, void (%struct._tga_source_struct*)** %4, align 8, !tbaa !14
  tail call void %6(%struct._tga_source_struct* nonnull %0) #5
  %7 = load i8, i8* %arrayidx1, align 2, !tbaa !15
  %incdec.ptr = getelementptr inbounds i8, i8* %ptr.0, i64 1
  store i8 %7, i8* %ptr.0, align 1, !tbaa !15
  %8 = load i8, i8* %arrayidx4, align 1, !tbaa !15
  %incdec.ptr7 = getelementptr inbounds i8, i8* %ptr.0, i64 2
  store i8 %8, i8* %incdec.ptr, align 1, !tbaa !15
  %9 = load i8, i8* %arrayidx9, align 8, !tbaa !15
  %incdec.ptr12 = getelementptr inbounds i8, i8* %ptr.0, i64 3
  store i8 %9, i8* %incdec.ptr7, align 1, !tbaa !15
  %dec = add i32 %col.0, -1
  br label %for.cond, !llvm.loop !16

looking for reduction
Done Loop Roller: 0/1
Optimizing: get_8bit_gray_row
  %ptr.0 = phi i8* [ %2, %entry ], [ %incdec.ptr, %for.body ]
  %col.0 = phi i32 [ %3, %entry ], [ %dec, %for.body ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %6, i8* %ptr.0, align 1, !tbaa !15
looking for reduction
Done Loop Roller: 0/0
Nothing found in: get_8bit_gray_row
Optimizing: get_memory_row
looking for reduction
looking for reduction
looking for reduction
  %sub1 = add i32 %0, %3
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %inc = add i32 %9, 1
looking for reduction
Attempting Group:
  store i8** %call, i8*** %buffer, align 8, !tbaa !18
Done Loop Roller: 0/0
Nothing found in: get_memory_row
Optimizing: preload_image
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end ], [ 0, %entry ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !11
  store i64 %6, i64* %pass_limit, align 8, !tbaa !15
Creating Node
  store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !11
  store i64 %6, i64* %pass_limit, align 8, !tbaa !15
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end ], [ 0, %entry ]
  %6 = zext i32 %5 to i64
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end ], [ 0, %entry ]
Alt Seq
Creating Node
  %pass_counter = getelementptr inbounds %struct.cdjpeg_progress_mgr, %struct.cdjpeg_progress_mgr* %1, i64 0, i32 0, i32 1
  %pass_limit = getelementptr inbounds %struct.cdjpeg_progress_mgr, %struct.cdjpeg_progress_mgr* %1, i64 0, i32 0, i32 2
Match: 0
2 x 2
Final Match: 0
  %pass_counter = getelementptr inbounds %struct.cdjpeg_progress_mgr, %struct.cdjpeg_progress_mgr* %1, i64 0, i32 0, i32 1
  %pass_limit = getelementptr inbounds %struct.cdjpeg_progress_mgr, %struct.cdjpeg_progress_mgr* %1, i64 0, i32 0, i32 2
GEPSeq2
%struct.jpeg_progress_mgr = type { {}*, i64, i64, i32, i32 }
BinOP?
  %pass_counter = getelementptr inbounds %struct.cdjpeg_progress_mgr, %struct.cdjpeg_progress_mgr* %1, i64 0, i32 0, i32 1
Alt Seq
ScheduleNode: {
  store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !11
}
ScheduleNode: {
  store i64 %6, i64* %pass_limit, align 8, !tbaa !15
}
ScheduleNode: {
  store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !11
}
Count: 1
Start:   store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !11
Processing:   store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !11
Count: 1
Found:   store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !11
ScheduleNode: {
  store i64 %6, i64* %pass_limit, align 8, !tbaa !15
}
Processing:   store i64 %6, i64* %pass_limit, align 8, !tbaa !15
Count: 1
Found:   store i64 %6, i64* %pass_limit, align 8, !tbaa !15
I:   %7 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %progress_monitor7, align 8, !tbaa !16
Last:   br label %if.end
Schedulable: 1
Loop Rolling: preload_image
Generating tree
Generating MATCH
Match: 
  store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !11
  store i64 %6, i64* %pass_limit, align 8, !tbaa !15
Generating ALTSEQ
Values:
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end ], [ 0, %entry ]
  %6 = zext i32 %5 to i64
Generated Version 4:
  %16 = icmp eq i8 %15, 0
  %17 = select i1 %16, i64 %indvars.iv, i64 %6
Generating ALTSEQ
Values:
  %pass_counter = getelementptr inbounds %struct.cdjpeg_progress_mgr, %struct.cdjpeg_progress_mgr* %1, i64 0, i32 0, i32 1
  %pass_limit = getelementptr inbounds %struct.cdjpeg_progress_mgr, %struct.cdjpeg_progress_mgr* %1, i64 0, i32 0, i32 2
Generated Version 4:
  %18 = select i1 %16, i64* %pass_counter, i64* %pass_limit
Operands done!
Generated:   store i64 %17, i64* %18, align 1
Gen:   store i64 %17, i64* %18, align 1
Graph code generated!
Root:
  store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !11
  store i64 %6, i64* %pass_limit, align 8, !tbaa !15
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: %indvars.iv, %6", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %pass_counter, %pass_limit", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; preload_image
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8** %call, i8*** %buffer, align 8, !tbaa !23
looking for reduction
looking for reduction
  %inc13 = add nsw i32 %13, 1
Attempting Group:
  store i32 %inc13, i32* %completed_extra_passes, align 8, !tbaa !27
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)* @get_memory_row, i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)** %get_pixel_rows16, align 8, !tbaa !28
Attempting Group:
  %call17 = tail call i32 @get_memory_row(%struct.jpeg_compress_struct* nonnull %cinfo, %struct.cjpeg_source_struct* %sinfo) #6
Done Loop Roller: 0/1
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jfdctfst.c -o src/jfdctfst.o   -mllvm -reroll-loops=3
Optimizing: jpeg_fdct_ifast
  %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
  %ctr.0 = phi i32 [ 7, %entry ], [ %dec, %for.body ]
looking for reduction
looking for reduction
  %add26 = add nsw i32 %add22, %add24
Found
looking for reduction
  %sub28 = sub nsw i32 %add22, %add24
looking for reduction
  %add32 = add nsw i32 %sub23, %conv31
looking for reduction
  %sub34 = sub nsw i32 %sub23, %conv31
looking for reduction
  %add60 = add nsw i32 %add48, %sub59
Found
looking for reduction
  %sub62 = sub nsw i32 %sub59, %add48
looking for reduction
  %add64 = add nsw i32 %add53, %add58
Found
looking for reduction
  %sub66 = sub nsw i32 %add58, %add53
Attempting Group:
  store i32 %add26, i32* %dataptr.0, align 4, !tbaa !2
  store i32 %sub28, i32* %arrayidx17, align 4, !tbaa !2
  store i32 %add32, i32* %arrayidx10, align 4, !tbaa !2
  store i32 %sub34, i32* %arrayidx5, align 4, !tbaa !2
  store i32 %add60, i32* %arrayidx11, align 4, !tbaa !2
  store i32 %sub62, i32* %arrayidx16, align 4, !tbaa !2
  store i32 %add64, i32* %arrayidx4, align 4, !tbaa !2
  store i32 %sub66, i32* %arrayidx1, align 4, !tbaa !2
Creating Node
  store i32 %add26, i32* %dataptr.0, align 4, !tbaa !2
  store i32 %sub28, i32* %arrayidx17, align 4, !tbaa !2
  store i32 %add32, i32* %arrayidx10, align 4, !tbaa !2
  store i32 %sub34, i32* %arrayidx5, align 4, !tbaa !2
  store i32 %add60, i32* %arrayidx11, align 4, !tbaa !2
  store i32 %sub62, i32* %arrayidx16, align 4, !tbaa !2
  store i32 %add64, i32* %arrayidx4, align 4, !tbaa !2
  store i32 %sub66, i32* %arrayidx1, align 4, !tbaa !2
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %add26 = add nsw i32 %add22, %add24
  %sub28 = sub nsw i32 %add22, %add24
  %add32 = add nsw i32 %sub23, %conv31
  %sub34 = sub nsw i32 %sub23, %conv31
  %add60 = add nsw i32 %add48, %sub59
  %sub62 = sub nsw i32 %sub59, %add48
  %add64 = add nsw i32 %add53, %add58
  %sub66 = sub nsw i32 %add58, %add53
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add26 = add nsw i32 %add22, %add24
BinOp Seq
Creating Node
  %add22 = add nsw i32 %add18, %add
  %sub28 = sub nsw i32 %add22, %add24
  %sub23 = sub nsw i32 %add, %add18
  %sub34 = sub nsw i32 %sub23, %conv31
  %add48 = add nsw i32 %conv43, %conv47
  %sub62 = sub nsw i32 %sub59, %add48
  %add53 = add nsw i32 %conv43, %conv52
  %sub66 = sub nsw i32 %add58, %add53
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add22 = add nsw i32 %add18, %add
BinOp Seq
Creating Node
  %add22 = add nsw i32 %add18, %add
  %add22 = add nsw i32 %add18, %add
  %add = add nsw i32 %1, %0
  %sub23 = sub nsw i32 %add, %add18
  %add48 = add nsw i32 %conv43, %conv47
  %sub59 = sub nsw i32 %sub, %conv57
  %add53 = add nsw i32 %conv43, %conv52
  %add58 = add nsw i32 %sub, %conv57
Match: 0
7 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add22 = add nsw i32 %add18, %add
BinOp Seq
Creating Node
  %add18 = add nsw i32 %7, %6
  %add18 = add nsw i32 %7, %6
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %sub23 = sub nsw i32 %add, %add18
  %conv43 = trunc i64 %9 to i32
  %sub59 = sub nsw i32 %sub, %conv57
  %conv43 = trunc i64 %9 to i32
  %sub = sub nsw i32 %0, %1
Match: 0
6 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add18 = add nsw i32 %7, %6
BinOp Seq
Creating Node
  %add18 = add nsw i32 %7, %6
  %add18 = add nsw i32 %7, %6
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %add = add nsw i32 %1, %0
  %conv43 = trunc i64 %9 to i32
  %sub = sub nsw i32 %0, %1
  %conv43 = trunc i64 %9 to i32
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
Match: 0
6 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add18 = add nsw i32 %7, %6
BinOp Seq
Creating Node
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %conv43 = trunc i64 %9 to i32
  %sub = sub nsw i32 %0, %1
  %conv43 = trunc i64 %9 to i32
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
BinOp Seq
Creating Node
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %conv43 = trunc i64 %9 to i32
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %conv43 = trunc i64 %9 to i32
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
Match: 0
4 x 8
Final Match: 0
GEPSeq2
BinOP?
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
i32 0
i32 0
i32 0
i32 0
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
i32 0
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
Match: 0
3 x 8
Final Match: 0
GEPSeq2
BinOP?
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
i32 0
i32 0
  %add18 = add nsw i32 %7, %6
i32 0
  %conv57 = trunc i64 %12 to i32
i32 0
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
Match: 0
4 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
BinOp Seq
Creating Node
i32 0
i32 0
i32 0
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
i32 0
  %conv57 = trunc i64 %12 to i32
i32 0
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
Match: 0
4 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
i32 0
i32 0
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %add = add nsw i32 %1, %0
  %add = add nsw i32 %1, %0
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
i32 0
  %conv47 = trunc i64 %10 to i32
i32 0
  %conv52 = trunc i64 %11 to i32
  %conv57 = trunc i64 %12 to i32
Match: 0
6 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add = add nsw i32 %1, %0
BinOp Seq
Creating Node
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
i32 0
  %conv47 = trunc i64 %10 to i32
i32 0
  %conv52 = trunc i64 %11 to i32
  %conv57 = trunc i64 %12 to i32
Match: 0
6 x 8
Final Match: 0
GEPSeq2
BinOP?
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
Mismatching
Creating Node
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
  %add24 = add nsw i32 %add12, %add6
  %add18 = add nsw i32 %7, %6
  %conv31 = trunc i64 %8 to i32
i32 0
  %add48 = add nsw i32 %conv43, %conv47
i32 0
  %add53 = add nsw i32 %conv43, %conv52
Match: 0
6 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
BinOp Seq
Creating Node
i32 0
  %add12 = add nsw i32 %5, %4
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
  %conv31 = trunc i64 %8 to i32
i32 0
  %conv43 = trunc i64 %9 to i32
i32 0
  %conv43 = trunc i64 %9 to i32
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
BinOp Seq
Creating Node
i32 0
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
  %conv31 = trunc i64 %8 to i32
i32 0
  %conv43 = trunc i64 %9 to i32
i32 0
  %conv43 = trunc i64 %9 to i32
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
  %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
  %add6 = add nsw i32 %3, %2
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
i32 0
i32 0
  %conv47 = trunc i64 %10 to i32
i32 0
  %conv52 = trunc i64 %11 to i32
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
BinOp Seq
Creating Node
i32 0
  %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
i32 0
i32 0
  %conv47 = trunc i64 %10 to i32
i32 0
  %conv52 = trunc i64 %11 to i32
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
  %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %add24 = add nsw i32 %add12, %add6
i32 0
  %conv31 = trunc i64 %8 to i32
i32 0
  %sub59 = sub nsw i32 %sub, %conv57
i32 0
  %add58 = add nsw i32 %sub, %conv57
i32 0
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add24 = add nsw i32 %add12, %add6
BinOp Seq
Creating Node
  %add12 = add nsw i32 %5, %4
i32 0
  %conv31 = trunc i64 %8 to i32
i32 0
  %sub59 = sub nsw i32 %sub, %conv57
i32 0
  %sub = sub nsw i32 %0, %1
i32 0
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add12 = add nsw i32 %5, %4
BinOp Seq
Creating Node
  %add12 = add nsw i32 %5, %4
i32 0
  %conv31 = trunc i64 %8 to i32
i32 0
  %sub = sub nsw i32 %0, %1
i32 0
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
i32 0
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add12 = add nsw i32 %5, %4
BinOp Seq
Creating Node
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
i32 0
  %conv31 = trunc i64 %8 to i32
i32 0
  %sub = sub nsw i32 %0, %1
i32 0
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
i32 0
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
BinOp Seq
Creating Node
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
i32 0
  %conv31 = trunc i64 %8 to i32
i32 0
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
i32 0
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
i32 0
Match: 0
4 x 8
Final Match: 0
GEPSeq2
BinOP?
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
i32 0
i32 0
i32 0
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
  %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
i32 0
i32 0
i32 0
  %conv57 = trunc i64 %12 to i32
i32 0
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
i32 0
Match: 0
3 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %add6 = add nsw i32 %3, %2
i32 0
i32 0
i32 0
i32 0
i32 0
  %conv57 = trunc i64 %12 to i32
i32 0
Match: 0
3 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add6 = add nsw i32 %3, %2
BinOp Seq
Creating Node
  %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
  %conv57 = trunc i64 %12 to i32
i32 0
Match: 0
3 x 8
Final Match: 0
GEPSeq2
BinOP?
  %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
Mismatching
Creating Node
  %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
  %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
Mismatching
Creating Node
  %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
  %arrayidx17 = getelementptr inbounds i32, i32* %dataptr.0, i64 4
  %arrayidx10 = getelementptr inbounds i32, i32* %dataptr.0, i64 2
  %arrayidx5 = getelementptr inbounds i32, i32* %dataptr.0, i64 6
  %arrayidx11 = getelementptr inbounds i32, i32* %dataptr.0, i64 5
  %arrayidx16 = getelementptr inbounds i32, i32* %dataptr.0, i64 3
  %arrayidx4 = getelementptr inbounds i32, i32* %dataptr.0, i64 1
  %arrayidx1 = getelementptr inbounds i32, i32* %dataptr.0, i64 7
Match: 0
8 x 8
Final Match: 0
  %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
  %arrayidx17 = getelementptr inbounds i32, i32* %dataptr.0, i64 4
  %arrayidx10 = getelementptr inbounds i32, i32* %dataptr.0, i64 2
  %arrayidx5 = getelementptr inbounds i32, i32* %dataptr.0, i64 6
  %arrayidx11 = getelementptr inbounds i32, i32* %dataptr.0, i64 5
  %arrayidx16 = getelementptr inbounds i32, i32* %dataptr.0, i64 3
  %arrayidx4 = getelementptr inbounds i32, i32* %dataptr.0, i64 1
  %arrayidx1 = getelementptr inbounds i32, i32* %dataptr.0, i64 7
Ptr:   %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 4
i64 2
i64 6
i64 5
i64 3
i64 1
i64 7
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
i64 0
Mismatching
Invalid:   %arrayidx16 = getelementptr inbounds i32, i32* %dataptr.0, i64 3
Invalid dependence found!
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
8 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
9 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
10 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
12 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
13 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
15 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
16 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
17 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
18 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
19 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
20 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
21 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
22 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
23 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
24 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
25 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
26 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
27 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
28 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
29 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
30 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
31 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
32 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
33 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
34 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
35 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
34->0 
2->1 
23->1 
3->2 
16->2 
4->3 
13->3 
5->4 
10->4 
6->5 
9->5 
7->6 
8->6 
11->10 
12->10 
14->13 
15->13 
17->16 
20->16 
18->17 
19->17 
21->20 
22->20 
24->23 
31->23 
25->24 
30->24 
26->25 
29->25 
27->26 
28->26 
32->31 
33->31 
35->34 
36 [label="add", style="filled" , fillcolor="#f2eb5c", shape=box];
2->36
4->36
37 [label="add", style="filled" , fillcolor="#f2eb5c", shape=box];
4->37
6->37
38 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
17->38
20->38
24->37
25->38
26->37
31->38
39 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->39
40 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->40
41 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->41
42 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->42
43 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->43
44 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->44
45 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->45
}


for.body:                                         ; preds = %for.cond
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %arrayidx1 = getelementptr inbounds i32, i32* %dataptr.0, i64 7
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %add = add nsw i32 %1, %0
  %sub = sub nsw i32 %0, %1
  %arrayidx4 = getelementptr inbounds i32, i32* %dataptr.0, i64 1
  %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
  %arrayidx5 = getelementptr inbounds i32, i32* %dataptr.0, i64 6
  %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
  %add6 = add nsw i32 %3, %2
  %sub9 = sub nsw i32 %2, %3
  %arrayidx10 = getelementptr inbounds i32, i32* %dataptr.0, i64 2
  %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
  %arrayidx11 = getelementptr inbounds i32, i32* %dataptr.0, i64 5
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
  %add12 = add nsw i32 %5, %4
  %sub15 = sub nsw i32 %4, %5
  %arrayidx16 = getelementptr inbounds i32, i32* %dataptr.0, i64 3
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
  %arrayidx17 = getelementptr inbounds i32, i32* %dataptr.0, i64 4
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
  %add18 = add nsw i32 %7, %6
  %sub21 = sub nsw i32 %6, %7
  %add22 = add nsw i32 %add18, %add
  %sub23 = sub nsw i32 %add, %add18
  %add24 = add nsw i32 %add12, %add6
  %sub25 = sub i32 %add6, %add12
  %add26 = add nsw i32 %add22, %add24
  store i32 %add26, i32* %dataptr.0, align 4, !tbaa !2
  %sub28 = sub nsw i32 %add22, %add24
  store i32 %sub28, i32* %arrayidx17, align 4, !tbaa !2
  %add30 = add nsw i32 %sub25, %sub23
  %conv = sext i32 %add30 to i64
  %mul = mul nsw i64 %conv, 181
  %8 = lshr i64 %mul, 8
  %conv31 = trunc i64 %8 to i32
  %add32 = add nsw i32 %sub23, %conv31
  store i32 %add32, i32* %arrayidx10, align 4, !tbaa !2
  %sub34 = sub nsw i32 %sub23, %conv31
  store i32 %sub34, i32* %arrayidx5, align 4, !tbaa !2
  %add36 = add nsw i32 %sub21, %sub15
  %add37 = add nsw i32 %sub15, %sub9
  %add38 = add nsw i32 %sub9, %sub
  %sub39 = sub nsw i32 %add36, %add38
  %conv40 = sext i32 %sub39 to i64
  %mul41 = mul nsw i64 %conv40, 98
  %9 = lshr i64 %mul41, 8
  %conv43 = trunc i64 %9 to i32
  %conv44 = sext i32 %add36 to i64
  %mul45 = mul nsw i64 %conv44, 139
  %10 = lshr i64 %mul45, 8
  %conv47 = trunc i64 %10 to i32
  %add48 = add nsw i32 %conv43, %conv47
  %conv49 = sext i32 %add38 to i64
  %mul50 = mul nsw i64 %conv49, 334
  %11 = lshr i64 %mul50, 8
  %conv52 = trunc i64 %11 to i32
  %add53 = add nsw i32 %conv43, %conv52
  %conv54 = sext i32 %add37 to i64
  %mul55 = mul nsw i64 %conv54, 181
  %12 = lshr i64 %mul55, 8
  %conv57 = trunc i64 %12 to i32
  %add58 = add nsw i32 %sub, %conv57
  %sub59 = sub nsw i32 %sub, %conv57
  %add60 = add nsw i32 %add48, %sub59
  store i32 %add60, i32* %arrayidx11, align 4, !tbaa !2
  %sub62 = sub nsw i32 %sub59, %add48
  store i32 %sub62, i32* %arrayidx16, align 4, !tbaa !2
  %add64 = add nsw i32 %add53, %add58
  store i32 %add64, i32* %arrayidx4, align 4, !tbaa !2
  %sub66 = sub nsw i32 %add58, %add53
  store i32 %sub66, i32* %arrayidx1, align 4, !tbaa !2
  %add.ptr = getelementptr inbounds i32, i32* %dataptr.0, i64 8
  %dec = add nsw i32 %ctr.0, -1
  br label %for.cond, !llvm.loop !6

Trying AGAIN
Trying AGAIN
Creating Node
  store i32 %sub28, i32* %arrayidx17, align 4, !tbaa !2
  store i32 %add32, i32* %arrayidx10, align 4, !tbaa !2
  store i32 %sub34, i32* %arrayidx5, align 4, !tbaa !2
  store i32 %add60, i32* %arrayidx11, align 4, !tbaa !2
  store i32 %sub62, i32* %arrayidx16, align 4, !tbaa !2
  store i32 %add64, i32* %arrayidx4, align 4, !tbaa !2
  store i32 %sub66, i32* %arrayidx1, align 4, !tbaa !2
Match: 1
7 x 7
Final Match: 1
Matching
Creating Node
  %sub28 = sub nsw i32 %add22, %add24
  %add32 = add nsw i32 %sub23, %conv31
  %sub34 = sub nsw i32 %sub23, %conv31
  %add60 = add nsw i32 %add48, %sub59
  %sub62 = sub nsw i32 %sub59, %add48
  %add64 = add nsw i32 %add53, %add58
  %sub66 = sub nsw i32 %add58, %add53
Match: 0
7 x 7
Final Match: 0
GEPSeq2
BinOP?
  %sub28 = sub nsw i32 %add22, %add24
BinOp Seq
Creating Node
  %add22 = add nsw i32 %add18, %add
  %add32 = add nsw i32 %sub23, %conv31
  %sub23 = sub nsw i32 %add, %add18
  %add60 = add nsw i32 %add48, %sub59
  %sub59 = sub nsw i32 %sub, %conv57
  %add64 = add nsw i32 %add53, %add58
  %add58 = add nsw i32 %sub, %conv57
Match: 0
7 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add22 = add nsw i32 %add18, %add
BinOp Seq
Creating Node
  %add18 = add nsw i32 %7, %6
  %sub23 = sub nsw i32 %add, %add18
  %sub23 = sub nsw i32 %add, %add18
  %add48 = add nsw i32 %conv43, %conv47
  %sub59 = sub nsw i32 %sub, %conv57
  %add53 = add nsw i32 %conv43, %conv52
  %sub = sub nsw i32 %0, %1
Match: 0
6 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add18 = add nsw i32 %7, %6
BinOp Seq
Creating Node
  %add18 = add nsw i32 %7, %6
  %add = add nsw i32 %1, %0
  %add = add nsw i32 %1, %0
  %add48 = add nsw i32 %conv43, %conv47
  %sub = sub nsw i32 %0, %1
  %add53 = add nsw i32 %conv43, %conv52
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
Match: 0
6 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add18 = add nsw i32 %7, %6
BinOp Seq
Creating Node
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %conv43 = trunc i64 %9 to i32
  %sub = sub nsw i32 %0, %1
  %conv43 = trunc i64 %9 to i32
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
Match: 0
5 x 7
Final Match: 0
GEPSeq2
BinOP?
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
BinOp Seq
Creating Node
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %conv43 = trunc i64 %9 to i32
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %conv43 = trunc i64 %9 to i32
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
i32 0
i32 0
i32 0
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
i32 0
i32 0
Match: 0
2 x 7
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %conv47 = trunc i64 %10 to i32
i32 0
  %conv52 = trunc i64 %11 to i32
i32 0
Match: 0
5 x 7
Final Match: 0
GEPSeq2
BinOP?
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
  %add18 = add nsw i32 %7, %6
  %add18 = add nsw i32 %7, %6
i32 0
  %conv57 = trunc i64 %12 to i32
i32 0
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
i32 0
BinOp Seq
Creating Node
i32 0
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
i32 0
  %conv57 = trunc i64 %12 to i32
i32 0
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 7
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %add = add nsw i32 %1, %0
  %conv31 = trunc i64 %8 to i32
i32 0
  %sub59 = sub nsw i32 %sub, %conv57
i32 0
  %add58 = add nsw i32 %sub, %conv57
  %conv57 = trunc i64 %12 to i32
Match: 0
6 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add = add nsw i32 %1, %0
BinOp Seq
Creating Node
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %conv31 = trunc i64 %8 to i32
i32 0
  %sub59 = sub nsw i32 %sub, %conv57
i32 0
  %sub = sub nsw i32 %0, %1
  %conv57 = trunc i64 %12 to i32
Match: 0
6 x 7
Final Match: 0
GEPSeq2
BinOP?
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
BinOp Seq
Creating Node
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %conv31 = trunc i64 %8 to i32
i32 0
  %sub = sub nsw i32 %0, %1
i32 0
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %conv57 = trunc i64 %12 to i32
Match: 0
6 x 7
Final Match: 0
GEPSeq2
BinOP?
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
BinOp Seq
Creating Node
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %conv31 = trunc i64 %8 to i32
i32 0
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
i32 0
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %conv57 = trunc i64 %12 to i32
Match: 0
5 x 7
Final Match: 0
GEPSeq2
BinOP?
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
i32 0
i32 0
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
i32 0
i32 0
i32 0
Match: 0
2 x 7
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
i32 0
i32 0
  %conv57 = trunc i64 %12 to i32
i32 0
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
i32 0
Match: 0
3 x 7
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
  %conv57 = trunc i64 %12 to i32
i32 0
Match: 0
3 x 7
Final Match: 0
GEPSeq2
BinOP?
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
Mismatching
Creating Node
  %add24 = add nsw i32 %add12, %add6
i32 0
  %conv31 = trunc i64 %8 to i32
i32 0
  %add48 = add nsw i32 %conv43, %conv47
i32 0
  %add53 = add nsw i32 %conv43, %conv52
Match: 0
5 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add24 = add nsw i32 %add12, %add6
BinOp Seq
Creating Node
  %add12 = add nsw i32 %5, %4
i32 0
  %conv31 = trunc i64 %8 to i32
i32 0
  %conv43 = trunc i64 %9 to i32
i32 0
  %conv43 = trunc i64 %9 to i32
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add12 = add nsw i32 %5, %4
BinOp Seq
Creating Node
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
i32 0
  %conv31 = trunc i64 %8 to i32
i32 0
  %conv43 = trunc i64 %9 to i32
i32 0
  %conv43 = trunc i64 %9 to i32
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
Mismatching
Creating Node
  %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 7
Final Match: 0
GEPSeq2
BinOP?
  %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
Mismatching
Creating Node
  %add6 = add nsw i32 %3, %2
i32 0
i32 0
i32 0
  %conv47 = trunc i64 %10 to i32
i32 0
  %conv52 = trunc i64 %11 to i32
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add6 = add nsw i32 %3, %2
BinOp Seq
Creating Node
  %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
i32 0
i32 0
i32 0
  %conv47 = trunc i64 %10 to i32
i32 0
  %conv52 = trunc i64 %11 to i32
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
  %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
Mismatching
Creating Node
  %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 7
Final Match: 0
GEPSeq2
BinOP?
  %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
Mismatching
Creating Node
  %arrayidx17 = getelementptr inbounds i32, i32* %dataptr.0, i64 4
  %arrayidx10 = getelementptr inbounds i32, i32* %dataptr.0, i64 2
  %arrayidx5 = getelementptr inbounds i32, i32* %dataptr.0, i64 6
  %arrayidx11 = getelementptr inbounds i32, i32* %dataptr.0, i64 5
  %arrayidx16 = getelementptr inbounds i32, i32* %dataptr.0, i64 3
  %arrayidx4 = getelementptr inbounds i32, i32* %dataptr.0, i64 1
  %arrayidx1 = getelementptr inbounds i32, i32* %dataptr.0, i64 7
Match: 1
7 x 7
Final Match: 1
Matching
Creating Node
  %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
  %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
  %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
  %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
  %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
  %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
  %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
Match: 0
1 x 7
Final Match: 0
All the Same
Creating Node
i64 4
i64 2
i64 6
i64 5
i64 3
i64 1
i64 7
Match: 0
7 x 7
Final Match: 0
GEPSeq2
BinOP?
i64 4
Mismatching
Invalid:   %arrayidx16 = getelementptr inbounds i32, i32* %dataptr.0, i64 3
Invalid dependence found!
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
7 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
8 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
9 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
11 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
12 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
13 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
15 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
16 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
17 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
18 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
19 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
20 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
21 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
22 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
23 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
24 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
25 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
26 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
27 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
28 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
26->0 
2->1 
19->1 
3->2 
12->2 
4->3 
9->3 
5->4 
8->4 
6->5 
7->5 
10->9 
11->9 
13->12 
18->12 
14->13 
17->13 
15->14 
16->14 
20->19 
23->19 
21->20 
22->20 
24->23 
25->23 
27->26 
28->26 
29 [label="add", style="filled" , fillcolor="#f2eb5c", shape=box];
2->29
30 [label="add", style="filled" , fillcolor="#f2eb5c", shape=box];
3->30
3->30
31 [label="add", style="filled" , fillcolor="#f2eb5c", shape=box];
3->31
5->31
13->31
14->31
19->29
32 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
20->32
23->32
33 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->33
34 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->34
35 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->35
36 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->36
37 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->37
38 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->38
39 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->39
}


for.body:                                         ; preds = %for.cond
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %arrayidx1 = getelementptr inbounds i32, i32* %dataptr.0, i64 7
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %add = add nsw i32 %1, %0
  %sub = sub nsw i32 %0, %1
  %arrayidx4 = getelementptr inbounds i32, i32* %dataptr.0, i64 1
  %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
  %arrayidx5 = getelementptr inbounds i32, i32* %dataptr.0, i64 6
  %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
  %add6 = add nsw i32 %3, %2
  %sub9 = sub nsw i32 %2, %3
  %arrayidx10 = getelementptr inbounds i32, i32* %dataptr.0, i64 2
  %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
  %arrayidx11 = getelementptr inbounds i32, i32* %dataptr.0, i64 5
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
  %add12 = add nsw i32 %5, %4
  %sub15 = sub nsw i32 %4, %5
  %arrayidx16 = getelementptr inbounds i32, i32* %dataptr.0, i64 3
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
  %arrayidx17 = getelementptr inbounds i32, i32* %dataptr.0, i64 4
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
  %add18 = add nsw i32 %7, %6
  %sub21 = sub nsw i32 %6, %7
  %add22 = add nsw i32 %add18, %add
  %sub23 = sub nsw i32 %add, %add18
  %add24 = add nsw i32 %add12, %add6
  %sub25 = sub i32 %add6, %add12
  %add26 = add nsw i32 %add22, %add24
  store i32 %add26, i32* %dataptr.0, align 4, !tbaa !2
  %sub28 = sub nsw i32 %add22, %add24
  store i32 %sub28, i32* %arrayidx17, align 4, !tbaa !2
  %add30 = add nsw i32 %sub25, %sub23
  %conv = sext i32 %add30 to i64
  %mul = mul nsw i64 %conv, 181
  %8 = lshr i64 %mul, 8
  %conv31 = trunc i64 %8 to i32
  %add32 = add nsw i32 %sub23, %conv31
  store i32 %add32, i32* %arrayidx10, align 4, !tbaa !2
  %sub34 = sub nsw i32 %sub23, %conv31
  store i32 %sub34, i32* %arrayidx5, align 4, !tbaa !2
  %add36 = add nsw i32 %sub21, %sub15
  %add37 = add nsw i32 %sub15, %sub9
  %add38 = add nsw i32 %sub9, %sub
  %sub39 = sub nsw i32 %add36, %add38
  %conv40 = sext i32 %sub39 to i64
  %mul41 = mul nsw i64 %conv40, 98
  %9 = lshr i64 %mul41, 8
  %conv43 = trunc i64 %9 to i32
  %conv44 = sext i32 %add36 to i64
  %mul45 = mul nsw i64 %conv44, 139
  %10 = lshr i64 %mul45, 8
  %conv47 = trunc i64 %10 to i32
  %add48 = add nsw i32 %conv43, %conv47
  %conv49 = sext i32 %add38 to i64
  %mul50 = mul nsw i64 %conv49, 334
  %11 = lshr i64 %mul50, 8
  %conv52 = trunc i64 %11 to i32
  %add53 = add nsw i32 %conv43, %conv52
  %conv54 = sext i32 %add37 to i64
  %mul55 = mul nsw i64 %conv54, 181
  %12 = lshr i64 %mul55, 8
  %conv57 = trunc i64 %12 to i32
  %add58 = add nsw i32 %sub, %conv57
  %sub59 = sub nsw i32 %sub, %conv57
  %add60 = add nsw i32 %add48, %sub59
  store i32 %add60, i32* %arrayidx11, align 4, !tbaa !2
  %sub62 = sub nsw i32 %sub59, %add48
  store i32 %sub62, i32* %arrayidx16, align 4, !tbaa !2
  %add64 = add nsw i32 %add53, %add58
  store i32 %add64, i32* %arrayidx4, align 4, !tbaa !2
  %sub66 = sub nsw i32 %add58, %add53
  store i32 %sub66, i32* %arrayidx1, align 4, !tbaa !2
  %add.ptr = getelementptr inbounds i32, i32* %dataptr.0, i64 8
  %dec = add nsw i32 %ctr.0, -1
  br label %for.cond, !llvm.loop !6

Building reduction
  store i32 %add64, i32* %arrayidx4, align 4, !tbaa !2
  %add64 = add nsw i32 %add53, %add58
BOs:
  %add64 = add nsw i32 %add53, %add58
  %add53 = add nsw i32 %conv43, %conv52
  %add58 = add nsw i32 %sub, %conv57
Operands:
  %conv43 = trunc i64 %9 to i32
  %conv52 = trunc i64 %11 to i32
  %sub = sub nsw i32 %0, %1
  %conv57 = trunc i64 %12 to i32
Operands:
  %sub = sub nsw i32 %0, %1
  %conv43 = trunc i64 %9 to i32
  %conv52 = trunc i64 %11 to i32
  %conv57 = trunc i64 %12 to i32
ReductionNode
Creating Node
  %sub = sub nsw i32 %0, %1
  %conv43 = trunc i64 %9 to i32
  %conv52 = trunc i64 %11 to i32
  %conv57 = trunc i64 %12 to i32
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %sub = sub nsw i32 %0, %1
BinOp Seq
Creating Node
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %conv43 = trunc i64 %9 to i32
  %conv52 = trunc i64 %11 to i32
  %conv57 = trunc i64 %12 to i32
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
Mismatching
Creating Node
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
i32 0
i32 0
i32 0
Match: 0
2 x 4
Final Match: 0
GEPSeq2
BinOP?
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
Mismatching
Invalid:   %sub = sub nsw i32 %0, %1
Invalid dependence found!
Building reduction
  store i32 %add26, i32* %dataptr.0, align 4, !tbaa !2
  %add26 = add nsw i32 %add22, %add24
BOs:
  %add26 = add nsw i32 %add22, %add24
  %add22 = add nsw i32 %add18, %add
  %add18 = add nsw i32 %7, %6
  %add = add nsw i32 %1, %0
  %add24 = add nsw i32 %add12, %add6
  %add12 = add nsw i32 %5, %4
  %add6 = add nsw i32 %3, %2
Operands:
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
  %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
  %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
  %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
Operands:
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
  %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
  %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
ReductionNode
Creating Node
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
  %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
  %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
  %arrayidx1 = getelementptr inbounds i32, i32* %dataptr.0, i64 7
  %arrayidx4 = getelementptr inbounds i32, i32* %dataptr.0, i64 1
  %arrayidx5 = getelementptr inbounds i32, i32* %dataptr.0, i64 6
  %arrayidx10 = getelementptr inbounds i32, i32* %dataptr.0, i64 2
  %arrayidx11 = getelementptr inbounds i32, i32* %dataptr.0, i64 5
  %arrayidx16 = getelementptr inbounds i32, i32* %dataptr.0, i64 3
  %arrayidx17 = getelementptr inbounds i32, i32* %dataptr.0, i64 4
Match: 0
8 x 8
Final Match: 0
  %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
  %arrayidx1 = getelementptr inbounds i32, i32* %dataptr.0, i64 7
  %arrayidx4 = getelementptr inbounds i32, i32* %dataptr.0, i64 1
  %arrayidx5 = getelementptr inbounds i32, i32* %dataptr.0, i64 6
  %arrayidx10 = getelementptr inbounds i32, i32* %dataptr.0, i64 2
  %arrayidx11 = getelementptr inbounds i32, i32* %dataptr.0, i64 5
  %arrayidx16 = getelementptr inbounds i32, i32* %dataptr.0, i64 3
  %arrayidx17 = getelementptr inbounds i32, i32* %dataptr.0, i64 4
Ptr:   %dataptr.0 = phi i32* [ %data, %entry ], [ %add.ptr, %for.body ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 7
i64 1
i64 6
i64 2
i64 5
i64 3
i64 4
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
i64 0
Mismatching
ScheduleNode: {
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
  %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
  %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
}
ScheduleNode: {
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
  %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
  %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
}
Count: 8
Start:   %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
Processing:   %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
Count: 8
Found:   %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
Non-memory:   %arrayidx1 = getelementptr inbounds i32, i32* %dataptr.0, i64 7
Processing:   %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
Count: 7
Found:   %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
Non-memory:   %add = add nsw i32 %1, %0
Non-memory:   %sub = sub nsw i32 %0, %1
Non-memory:   %arrayidx4 = getelementptr inbounds i32, i32* %dataptr.0, i64 1
Processing:   %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
Count: 6
Found:   %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
Non-memory:   %arrayidx5 = getelementptr inbounds i32, i32* %dataptr.0, i64 6
Processing:   %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
Count: 5
Found:   %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
Non-memory:   %add6 = add nsw i32 %3, %2
Non-memory:   %sub9 = sub nsw i32 %2, %3
Non-memory:   %arrayidx10 = getelementptr inbounds i32, i32* %dataptr.0, i64 2
Processing:   %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
Count: 4
Found:   %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
Non-memory:   %arrayidx11 = getelementptr inbounds i32, i32* %dataptr.0, i64 5
Processing:   %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
Count: 3
Found:   %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
Non-memory:   %add12 = add nsw i32 %5, %4
Non-memory:   %sub15 = sub nsw i32 %4, %5
Non-memory:   %arrayidx16 = getelementptr inbounds i32, i32* %dataptr.0, i64 3
Processing:   %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
Count: 2
Found:   %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
Non-memory:   %arrayidx17 = getelementptr inbounds i32, i32* %dataptr.0, i64 4
Processing:   %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
Count: 1
Found:   %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
I:   %add18 = add nsw i32 %7, %6
Last:   br label %for.cond, !llvm.loop !6
Schedulable: 1
Loop Rolling: jpeg_fdct_ifast
Generating tree
Generating REDUCTION
Generating MATCH
Match: 
  %0 = load i32, i32* %dataptr.0, align 4, !tbaa !2
  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !2
  %2 = load i32, i32* %arrayidx4, align 4, !tbaa !2
  %3 = load i32, i32* %arrayidx5, align 4, !tbaa !2
  %4 = load i32, i32* %arrayidx10, align 4, !tbaa !2
  %5 = load i32, i32* %arrayidx11, align 4, !tbaa !2
  %6 = load i32, i32* %arrayidx16, align 4, !tbaa !2
  %7 = load i32, i32* %arrayidx17, align 4, !tbaa !2
Generating GEPSEQ
Generating Mismatch
Mismatched Values:
int: i64 0
int: i64 7
int: i64 1
int: i64 6
int: i64 2
int: i64 5
int: i64 3
int: i64 4
All constants
Created array: @0 = private constant [8 x i64] [i64 0, i64 7, i64 1, i64 6, i64 2, i64 5, i64 3, i64 4]
Gen:   %28 = load i64, i64* %27, align 8
Closing GEPSEQ
Found use: 1:   store i32 %sub66, i32* %arrayidx1, align 4, !tbaa !2
Found use: 2:   store i32 %add64, i32* %arrayidx4, align 4, !tbaa !2
Found use: 3:   store i32 %sub34, i32* %arrayidx5, align 4, !tbaa !2
Found use: 4:   store i32 %add32, i32* %arrayidx10, align 4, !tbaa !2
Found use: 5:   store i32 %add60, i32* %arrayidx11, align 4, !tbaa !2
Found use: 6:   store i32 %sub62, i32* %arrayidx16, align 4, !tbaa !2
Found use: 7:   store i32 %sub28, i32* %arrayidx17, align 4, !tbaa !2
Extracting:   %29 = getelementptr i32, i32* %dataptr.0, i64 %28
Gen:   %30 = getelementptr i32, i32* %dataptr.0, i64 %29
Operands done!
Generated:   %32 = load i32, i32* %30, align 1
Found use: 0:   %sub = sub nsw i32 %1, %2
Found use: 1:   %sub = sub nsw i32 %1, %2
Found use: 2:   %sub9 = sub nsw i32 %3, %4
Found use: 3:   %sub9 = sub nsw i32 %3, %4
Found use: 4:   %sub15 = sub nsw i32 %5, %6
Found use: 5:   %sub15 = sub nsw i32 %5, %6
Found use: 6:   %sub21 = sub nsw i32 %7, %8
Found use: 7:   %sub21 = sub nsw i32 %7, %8
Extracting:   %32 = load i32, i32* %30, align 1
Gen:   %33 = load i32, i32* %31, align 1
Closing REDUCTION
Found use: 0:   store i32 %add26, i32* %dataptr.0, align 4, !tbaa !2
Found use: 1:   %sub28 = sub nsw i32 %add22, %add24
Found use: 2:   %sub23 = sub nsw i32 %add, %add18
Found use: 3:   %sub23 = sub nsw i32 %add, %add18
Found use: 4:   %sub28 = sub nsw i32 %add22, %add24
Found use: 5:   %sub25 = sub i32 %add6, %add12
Found use: 6:   %sub25 = sub i32 %add6, %add12
Extracting:   %36 = add nsw i32 %29, %34
Gen:   %37 = add nsw i32 %30, %35
Graph code generated!
Root:
  %add26 = add nsw i32 %add22, %add24
  %add22 = add nsw i32 %add18, %add
  %add18 = add nsw i32 %10, %9
  %add = add nsw i32 %4, %3
  %add24 = add nsw i32 %add12, %add6
  %add12 = add nsw i32 %8, %7
  %add6 = add nsw i32 %6, %5
Root size: 7
digraph VTree {
0 [label="add red.", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->1 
3->2 
4 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
0->4
5 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
0->5
6 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
0->6
0->6
0->5
7 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
0->7
0->7
8 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->8
1->8
9 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->9
1->9
10 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->10
1->10
11 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->11
1->11
12 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->12
13 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->13
14 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->14
15 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->15
16 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->16
17 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->17
18 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->18
}

Gains: 30 - 151 = -121; Width: 7; Reduction Unprofitable; jpeg_fdct_ifast
Building reduction
  store i32 %add60, i32* %arrayidx11, align 4, !tbaa !2
  %add60 = add nsw i32 %add48, %sub59
BOs:
  %add60 = add nsw i32 %add48, %sub59
  %add48 = add nsw i32 %conv43, %conv47
Operands:
  %conv43 = trunc i64 %12 to i32
  %conv47 = trunc i64 %13 to i32
  %sub59 = sub nsw i32 %sub, %conv57
Operands:
  %conv43 = trunc i64 %12 to i32
  %conv47 = trunc i64 %13 to i32
  %sub59 = sub nsw i32 %sub, %conv57
ReductionNode
Creating Node
  %conv43 = trunc i64 %12 to i32
  %conv47 = trunc i64 %13 to i32
  %sub59 = sub nsw i32 %sub, %conv57
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %conv43 = trunc i64 %12 to i32
BinOp Seq
Creating Node
  %conv43 = trunc i64 %12 to i32
  %conv47 = trunc i64 %13 to i32
  %sub = sub nsw i32 %3, %4
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %conv43 = trunc i64 %12 to i32
BinOp Seq
Creating Node
  %conv43 = trunc i64 %12 to i32
  %conv47 = trunc i64 %13 to i32
  %3 = load i32, i32* %dataptr.0, align 4, !tbaa !2
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %conv43 = trunc i64 %12 to i32
Mismatching
Creating Node
i32 0
i32 0
  %4 = load i32, i32* %arrayidx1, align 4, !tbaa !2
Match: 0
2 x 3
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
i32 0
  %conv57 = trunc i64 %15 to i32
Match: 0
2 x 3
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Invalid:   %sub = sub nsw i32 %3, %4
Invalid dependence found!
  %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
  %ctr.1 = phi i32 [ %dec146, %for.body71 ], [ 7, %for.cond68.preheader ]
looking for reduction
looking for reduction
  %add100 = add nsw i32 %add96, %add98
Found
looking for reduction
  %sub102 = sub nsw i32 %add96, %add98
looking for reduction
  %add109 = add nsw i32 %sub97, %conv108
looking for reduction
  %sub111 = sub nsw i32 %sub97, %conv108
looking for reduction
  %add137 = add nsw i32 %add125, %sub136
Found
looking for reduction
  %sub139 = sub nsw i32 %sub136, %add125
looking for reduction
  %add141 = add nsw i32 %add130, %add135
Found
looking for reduction
  %sub143 = sub nsw i32 %add135, %add130
Attempting Group:
  store i32 %add100, i32* %dataptr.1, align 4, !tbaa !2
  store i32 %sub102, i32* %arrayidx91, align 4, !tbaa !2
  store i32 %add109, i32* %arrayidx84, align 4, !tbaa !2
  store i32 %sub111, i32* %arrayidx79, align 4, !tbaa !2
  store i32 %add137, i32* %arrayidx85, align 4, !tbaa !2
  store i32 %sub139, i32* %arrayidx90, align 4, !tbaa !2
  store i32 %add141, i32* %arrayidx78, align 4, !tbaa !2
  store i32 %sub143, i32* %arrayidx73, align 4, !tbaa !2
Creating Node
  store i32 %add100, i32* %dataptr.1, align 4, !tbaa !2
  store i32 %sub102, i32* %arrayidx91, align 4, !tbaa !2
  store i32 %add109, i32* %arrayidx84, align 4, !tbaa !2
  store i32 %sub111, i32* %arrayidx79, align 4, !tbaa !2
  store i32 %add137, i32* %arrayidx85, align 4, !tbaa !2
  store i32 %sub139, i32* %arrayidx90, align 4, !tbaa !2
  store i32 %add141, i32* %arrayidx78, align 4, !tbaa !2
  store i32 %sub143, i32* %arrayidx73, align 4, !tbaa !2
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %add100 = add nsw i32 %add96, %add98
  %sub102 = sub nsw i32 %add96, %add98
  %add109 = add nsw i32 %sub97, %conv108
  %sub111 = sub nsw i32 %sub97, %conv108
  %add137 = add nsw i32 %add125, %sub136
  %sub139 = sub nsw i32 %sub136, %add125
  %add141 = add nsw i32 %add130, %add135
  %sub143 = sub nsw i32 %add135, %add130
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add100 = add nsw i32 %add96, %add98
BinOp Seq
Creating Node
  %add96 = add nsw i32 %add92, %add74
  %sub102 = sub nsw i32 %add96, %add98
  %sub97 = sub nsw i32 %add74, %add92
  %sub111 = sub nsw i32 %sub97, %conv108
  %add125 = add nsw i32 %conv120, %conv124
  %sub139 = sub nsw i32 %sub136, %add125
  %add130 = add nsw i32 %conv120, %conv129
  %sub143 = sub nsw i32 %add135, %add130
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add96 = add nsw i32 %add92, %add74
BinOp Seq
Creating Node
  %add96 = add nsw i32 %add92, %add74
  %add96 = add nsw i32 %add92, %add74
  %add74 = add nsw i32 %17, %16
  %sub97 = sub nsw i32 %add74, %add92
  %add125 = add nsw i32 %conv120, %conv124
  %sub136 = sub nsw i32 %sub77, %conv134
  %add130 = add nsw i32 %conv120, %conv129
  %add135 = add nsw i32 %sub77, %conv134
Match: 0
7 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add96 = add nsw i32 %add92, %add74
BinOp Seq
Creating Node
  %add92 = add nsw i32 %23, %22
  %add92 = add nsw i32 %23, %22
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %sub97 = sub nsw i32 %add74, %add92
  %conv120 = trunc i64 %25 to i32
  %sub136 = sub nsw i32 %sub77, %conv134
  %conv120 = trunc i64 %25 to i32
  %sub77 = sub nsw i32 %16, %17
Match: 0
6 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add92 = add nsw i32 %23, %22
BinOp Seq
Creating Node
  %add92 = add nsw i32 %23, %22
  %add92 = add nsw i32 %23, %22
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %add74 = add nsw i32 %17, %16
  %conv120 = trunc i64 %25 to i32
  %sub77 = sub nsw i32 %16, %17
  %conv120 = trunc i64 %25 to i32
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
Match: 0
6 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add92 = add nsw i32 %23, %22
BinOp Seq
Creating Node
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %conv120 = trunc i64 %25 to i32
  %sub77 = sub nsw i32 %16, %17
  %conv120 = trunc i64 %25 to i32
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
BinOp Seq
Creating Node
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %conv120 = trunc i64 %25 to i32
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %conv120 = trunc i64 %25 to i32
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
Match: 0
4 x 8
Final Match: 0
GEPSeq2
BinOP?
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
i32 0
i32 0
i32 0
i32 0
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
i32 0
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
Match: 0
3 x 8
Final Match: 0
GEPSeq2
BinOP?
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
i32 0
i32 0
  %add92 = add nsw i32 %23, %22
i32 0
  %conv134 = trunc i64 %28 to i32
i32 0
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
Match: 0
4 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
BinOp Seq
Creating Node
i32 0
i32 0
i32 0
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
i32 0
  %conv134 = trunc i64 %28 to i32
i32 0
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
Match: 0
4 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
i32 0
i32 0
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %add74 = add nsw i32 %17, %16
  %add74 = add nsw i32 %17, %16
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
i32 0
  %conv124 = trunc i64 %26 to i32
i32 0
  %conv129 = trunc i64 %27 to i32
  %conv134 = trunc i64 %28 to i32
Match: 0
6 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add74 = add nsw i32 %17, %16
BinOp Seq
Creating Node
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
i32 0
  %conv124 = trunc i64 %26 to i32
i32 0
  %conv129 = trunc i64 %27 to i32
  %conv134 = trunc i64 %28 to i32
Match: 0
6 x 8
Final Match: 0
GEPSeq2
BinOP?
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
Mismatching
Creating Node
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
  %add98 = add nsw i32 %add86, %add80
  %add92 = add nsw i32 %23, %22
  %conv108 = trunc i64 %24 to i32
i32 0
  %add125 = add nsw i32 %conv120, %conv124
i32 0
  %add130 = add nsw i32 %conv120, %conv129
Match: 0
6 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
BinOp Seq
Creating Node
i32 0
  %add86 = add nsw i32 %21, %20
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
  %conv108 = trunc i64 %24 to i32
i32 0
  %conv120 = trunc i64 %25 to i32
i32 0
  %conv120 = trunc i64 %25 to i32
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
BinOp Seq
Creating Node
i32 0
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
  %conv108 = trunc i64 %24 to i32
i32 0
  %conv120 = trunc i64 %25 to i32
i32 0
  %conv120 = trunc i64 %25 to i32
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
  %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
  %add80 = add nsw i32 %19, %18
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
i32 0
i32 0
  %conv124 = trunc i64 %26 to i32
i32 0
  %conv129 = trunc i64 %27 to i32
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
BinOp Seq
Creating Node
i32 0
  %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
i32 0
i32 0
  %conv124 = trunc i64 %26 to i32
i32 0
  %conv129 = trunc i64 %27 to i32
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
  %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %add98 = add nsw i32 %add86, %add80
i32 0
  %conv108 = trunc i64 %24 to i32
i32 0
  %sub136 = sub nsw i32 %sub77, %conv134
i32 0
  %add135 = add nsw i32 %sub77, %conv134
i32 0
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add98 = add nsw i32 %add86, %add80
BinOp Seq
Creating Node
  %add86 = add nsw i32 %21, %20
i32 0
  %conv108 = trunc i64 %24 to i32
i32 0
  %sub136 = sub nsw i32 %sub77, %conv134
i32 0
  %sub77 = sub nsw i32 %16, %17
i32 0
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add86 = add nsw i32 %21, %20
BinOp Seq
Creating Node
  %add86 = add nsw i32 %21, %20
i32 0
  %conv108 = trunc i64 %24 to i32
i32 0
  %sub77 = sub nsw i32 %16, %17
i32 0
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
i32 0
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add86 = add nsw i32 %21, %20
BinOp Seq
Creating Node
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
i32 0
  %conv108 = trunc i64 %24 to i32
i32 0
  %sub77 = sub nsw i32 %16, %17
i32 0
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
i32 0
Match: 0
5 x 8
Final Match: 0
GEPSeq2
BinOP?
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
BinOp Seq
Creating Node
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
i32 0
  %conv108 = trunc i64 %24 to i32
i32 0
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
i32 0
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
i32 0
Match: 0
4 x 8
Final Match: 0
GEPSeq2
BinOP?
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
i32 0
i32 0
i32 0
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
  %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
i32 0
i32 0
i32 0
  %conv134 = trunc i64 %28 to i32
i32 0
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
i32 0
Match: 0
3 x 8
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %add80 = add nsw i32 %19, %18
i32 0
i32 0
i32 0
i32 0
i32 0
  %conv134 = trunc i64 %28 to i32
i32 0
Match: 0
3 x 8
Final Match: 0
GEPSeq2
BinOP?
  %add80 = add nsw i32 %19, %18
BinOp Seq
Creating Node
  %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
  %conv134 = trunc i64 %28 to i32
i32 0
Match: 0
3 x 8
Final Match: 0
GEPSeq2
BinOP?
  %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
Mismatching
Creating Node
  %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 8
Final Match: 0
GEPSeq2
BinOP?
  %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
Mismatching
Creating Node
  %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
  %arrayidx91 = getelementptr inbounds i32, i32* %dataptr.1, i64 32
  %arrayidx84 = getelementptr inbounds i32, i32* %dataptr.1, i64 16
  %arrayidx79 = getelementptr inbounds i32, i32* %dataptr.1, i64 48
  %arrayidx85 = getelementptr inbounds i32, i32* %dataptr.1, i64 40
  %arrayidx90 = getelementptr inbounds i32, i32* %dataptr.1, i64 24
  %arrayidx78 = getelementptr inbounds i32, i32* %dataptr.1, i64 8
  %arrayidx73 = getelementptr inbounds i32, i32* %dataptr.1, i64 56
Match: 0
8 x 8
Final Match: 0
  %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
  %arrayidx91 = getelementptr inbounds i32, i32* %dataptr.1, i64 32
  %arrayidx84 = getelementptr inbounds i32, i32* %dataptr.1, i64 16
  %arrayidx79 = getelementptr inbounds i32, i32* %dataptr.1, i64 48
  %arrayidx85 = getelementptr inbounds i32, i32* %dataptr.1, i64 40
  %arrayidx90 = getelementptr inbounds i32, i32* %dataptr.1, i64 24
  %arrayidx78 = getelementptr inbounds i32, i32* %dataptr.1, i64 8
  %arrayidx73 = getelementptr inbounds i32, i32* %dataptr.1, i64 56
Ptr:   %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 32
i64 16
i64 48
i64 40
i64 24
i64 8
i64 56
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
i64 0
Mismatching
Invalid:   %arrayidx90 = getelementptr inbounds i32, i32* %dataptr.1, i64 24
Invalid dependence found!
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
8 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
9 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
10 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
12 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
13 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
15 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
16 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
17 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
18 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
19 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
20 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
21 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
22 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
23 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
24 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
25 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
26 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
27 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
28 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
29 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
30 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
31 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
32 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
33 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
34 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
35 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
34->0 
2->1 
23->1 
3->2 
16->2 
4->3 
13->3 
5->4 
10->4 
6->5 
9->5 
7->6 
8->6 
11->10 
12->10 
14->13 
15->13 
17->16 
20->16 
18->17 
19->17 
21->20 
22->20 
24->23 
31->23 
25->24 
30->24 
26->25 
29->25 
27->26 
28->26 
32->31 
33->31 
35->34 
36 [label="add", style="filled" , fillcolor="#f2eb5c", shape=box];
2->36
4->36
37 [label="add", style="filled" , fillcolor="#f2eb5c", shape=box];
4->37
6->37
38 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
17->38
20->38
24->37
25->38
26->37
31->38
39 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->39
40 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->40
41 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->41
42 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->42
43 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->43
44 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->44
45 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
34->45
}


for.body71:                                       ; preds = %for.cond68
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %arrayidx73 = getelementptr inbounds i32, i32* %dataptr.1, i64 56
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %add74 = add nsw i32 %17, %16
  %sub77 = sub nsw i32 %16, %17
  %arrayidx78 = getelementptr inbounds i32, i32* %dataptr.1, i64 8
  %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
  %arrayidx79 = getelementptr inbounds i32, i32* %dataptr.1, i64 48
  %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
  %add80 = add nsw i32 %19, %18
  %sub83 = sub nsw i32 %18, %19
  %arrayidx84 = getelementptr inbounds i32, i32* %dataptr.1, i64 16
  %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
  %arrayidx85 = getelementptr inbounds i32, i32* %dataptr.1, i64 40
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
  %add86 = add nsw i32 %21, %20
  %sub89 = sub nsw i32 %20, %21
  %arrayidx90 = getelementptr inbounds i32, i32* %dataptr.1, i64 24
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
  %arrayidx91 = getelementptr inbounds i32, i32* %dataptr.1, i64 32
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
  %add92 = add nsw i32 %23, %22
  %sub95 = sub nsw i32 %22, %23
  %add96 = add nsw i32 %add92, %add74
  %sub97 = sub nsw i32 %add74, %add92
  %add98 = add nsw i32 %add86, %add80
  %sub99 = sub i32 %add80, %add86
  %add100 = add nsw i32 %add96, %add98
  store i32 %add100, i32* %dataptr.1, align 4, !tbaa !2
  %sub102 = sub nsw i32 %add96, %add98
  store i32 %sub102, i32* %arrayidx91, align 4, !tbaa !2
  %add104 = add nsw i32 %sub99, %sub97
  %conv105 = sext i32 %add104 to i64
  %mul106 = mul nsw i64 %conv105, 181
  %24 = lshr i64 %mul106, 8
  %conv108 = trunc i64 %24 to i32
  %add109 = add nsw i32 %sub97, %conv108
  store i32 %add109, i32* %arrayidx84, align 4, !tbaa !2
  %sub111 = sub nsw i32 %sub97, %conv108
  store i32 %sub111, i32* %arrayidx79, align 4, !tbaa !2
  %add113 = add nsw i32 %sub95, %sub89
  %add114 = add nsw i32 %sub89, %sub83
  %add115 = add nsw i32 %sub83, %sub77
  %sub116 = sub nsw i32 %add113, %add115
  %conv117 = sext i32 %sub116 to i64
  %mul118 = mul nsw i64 %conv117, 98
  %25 = lshr i64 %mul118, 8
  %conv120 = trunc i64 %25 to i32
  %conv121 = sext i32 %add113 to i64
  %mul122 = mul nsw i64 %conv121, 139
  %26 = lshr i64 %mul122, 8
  %conv124 = trunc i64 %26 to i32
  %add125 = add nsw i32 %conv120, %conv124
  %conv126 = sext i32 %add115 to i64
  %mul127 = mul nsw i64 %conv126, 334
  %27 = lshr i64 %mul127, 8
  %conv129 = trunc i64 %27 to i32
  %add130 = add nsw i32 %conv120, %conv129
  %conv131 = sext i32 %add114 to i64
  %mul132 = mul nsw i64 %conv131, 181
  %28 = lshr i64 %mul132, 8
  %conv134 = trunc i64 %28 to i32
  %add135 = add nsw i32 %sub77, %conv134
  %sub136 = sub nsw i32 %sub77, %conv134
  %add137 = add nsw i32 %add125, %sub136
  store i32 %add137, i32* %arrayidx85, align 4, !tbaa !2
  %sub139 = sub nsw i32 %sub136, %add125
  store i32 %sub139, i32* %arrayidx90, align 4, !tbaa !2
  %add141 = add nsw i32 %add130, %add135
  store i32 %add141, i32* %arrayidx78, align 4, !tbaa !2
  %sub143 = sub nsw i32 %add135, %add130
  store i32 %sub143, i32* %arrayidx73, align 4, !tbaa !2
  %incdec.ptr = getelementptr inbounds i32, i32* %dataptr.1, i64 1
  %dec146 = add nsw i32 %ctr.1, -1
  br label %for.cond68, !llvm.loop !8

Trying AGAIN
Trying AGAIN
Creating Node
  store i32 %sub102, i32* %arrayidx91, align 4, !tbaa !2
  store i32 %add109, i32* %arrayidx84, align 4, !tbaa !2
  store i32 %sub111, i32* %arrayidx79, align 4, !tbaa !2
  store i32 %add137, i32* %arrayidx85, align 4, !tbaa !2
  store i32 %sub139, i32* %arrayidx90, align 4, !tbaa !2
  store i32 %add141, i32* %arrayidx78, align 4, !tbaa !2
  store i32 %sub143, i32* %arrayidx73, align 4, !tbaa !2
Match: 1
7 x 7
Final Match: 1
Matching
Creating Node
  %sub102 = sub nsw i32 %add96, %add98
  %add109 = add nsw i32 %sub97, %conv108
  %sub111 = sub nsw i32 %sub97, %conv108
  %add137 = add nsw i32 %add125, %sub136
  %sub139 = sub nsw i32 %sub136, %add125
  %add141 = add nsw i32 %add130, %add135
  %sub143 = sub nsw i32 %add135, %add130
Match: 0
7 x 7
Final Match: 0
GEPSeq2
BinOP?
  %sub102 = sub nsw i32 %add96, %add98
BinOp Seq
Creating Node
  %add96 = add nsw i32 %add92, %add74
  %add109 = add nsw i32 %sub97, %conv108
  %sub97 = sub nsw i32 %add74, %add92
  %add137 = add nsw i32 %add125, %sub136
  %sub136 = sub nsw i32 %sub77, %conv134
  %add141 = add nsw i32 %add130, %add135
  %add135 = add nsw i32 %sub77, %conv134
Match: 0
7 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add96 = add nsw i32 %add92, %add74
BinOp Seq
Creating Node
  %add92 = add nsw i32 %23, %22
  %sub97 = sub nsw i32 %add74, %add92
  %sub97 = sub nsw i32 %add74, %add92
  %add125 = add nsw i32 %conv120, %conv124
  %sub136 = sub nsw i32 %sub77, %conv134
  %add130 = add nsw i32 %conv120, %conv129
  %sub77 = sub nsw i32 %16, %17
Match: 0
6 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add92 = add nsw i32 %23, %22
BinOp Seq
Creating Node
  %add92 = add nsw i32 %23, %22
  %add74 = add nsw i32 %17, %16
  %add74 = add nsw i32 %17, %16
  %add125 = add nsw i32 %conv120, %conv124
  %sub77 = sub nsw i32 %16, %17
  %add130 = add nsw i32 %conv120, %conv129
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
Match: 0
6 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add92 = add nsw i32 %23, %22
BinOp Seq
Creating Node
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %conv120 = trunc i64 %25 to i32
  %sub77 = sub nsw i32 %16, %17
  %conv120 = trunc i64 %25 to i32
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
Match: 0
5 x 7
Final Match: 0
GEPSeq2
BinOP?
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
BinOp Seq
Creating Node
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %conv120 = trunc i64 %25 to i32
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %conv120 = trunc i64 %25 to i32
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
i32 0
i32 0
i32 0
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
i32 0
i32 0
Match: 0
2 x 7
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %conv124 = trunc i64 %26 to i32
i32 0
  %conv129 = trunc i64 %27 to i32
i32 0
Match: 0
5 x 7
Final Match: 0
GEPSeq2
BinOP?
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
  %add92 = add nsw i32 %23, %22
  %add92 = add nsw i32 %23, %22
i32 0
  %conv134 = trunc i64 %28 to i32
i32 0
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
i32 0
BinOp Seq
Creating Node
i32 0
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
i32 0
  %conv134 = trunc i64 %28 to i32
i32 0
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 7
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %add74 = add nsw i32 %17, %16
  %conv108 = trunc i64 %24 to i32
i32 0
  %sub136 = sub nsw i32 %sub77, %conv134
i32 0
  %add135 = add nsw i32 %sub77, %conv134
  %conv134 = trunc i64 %28 to i32
Match: 0
6 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add74 = add nsw i32 %17, %16
BinOp Seq
Creating Node
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %conv108 = trunc i64 %24 to i32
i32 0
  %sub136 = sub nsw i32 %sub77, %conv134
i32 0
  %sub77 = sub nsw i32 %16, %17
  %conv134 = trunc i64 %28 to i32
Match: 0
6 x 7
Final Match: 0
GEPSeq2
BinOP?
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
BinOp Seq
Creating Node
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %conv108 = trunc i64 %24 to i32
i32 0
  %sub77 = sub nsw i32 %16, %17
i32 0
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %conv134 = trunc i64 %28 to i32
Match: 0
6 x 7
Final Match: 0
GEPSeq2
BinOP?
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
BinOp Seq
Creating Node
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %conv108 = trunc i64 %24 to i32
i32 0
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
i32 0
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %conv134 = trunc i64 %28 to i32
Match: 0
5 x 7
Final Match: 0
GEPSeq2
BinOP?
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
Mismatching
Creating Node
i32 0
i32 0
i32 0
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
i32 0
i32 0
i32 0
Match: 0
2 x 7
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
i32 0
i32 0
  %conv134 = trunc i64 %28 to i32
i32 0
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
i32 0
Match: 0
3 x 7
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
  %conv134 = trunc i64 %28 to i32
i32 0
Match: 0
3 x 7
Final Match: 0
GEPSeq2
BinOP?
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
Mismatching
Creating Node
  %add98 = add nsw i32 %add86, %add80
i32 0
  %conv108 = trunc i64 %24 to i32
i32 0
  %add125 = add nsw i32 %conv120, %conv124
i32 0
  %add130 = add nsw i32 %conv120, %conv129
Match: 0
5 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add98 = add nsw i32 %add86, %add80
BinOp Seq
Creating Node
  %add86 = add nsw i32 %21, %20
i32 0
  %conv108 = trunc i64 %24 to i32
i32 0
  %conv120 = trunc i64 %25 to i32
i32 0
  %conv120 = trunc i64 %25 to i32
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add86 = add nsw i32 %21, %20
BinOp Seq
Creating Node
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
i32 0
  %conv108 = trunc i64 %24 to i32
i32 0
  %conv120 = trunc i64 %25 to i32
i32 0
  %conv120 = trunc i64 %25 to i32
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
Mismatching
Creating Node
  %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 7
Final Match: 0
GEPSeq2
BinOP?
  %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
Mismatching
Creating Node
  %add80 = add nsw i32 %19, %18
i32 0
i32 0
i32 0
  %conv124 = trunc i64 %26 to i32
i32 0
  %conv129 = trunc i64 %27 to i32
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
  %add80 = add nsw i32 %19, %18
BinOp Seq
Creating Node
  %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
i32 0
i32 0
i32 0
  %conv124 = trunc i64 %26 to i32
i32 0
  %conv129 = trunc i64 %27 to i32
Match: 0
4 x 7
Final Match: 0
GEPSeq2
BinOP?
  %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
Mismatching
Creating Node
  %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
i32 0
i32 0
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 7
Final Match: 0
GEPSeq2
BinOP?
  %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
Mismatching
Creating Node
  %arrayidx91 = getelementptr inbounds i32, i32* %dataptr.1, i64 32
  %arrayidx84 = getelementptr inbounds i32, i32* %dataptr.1, i64 16
  %arrayidx79 = getelementptr inbounds i32, i32* %dataptr.1, i64 48
  %arrayidx85 = getelementptr inbounds i32, i32* %dataptr.1, i64 40
  %arrayidx90 = getelementptr inbounds i32, i32* %dataptr.1, i64 24
  %arrayidx78 = getelementptr inbounds i32, i32* %dataptr.1, i64 8
  %arrayidx73 = getelementptr inbounds i32, i32* %dataptr.1, i64 56
Match: 1
7 x 7
Final Match: 1
Matching
Creating Node
  %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
  %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
  %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
  %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
  %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
  %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
  %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
Match: 0
1 x 7
Final Match: 0
All the Same
Creating Node
i64 32
i64 16
i64 48
i64 40
i64 24
i64 8
i64 56
Match: 0
7 x 7
Final Match: 0
GEPSeq2
BinOP?
i64 32
Mismatching
Invalid:   %arrayidx90 = getelementptr inbounds i32, i32* %dataptr.1, i64 24
Invalid dependence found!
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
7 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
8 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
9 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
11 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
12 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
13 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
15 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
16 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
17 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
18 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
19 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
20 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
21 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
22 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
23 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
24 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
25 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
26 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
27 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
28 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
26->0 
2->1 
19->1 
3->2 
12->2 
4->3 
9->3 
5->4 
8->4 
6->5 
7->5 
10->9 
11->9 
13->12 
18->12 
14->13 
17->13 
15->14 
16->14 
20->19 
23->19 
21->20 
22->20 
24->23 
25->23 
27->26 
28->26 
29 [label="add", style="filled" , fillcolor="#f2eb5c", shape=box];
2->29
30 [label="add", style="filled" , fillcolor="#f2eb5c", shape=box];
3->30
3->30
31 [label="add", style="filled" , fillcolor="#f2eb5c", shape=box];
3->31
5->31
13->31
14->31
19->29
32 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
20->32
23->32
33 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->33
34 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->34
35 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->35
36 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->36
37 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->37
38 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->38
39 [label="load", style="filled" , fillcolor="#f2eb5c", shape=box];
26->39
}


for.body71:                                       ; preds = %for.cond68
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %arrayidx73 = getelementptr inbounds i32, i32* %dataptr.1, i64 56
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %add74 = add nsw i32 %17, %16
  %sub77 = sub nsw i32 %16, %17
  %arrayidx78 = getelementptr inbounds i32, i32* %dataptr.1, i64 8
  %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
  %arrayidx79 = getelementptr inbounds i32, i32* %dataptr.1, i64 48
  %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
  %add80 = add nsw i32 %19, %18
  %sub83 = sub nsw i32 %18, %19
  %arrayidx84 = getelementptr inbounds i32, i32* %dataptr.1, i64 16
  %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
  %arrayidx85 = getelementptr inbounds i32, i32* %dataptr.1, i64 40
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
  %add86 = add nsw i32 %21, %20
  %sub89 = sub nsw i32 %20, %21
  %arrayidx90 = getelementptr inbounds i32, i32* %dataptr.1, i64 24
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
  %arrayidx91 = getelementptr inbounds i32, i32* %dataptr.1, i64 32
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
  %add92 = add nsw i32 %23, %22
  %sub95 = sub nsw i32 %22, %23
  %add96 = add nsw i32 %add92, %add74
  %sub97 = sub nsw i32 %add74, %add92
  %add98 = add nsw i32 %add86, %add80
  %sub99 = sub i32 %add80, %add86
  %add100 = add nsw i32 %add96, %add98
  store i32 %add100, i32* %dataptr.1, align 4, !tbaa !2
  %sub102 = sub nsw i32 %add96, %add98
  store i32 %sub102, i32* %arrayidx91, align 4, !tbaa !2
  %add104 = add nsw i32 %sub99, %sub97
  %conv105 = sext i32 %add104 to i64
  %mul106 = mul nsw i64 %conv105, 181
  %24 = lshr i64 %mul106, 8
  %conv108 = trunc i64 %24 to i32
  %add109 = add nsw i32 %sub97, %conv108
  store i32 %add109, i32* %arrayidx84, align 4, !tbaa !2
  %sub111 = sub nsw i32 %sub97, %conv108
  store i32 %sub111, i32* %arrayidx79, align 4, !tbaa !2
  %add113 = add nsw i32 %sub95, %sub89
  %add114 = add nsw i32 %sub89, %sub83
  %add115 = add nsw i32 %sub83, %sub77
  %sub116 = sub nsw i32 %add113, %add115
  %conv117 = sext i32 %sub116 to i64
  %mul118 = mul nsw i64 %conv117, 98
  %25 = lshr i64 %mul118, 8
  %conv120 = trunc i64 %25 to i32
  %conv121 = sext i32 %add113 to i64
  %mul122 = mul nsw i64 %conv121, 139
  %26 = lshr i64 %mul122, 8
  %conv124 = trunc i64 %26 to i32
  %add125 = add nsw i32 %conv120, %conv124
  %conv126 = sext i32 %add115 to i64
  %mul127 = mul nsw i64 %conv126, 334
  %27 = lshr i64 %mul127, 8
  %conv129 = trunc i64 %27 to i32
  %add130 = add nsw i32 %conv120, %conv129
  %conv131 = sext i32 %add114 to i64
  %mul132 = mul nsw i64 %conv131, 181
  %28 = lshr i64 %mul132, 8
  %conv134 = trunc i64 %28 to i32
  %add135 = add nsw i32 %sub77, %conv134
  %sub136 = sub nsw i32 %sub77, %conv134
  %add137 = add nsw i32 %add125, %sub136
  store i32 %add137, i32* %arrayidx85, align 4, !tbaa !2
  %sub139 = sub nsw i32 %sub136, %add125
  store i32 %sub139, i32* %arrayidx90, align 4, !tbaa !2
  %add141 = add nsw i32 %add130, %add135
  store i32 %add141, i32* %arrayidx78, align 4, !tbaa !2
  %sub143 = sub nsw i32 %add135, %add130
  store i32 %sub143, i32* %arrayidx73, align 4, !tbaa !2
  %incdec.ptr = getelementptr inbounds i32, i32* %dataptr.1, i64 1
  %dec146 = add nsw i32 %ctr.1, -1
  br label %for.cond68, !llvm.loop !8

Building reduction
  store i32 %add141, i32* %arrayidx78, align 4, !tbaa !2
  %add141 = add nsw i32 %add130, %add135
BOs:
  %add141 = add nsw i32 %add130, %add135
  %add130 = add nsw i32 %conv120, %conv129
  %add135 = add nsw i32 %sub77, %conv134
Operands:
  %conv120 = trunc i64 %25 to i32
  %conv129 = trunc i64 %27 to i32
  %sub77 = sub nsw i32 %16, %17
  %conv134 = trunc i64 %28 to i32
Operands:
  %sub77 = sub nsw i32 %16, %17
  %conv120 = trunc i64 %25 to i32
  %conv129 = trunc i64 %27 to i32
  %conv134 = trunc i64 %28 to i32
ReductionNode
Creating Node
  %sub77 = sub nsw i32 %16, %17
  %conv120 = trunc i64 %25 to i32
  %conv129 = trunc i64 %27 to i32
  %conv134 = trunc i64 %28 to i32
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %sub77 = sub nsw i32 %16, %17
BinOp Seq
Creating Node
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %conv120 = trunc i64 %25 to i32
  %conv129 = trunc i64 %27 to i32
  %conv134 = trunc i64 %28 to i32
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
Mismatching
Creating Node
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
i32 0
i32 0
i32 0
Match: 0
2 x 4
Final Match: 0
GEPSeq2
BinOP?
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
Mismatching
Invalid:   %sub77 = sub nsw i32 %16, %17
Invalid dependence found!
Building reduction
  store i32 %add137, i32* %arrayidx85, align 4, !tbaa !2
  %add137 = add nsw i32 %add125, %sub136
BOs:
  %add137 = add nsw i32 %add125, %sub136
  %add125 = add nsw i32 %conv120, %conv124
Operands:
  %conv120 = trunc i64 %25 to i32
  %conv124 = trunc i64 %26 to i32
  %sub136 = sub nsw i32 %sub77, %conv134
Operands:
  %conv120 = trunc i64 %25 to i32
  %conv124 = trunc i64 %26 to i32
  %sub136 = sub nsw i32 %sub77, %conv134
ReductionNode
Creating Node
  %conv120 = trunc i64 %25 to i32
  %conv124 = trunc i64 %26 to i32
  %sub136 = sub nsw i32 %sub77, %conv134
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %conv120 = trunc i64 %25 to i32
BinOp Seq
Creating Node
  %conv120 = trunc i64 %25 to i32
  %conv124 = trunc i64 %26 to i32
  %sub77 = sub nsw i32 %16, %17
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %conv120 = trunc i64 %25 to i32
BinOp Seq
Creating Node
  %conv120 = trunc i64 %25 to i32
  %conv124 = trunc i64 %26 to i32
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %conv120 = trunc i64 %25 to i32
Mismatching
Creating Node
i32 0
i32 0
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
Match: 0
2 x 3
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
i32 0
i32 0
  %conv134 = trunc i64 %28 to i32
Match: 0
2 x 3
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Invalid:   %sub77 = sub nsw i32 %16, %17
Invalid dependence found!
Building reduction
  store i32 %add100, i32* %dataptr.1, align 4, !tbaa !2
  %add100 = add nsw i32 %add96, %add98
BOs:
  %add100 = add nsw i32 %add96, %add98
  %add96 = add nsw i32 %add92, %add74
  %add92 = add nsw i32 %23, %22
  %add74 = add nsw i32 %17, %16
  %add98 = add nsw i32 %add86, %add80
  %add86 = add nsw i32 %21, %20
  %add80 = add nsw i32 %19, %18
Operands:
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
  %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
  %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
  %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
Operands:
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
  %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
  %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
ReductionNode
Creating Node
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
  %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
  %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
Match: 1
8 x 8
Final Match: 1
Matching
Creating Node
  %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
  %arrayidx73 = getelementptr inbounds i32, i32* %dataptr.1, i64 56
  %arrayidx78 = getelementptr inbounds i32, i32* %dataptr.1, i64 8
  %arrayidx79 = getelementptr inbounds i32, i32* %dataptr.1, i64 48
  %arrayidx84 = getelementptr inbounds i32, i32* %dataptr.1, i64 16
  %arrayidx85 = getelementptr inbounds i32, i32* %dataptr.1, i64 40
  %arrayidx90 = getelementptr inbounds i32, i32* %dataptr.1, i64 24
  %arrayidx91 = getelementptr inbounds i32, i32* %dataptr.1, i64 32
Match: 0
8 x 8
Final Match: 0
  %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
  %arrayidx73 = getelementptr inbounds i32, i32* %dataptr.1, i64 56
  %arrayidx78 = getelementptr inbounds i32, i32* %dataptr.1, i64 8
  %arrayidx79 = getelementptr inbounds i32, i32* %dataptr.1, i64 48
  %arrayidx84 = getelementptr inbounds i32, i32* %dataptr.1, i64 16
  %arrayidx85 = getelementptr inbounds i32, i32* %dataptr.1, i64 40
  %arrayidx90 = getelementptr inbounds i32, i32* %dataptr.1, i64 24
  %arrayidx91 = getelementptr inbounds i32, i32* %dataptr.1, i64 32
Ptr:   %dataptr.1 = phi i32* [ %incdec.ptr, %for.body71 ], [ %data, %for.cond68.preheader ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 56
i64 8
i64 48
i64 16
i64 40
i64 24
i64 32
Match: 0
8 x 8
Final Match: 0
GEPSeq2
BinOP?
i64 0
Mismatching
ScheduleNode: {
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
  %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
  %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
}
ScheduleNode: {
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
  %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
  %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
}
Count: 8
Start:   %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
Processing:   %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
Count: 8
Found:   %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
Non-memory:   %arrayidx73 = getelementptr inbounds i32, i32* %dataptr.1, i64 56
Processing:   %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
Count: 7
Found:   %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
Non-memory:   %add74 = add nsw i32 %17, %16
Non-memory:   %sub77 = sub nsw i32 %16, %17
Non-memory:   %arrayidx78 = getelementptr inbounds i32, i32* %dataptr.1, i64 8
Processing:   %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
Count: 6
Found:   %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
Non-memory:   %arrayidx79 = getelementptr inbounds i32, i32* %dataptr.1, i64 48
Processing:   %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
Count: 5
Found:   %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
Non-memory:   %add80 = add nsw i32 %19, %18
Non-memory:   %sub83 = sub nsw i32 %18, %19
Non-memory:   %arrayidx84 = getelementptr inbounds i32, i32* %dataptr.1, i64 16
Processing:   %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
Count: 4
Found:   %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
Non-memory:   %arrayidx85 = getelementptr inbounds i32, i32* %dataptr.1, i64 40
Processing:   %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
Count: 3
Found:   %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
Non-memory:   %add86 = add nsw i32 %21, %20
Non-memory:   %sub89 = sub nsw i32 %20, %21
Non-memory:   %arrayidx90 = getelementptr inbounds i32, i32* %dataptr.1, i64 24
Processing:   %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
Count: 2
Found:   %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
Non-memory:   %arrayidx91 = getelementptr inbounds i32, i32* %dataptr.1, i64 32
Processing:   %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
Count: 1
Found:   %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
I:   %add92 = add nsw i32 %23, %22
Last:   br label %for.cond68, !llvm.loop !8
Schedulable: 1
Loop Rolling: jpeg_fdct_ifast
Generating tree
Generating REDUCTION
Generating MATCH
Match: 
  %16 = load i32, i32* %dataptr.1, align 4, !tbaa !2
  %17 = load i32, i32* %arrayidx73, align 4, !tbaa !2
  %18 = load i32, i32* %arrayidx78, align 4, !tbaa !2
  %19 = load i32, i32* %arrayidx79, align 4, !tbaa !2
  %20 = load i32, i32* %arrayidx84, align 4, !tbaa !2
  %21 = load i32, i32* %arrayidx85, align 4, !tbaa !2
  %22 = load i32, i32* %arrayidx90, align 4, !tbaa !2
  %23 = load i32, i32* %arrayidx91, align 4, !tbaa !2
Generating GEPSEQ
Generating Mismatch
Mismatched Values:
int: i64 0
int: i64 56
int: i64 8
int: i64 48
int: i64 16
int: i64 40
int: i64 24
int: i64 32
All constants
Created array: @1 = private constant [8 x i64] [i64 0, i64 56, i64 8, i64 48, i64 16, i64 40, i64 24, i64 32]
Gen:   %31 = load i64, i64* %30, align 8
Closing GEPSEQ
Found use: 1:   store i32 %sub143, i32* %arrayidx73, align 4, !tbaa !2
Found use: 2:   store i32 %add141, i32* %arrayidx78, align 4, !tbaa !2
Found use: 3:   store i32 %sub111, i32* %arrayidx79, align 4, !tbaa !2
Found use: 4:   store i32 %add109, i32* %arrayidx84, align 4, !tbaa !2
Found use: 5:   store i32 %add137, i32* %arrayidx85, align 4, !tbaa !2
Found use: 6:   store i32 %sub139, i32* %arrayidx90, align 4, !tbaa !2
Found use: 7:   store i32 %sub102, i32* %arrayidx91, align 4, !tbaa !2
Extracting:   %32 = getelementptr i32, i32* %dataptr.1, i64 %31
Gen:   %33 = getelementptr i32, i32* %dataptr.1, i64 %32
Operands done!
Generated:   %35 = load i32, i32* %33, align 1
Found use: 0:   %sub77 = sub nsw i32 %17, %18
Found use: 1:   %sub77 = sub nsw i32 %17, %18
Found use: 2:   %sub83 = sub nsw i32 %19, %20
Found use: 3:   %sub83 = sub nsw i32 %19, %20
Found use: 4:   %sub89 = sub nsw i32 %21, %22
Found use: 5:   %sub89 = sub nsw i32 %21, %22
Found use: 6:   %sub95 = sub nsw i32 %23, %24
Found use: 7:   %sub95 = sub nsw i32 %23, %24
Extracting:   %35 = load i32, i32* %33, align 1
Gen:   %36 = load i32, i32* %34, align 1
Closing REDUCTION
Found use: 0:   store i32 %add100, i32* %dataptr.1, align 4, !tbaa !2
Found use: 1:   %sub102 = sub nsw i32 %add96, %add98
Found use: 2:   %sub97 = sub nsw i32 %add74, %add92
Found use: 3:   %sub97 = sub nsw i32 %add74, %add92
Found use: 4:   %sub102 = sub nsw i32 %add96, %add98
Found use: 5:   %sub99 = sub i32 %add80, %add86
Found use: 6:   %sub99 = sub i32 %add80, %add86
Extracting:   %39 = add nsw i32 %32, %37
Gen:   %40 = add nsw i32 %33, %38
Graph code generated!
Root:
  %add100 = add nsw i32 %add96, %add98
  %add96 = add nsw i32 %add92, %add74
  %add92 = add nsw i32 %26, %25
  %add74 = add nsw i32 %20, %19
  %add98 = add nsw i32 %add86, %add80
  %add86 = add nsw i32 %24, %23
  %add80 = add nsw i32 %22, %21
Root size: 7
digraph VTree {
0 [label="add red.", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->1 
3->2 
4 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
0->4
5 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
0->5
6 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
0->6
0->6
0->5
7 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
0->7
0->7
8 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->8
1->8
9 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->9
1->9
10 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->10
1->10
11 [label="sub", style="filled" , fillcolor="#f2eb5c", shape=box];
1->11
1->11
12 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->12
13 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->13
14 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->14
15 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->15
16 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->16
17 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->17
18 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
2->18
}

Gains: 30 - 151 = -121; Width: 7; Reduction Unprofitable; jpeg_fdct_ifast
looking for reduction
Done Loop Roller: 0/2
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jquant2.c -o src/jquant2.o   -mllvm -reroll-loops=3
Optimizing: init_error_limit
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %add.ptr, i8** %6, align 8, !tbaa !14
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
looking for reduction
looking for reduction
looking for reduction
  %sub = sub nsw i32 0, %in.0
Attempting Group:
  store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
  store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
Creating Node
  store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
  store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %sub = sub nsw i32 0, %in.0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
BinOp Seq
Creating Node
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
Alt Seq
Creating Node
i32 0
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
  %arrayidx = getelementptr inbounds i32, i32* %5, i64 %indvars.iv68
  %arrayidx4 = getelementptr inbounds i32, i32* %5, i64 %7
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %5 = bitcast i8* %add.ptr to i32*
  %5 = bitcast i8* %add.ptr to i32*
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
  %7 = sub nsw i64 0, %indvars.iv68
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
BinOp Seq
Creating Node
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
i64 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
Alt Seq
Creating Node
i64 0
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 0
Alt Seq
ScheduleNode: {
  store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
}
Count: 1
Start:   %arrayidx = getelementptr inbounds i32, i32* %5, i64 %indvars.iv68
Non-memory:   %arrayidx = getelementptr inbounds i32, i32* %5, i64 %indvars.iv68
Processing:   store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
Count: 1
Found:   store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
ScheduleNode: {
  store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
}
Non-memory:   %sub = sub nsw i32 0, %in.0
Non-memory:   %7 = sub nsw i64 0, %indvars.iv68
Non-memory:   %arrayidx4 = getelementptr inbounds i32, i32* %5, i64 %7
Processing:   store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
Count: 1
Found:   store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
I:   %indvars.iv.next69 = add nuw nsw i64 %indvars.iv68, 1
Last:   br label %for.cond, !llvm.loop !18
Schedulable: 1
Loop Rolling: init_error_limit
Generating tree
Generating MATCH
Match: 
  store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
  store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
Generating BINOP
Generating ALTSEQ
Values:
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
i32 0
Generated Version 4:
  %13 = icmp eq i8 %12, 0
  %14 = select i1 %13, i32 %in.0, i32 0
Generating ALTSEQ
Values:
i32 0
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
Generated Version 4:
  %15 = select i1 %13, i32 0, i32 %in.0
Closing BINOP
Gen:   %16 = sub nsw i32 %14, %15
Generating MATCH
Match: 
  %arrayidx = getelementptr inbounds i32, i32* %5, i64 %indvars.iv68
  %arrayidx4 = getelementptr inbounds i32, i32* %5, i64 %7
Generating IDENTICAL
Generating BINOP
Generating ALTSEQ
Values:
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
i64 0
Generated Version 4:
  %17 = select i1 %13, i64 %indvars.iv68, i64 0
Generating ALTSEQ
Values:
i64 0
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
Generated Version 4:
  %18 = select i1 %13, i64 0, i64 %indvars.iv68
Closing BINOP
Gen:   %19 = sub nsw i64 %17, %18
Operands done!
Generated:   %20 = getelementptr inbounds i32, i32* %5, i64 %19
Gen:   %20 = getelementptr inbounds i32, i32* %5, i64 %19
Operands done!
Generated:   store i32 %16, i32* %20, align 1
Gen:   store i32 %16, i32* %20, align 1
Graph code generated!
Root:
  store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
  store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %in.0, 0", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: 0, %in.0", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %indvars.iv68, 0", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="alt: 0, %indvars.iv68", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
5->4 
6->4 
7->6 
8->6 
}

Gains: 11 - 11 = 0; Width: 2; Unprofitable; init_error_limit
Trying AGAIN
Creating Node
  store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
  store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %sub = sub nsw i32 0, %in.0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
BinOp Seq
Creating Node
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
Alt Seq
Creating Node
i32 0
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
  %arrayidx = getelementptr inbounds i32, i32* %5, i64 %indvars.iv68
  %arrayidx4 = getelementptr inbounds i32, i32* %5, i64 %7
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %5 = bitcast i8* %add.ptr to i32*
  %5 = bitcast i8* %add.ptr to i32*
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
  %7 = sub nsw i64 0, %indvars.iv68
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
BinOp Seq
Creating Node
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
i64 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
Alt Seq
Creating Node
i64 0
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 0
Alt Seq
ScheduleNode: {
  store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
}
Count: 1
Start:   %arrayidx = getelementptr inbounds i32, i32* %5, i64 %indvars.iv68
Non-memory:   %arrayidx = getelementptr inbounds i32, i32* %5, i64 %indvars.iv68
Processing:   store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
Count: 1
Found:   store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
ScheduleNode: {
  store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
}
Non-memory:   %sub = sub nsw i32 0, %in.0
Non-memory:   %7 = sub nsw i64 0, %indvars.iv68
Non-memory:   %arrayidx4 = getelementptr inbounds i32, i32* %5, i64 %7
Processing:   store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
Count: 1
Found:   store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
I:   %indvars.iv.next69 = add nuw nsw i64 %indvars.iv68, 1
Last:   br label %for.cond, !llvm.loop !18
Schedulable: 1
Loop Rolling: init_error_limit
Generating tree
Generating MATCH
Match: 
  store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
  store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
Generating BINOP
Generating ALTSEQ
Values:
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
i32 0
Generated Version 4:
  %13 = icmp eq i8 %12, 0
  %14 = select i1 %13, i32 %in.0, i32 0
Generating ALTSEQ
Values:
i32 0
  %in.0 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
Generated Version 4:
  %15 = select i1 %13, i32 0, i32 %in.0
Closing BINOP
Gen:   %16 = sub nsw i32 %14, %15
Generating MATCH
Match: 
  %arrayidx = getelementptr inbounds i32, i32* %5, i64 %indvars.iv68
  %arrayidx4 = getelementptr inbounds i32, i32* %5, i64 %7
Generating IDENTICAL
Generating BINOP
Generating ALTSEQ
Values:
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
i64 0
Generated Version 4:
  %17 = select i1 %13, i64 %indvars.iv68, i64 0
Generating ALTSEQ
Values:
i64 0
  %indvars.iv68 = phi i64 [ %indvars.iv.next69, %for.body ], [ 0, %entry ]
Generated Version 4:
  %18 = select i1 %13, i64 0, i64 %indvars.iv68
Closing BINOP
Gen:   %19 = sub nsw i64 %17, %18
Operands done!
Generated:   %20 = getelementptr inbounds i32, i32* %5, i64 %19
Gen:   %20 = getelementptr inbounds i32, i32* %5, i64 %19
Operands done!
Generated:   store i32 %16, i32* %20, align 1
Gen:   store i32 %16, i32* %20, align 1
Graph code generated!
Root:
  store i32 %in.0, i32* %arrayidx, align 4, !tbaa !17
  store i32 %sub, i32* %arrayidx4, align 4, !tbaa !17
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %in.0, 0", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: 0, %in.0", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %indvars.iv68, 0", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="alt: 0, %indvars.iv68", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
5->4 
6->4 
7->6 
8->6 
}

Gains: 11 - 11 = 0; Width: 2; Unprofitable; init_error_limit
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
looking for reduction
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
looking for reduction
looking for reduction
  %sub11 = sub nsw i32 0, %out.1
Attempting Group:
  store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
  store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
Creating Node
  store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
  store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
  %sub11 = sub nsw i32 0, %out.1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
BinOp Seq
Creating Node
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
Alt Seq
Creating Node
i32 0
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
  %arrayidx10 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv63
  %arrayidx14 = getelementptr inbounds i32, i32* %5, i64 %8
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %5 = bitcast i8* %add.ptr to i32*
  %5 = bitcast i8* %add.ptr to i32*
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
  %8 = sub nsw i64 0, %indvars.iv63
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
BinOp Seq
Creating Node
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
i64 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
Alt Seq
Creating Node
i64 0
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 0
Alt Seq
ScheduleNode: {
  store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
}
Count: 1
Start:   %arrayidx10 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv63
Non-memory:   %arrayidx10 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv63
Processing:   store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
Count: 1
Found:   store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
ScheduleNode: {
  store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
}
Non-memory:   %sub11 = sub nsw i32 0, %out.1
Non-memory:   %8 = sub nsw i64 0, %indvars.iv63
Non-memory:   %arrayidx14 = getelementptr inbounds i32, i32* %5, i64 %8
Processing:   store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
Count: 1
Found:   store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
I:   %indvars.iv.next64 = add nuw nsw i64 %indvars.iv63, 1
Last:   br label %for.cond6, !llvm.loop !20
Schedulable: 1
Loop Rolling: init_error_limit
Generating tree
Generating MATCH
Match: 
  store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
  store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
Generating BINOP
Generating ALTSEQ
Values:
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
i32 0
Generated Version 4:
  %13 = icmp eq i8 %12, 0
  %14 = select i1 %13, i32 %out.1, i32 0
Generating ALTSEQ
Values:
i32 0
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
Generated Version 4:
  %15 = select i1 %13, i32 0, i32 %out.1
Closing BINOP
Gen:   %16 = sub nsw i32 %14, %15
Generating MATCH
Match: 
  %arrayidx10 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv63
  %arrayidx14 = getelementptr inbounds i32, i32* %5, i64 %8
Generating IDENTICAL
Generating BINOP
Generating ALTSEQ
Values:
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
i64 0
Generated Version 4:
  %17 = select i1 %13, i64 %indvars.iv63, i64 0
Generating ALTSEQ
Values:
i64 0
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
Generated Version 4:
  %18 = select i1 %13, i64 0, i64 %indvars.iv63
Closing BINOP
Gen:   %19 = sub nsw i64 %17, %18
Operands done!
Generated:   %20 = getelementptr inbounds i32, i32* %5, i64 %19
Gen:   %20 = getelementptr inbounds i32, i32* %5, i64 %19
Operands done!
Generated:   store i32 %16, i32* %20, align 1
Gen:   store i32 %16, i32* %20, align 1
Graph code generated!
Root:
  store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
  store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %out.1, 0", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: 0, %out.1", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %indvars.iv63, 0", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="alt: 0, %indvars.iv63", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
5->4 
6->4 
7->6 
8->6 
}

Gains: 11 - 11 = 0; Width: 2; Unprofitable; init_error_limit
Trying AGAIN
Creating Node
  store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
  store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
  %sub11 = sub nsw i32 0, %out.1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
BinOp Seq
Creating Node
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
Alt Seq
Creating Node
i32 0
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
  %arrayidx10 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv63
  %arrayidx14 = getelementptr inbounds i32, i32* %5, i64 %8
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %5 = bitcast i8* %add.ptr to i32*
  %5 = bitcast i8* %add.ptr to i32*
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
  %8 = sub nsw i64 0, %indvars.iv63
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
BinOp Seq
Creating Node
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
i64 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
Alt Seq
Creating Node
i64 0
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 0
Alt Seq
ScheduleNode: {
  store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
}
Count: 1
Start:   %arrayidx10 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv63
Non-memory:   %arrayidx10 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv63
Processing:   store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
Count: 1
Found:   store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
ScheduleNode: {
  store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
}
Non-memory:   %sub11 = sub nsw i32 0, %out.1
Non-memory:   %8 = sub nsw i64 0, %indvars.iv63
Non-memory:   %arrayidx14 = getelementptr inbounds i32, i32* %5, i64 %8
Processing:   store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
Count: 1
Found:   store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
I:   %indvars.iv.next64 = add nuw nsw i64 %indvars.iv63, 1
Last:   br label %for.cond6, !llvm.loop !20
Schedulable: 1
Loop Rolling: init_error_limit
Generating tree
Generating MATCH
Match: 
  store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
  store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
Generating BINOP
Generating ALTSEQ
Values:
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
i32 0
Generated Version 4:
  %13 = icmp eq i8 %12, 0
  %14 = select i1 %13, i32 %out.1, i32 0
Generating ALTSEQ
Values:
i32 0
  %out.1 = phi i32 [ %add, %for.body8 ], [ 16, %for.cond6.preheader ]
Generated Version 4:
  %15 = select i1 %13, i32 0, i32 %out.1
Closing BINOP
Gen:   %16 = sub nsw i32 %14, %15
Generating MATCH
Match: 
  %arrayidx10 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv63
  %arrayidx14 = getelementptr inbounds i32, i32* %5, i64 %8
Generating IDENTICAL
Generating BINOP
Generating ALTSEQ
Values:
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
i64 0
Generated Version 4:
  %17 = select i1 %13, i64 %indvars.iv63, i64 0
Generating ALTSEQ
Values:
i64 0
  %indvars.iv63 = phi i64 [ %indvars.iv.next64, %for.body8 ], [ 16, %for.cond6.preheader ]
Generated Version 4:
  %18 = select i1 %13, i64 0, i64 %indvars.iv63
Closing BINOP
Gen:   %19 = sub nsw i64 %17, %18
Operands done!
Generated:   %20 = getelementptr inbounds i32, i32* %5, i64 %19
Gen:   %20 = getelementptr inbounds i32, i32* %5, i64 %19
Operands done!
Generated:   store i32 %16, i32* %20, align 1
Gen:   store i32 %16, i32* %20, align 1
Graph code generated!
Root:
  store i32 %out.1, i32* %arrayidx10, align 4, !tbaa !17
  store i32 %sub11, i32* %arrayidx14, align 4, !tbaa !17
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %out.1, 0", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: 0, %out.1", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %indvars.iv63, 0", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="alt: 0, %indvars.iv63", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
5->4 
6->4 
7->6 
8->6 
}

Gains: 11 - 11 = 0; Width: 2; Unprofitable; init_error_limit
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
looking for reduction
looking for reduction
looking for reduction
  %sub23 = sub nsw i32 0, %out.1.lcssa
Attempting Group:
  store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
  store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
Creating Node
  store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
  store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
  %sub23 = sub nsw i32 0, %out.1.lcssa
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
BinOp Seq
Creating Node
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
Alt Seq
Creating Node
i32 0
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
  %arrayidx22 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv
  %arrayidx26 = getelementptr inbounds i32, i32* %5, i64 %11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %5 = bitcast i8* %add.ptr to i32*
  %5 = bitcast i8* %add.ptr to i32*
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
  %11 = sub nsw i64 0, %indvars.iv
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
BinOp Seq
Creating Node
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
i64 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
Alt Seq
Creating Node
i64 0
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 0
Alt Seq
ScheduleNode: {
  store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
}
Count: 1
Start:   %arrayidx22 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv
Non-memory:   %arrayidx22 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv
Processing:   store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
Count: 1
Found:   store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
ScheduleNode: {
  store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
}
Non-memory:   %11 = sub nsw i64 0, %indvars.iv
Non-memory:   %arrayidx26 = getelementptr inbounds i32, i32* %5, i64 %11
Processing:   store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
Count: 1
Found:   store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
I:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
Last:   br label %for.cond18, !llvm.loop !21
Schedulable: 1
Loop Rolling: init_error_limit
Generating tree
Generating MATCH
Match: 
  store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
  store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
Generating BINOP
Generating ALTSEQ
Values:
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
i32 0
Generated Version 4:
  %13 = icmp eq i8 %12, 0
  %14 = select i1 %13, i32 %out.1.lcssa, i32 0
Generating ALTSEQ
Values:
i32 0
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
Generated Version 4:
  %15 = select i1 %13, i32 0, i32 %out.1.lcssa
Closing BINOP
Gen:   %16 = sub nsw i32 %14, %15
Generating MATCH
Match: 
  %arrayidx22 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv
  %arrayidx26 = getelementptr inbounds i32, i32* %5, i64 %11
Generating IDENTICAL
Generating BINOP
Generating ALTSEQ
Values:
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
i64 0
Generated Version 4:
  %17 = select i1 %13, i64 %indvars.iv, i64 0
Generating ALTSEQ
Values:
i64 0
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
Generated Version 4:
  %18 = select i1 %13, i64 0, i64 %indvars.iv
Closing BINOP
Gen:   %19 = sub nsw i64 %17, %18
Operands done!
Generated:   %20 = getelementptr inbounds i32, i32* %5, i64 %19
Gen:   %20 = getelementptr inbounds i32, i32* %5, i64 %19
Operands done!
Generated:   store i32 %16, i32* %20, align 1
Gen:   store i32 %16, i32* %20, align 1
Graph code generated!
Root:
  store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
  store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %out.1.lcssa, 0", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: 0, %out.1.lcssa", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %indvars.iv, 0", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="alt: 0, %indvars.iv", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
5->4 
6->4 
7->6 
8->6 
}

Gains: 11 - 11 = 0; Width: 2; Unprofitable; init_error_limit
Trying AGAIN
Creating Node
  store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
  store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
  %sub23 = sub nsw i32 0, %out.1.lcssa
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
BinOp Seq
Creating Node
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
Alt Seq
Creating Node
i32 0
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
  %arrayidx22 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv
  %arrayidx26 = getelementptr inbounds i32, i32* %5, i64 %11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %5 = bitcast i8* %add.ptr to i32*
  %5 = bitcast i8* %add.ptr to i32*
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
  %11 = sub nsw i64 0, %indvars.iv
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
BinOp Seq
Creating Node
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
i64 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
Alt Seq
Creating Node
i64 0
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 0
Alt Seq
ScheduleNode: {
  store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
}
Count: 1
Start:   %arrayidx22 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv
Non-memory:   %arrayidx22 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv
Processing:   store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
Count: 1
Found:   store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
ScheduleNode: {
  store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
}
Non-memory:   %11 = sub nsw i64 0, %indvars.iv
Non-memory:   %arrayidx26 = getelementptr inbounds i32, i32* %5, i64 %11
Processing:   store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
Count: 1
Found:   store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
I:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
Last:   br label %for.cond18, !llvm.loop !21
Schedulable: 1
Loop Rolling: init_error_limit
Generating tree
Generating MATCH
Match: 
  store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
  store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
Generating BINOP
Generating ALTSEQ
Values:
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
i32 0
Generated Version 4:
  %13 = icmp eq i8 %12, 0
  %14 = select i1 %13, i32 %out.1.lcssa, i32 0
Generating ALTSEQ
Values:
i32 0
  %out.1.lcssa = phi i32 [ %out.1, %for.cond6 ]
Generated Version 4:
  %15 = select i1 %13, i32 0, i32 %out.1.lcssa
Closing BINOP
Gen:   %16 = sub nsw i32 %14, %15
Generating MATCH
Match: 
  %arrayidx22 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv
  %arrayidx26 = getelementptr inbounds i32, i32* %5, i64 %11
Generating IDENTICAL
Generating BINOP
Generating ALTSEQ
Values:
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
i64 0
Generated Version 4:
  %17 = select i1 %13, i64 %indvars.iv, i64 0
Generating ALTSEQ
Values:
i64 0
  %indvars.iv = phi i64 [ 48, %for.cond18.preheader ], [ %indvars.iv.next, %for.body20 ]
Generated Version 4:
  %18 = select i1 %13, i64 0, i64 %indvars.iv
Closing BINOP
Gen:   %19 = sub nsw i64 %17, %18
Operands done!
Generated:   %20 = getelementptr inbounds i32, i32* %5, i64 %19
Gen:   %20 = getelementptr inbounds i32, i32* %5, i64 %19
Operands done!
Generated:   store i32 %16, i32* %20, align 1
Gen:   store i32 %16, i32* %20, align 1
Graph code generated!
Root:
  store i32 %out.1.lcssa, i32* %arrayidx22, align 4, !tbaa !17
  store i32 %sub23, i32* %arrayidx26, align 4, !tbaa !17
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %out.1.lcssa, 0", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: 0, %out.1.lcssa", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %indvars.iv, 0", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="alt: 0, %indvars.iv", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
5->4 
6->4 
7->6 
8->6 
}

Gains: 11 - 11 = 0; Width: 2; Unprofitable; init_error_limit
looking for reduction
Done Loop Roller: 0/6
Optimizing: jinit_2pass_quantizer
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, i32)* @start_pass_2_quant, void (%struct.jpeg_decompress_struct*, i32)** %start_pass, align 8, !tbaa !14
Attempting Group:
  store i8* %call, i8** %3, align 8, !tbaa !13
looking for reduction
looking for reduction
Attempting Group:
  store i32 46, i32* %msg_code, align 8, !tbaa !22
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %call7, i8** %12, align 8, !tbaa !25
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %if.end ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %call10, i8** %16, align 8, !tbaa !27
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %17, align 8, !tbaa !30
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 55, i32* %msg_code16, align 8, !tbaa !22
  store i32 8, i32* %arrayidx19, align 4, !tbaa !33
Creating Node
  store i32 55, i32* %msg_code16, align 8, !tbaa !22
  store i32 8, i32* %arrayidx19, align 4, !tbaa !33
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 55
i32 8
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 55
Int Seq
Creating Node
  %msg_code16 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 5
  %arrayidx19 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code16 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 5
  %arrayidx19 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code16 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 55, i32* %msg_code16, align 8, !tbaa !22
}
ScheduleNode: {
  store i32 8, i32* %arrayidx19, align 4, !tbaa !33
}
ScheduleNode: {
  store i32 55, i32* %msg_code16, align 8, !tbaa !22
}
Count: 1
Start:   store i32 55, i32* %msg_code16, align 8, !tbaa !22
Processing:   store i32 55, i32* %msg_code16, align 8, !tbaa !22
Count: 1
Found:   store i32 55, i32* %msg_code16, align 8, !tbaa !22
ScheduleNode: {
  store i32 8, i32* %arrayidx19, align 4, !tbaa !33
}
Non-memory:   %arrayidx19 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 8, i32* %arrayidx19, align 4, !tbaa !33
Count: 1
Found:   store i32 8, i32* %arrayidx19, align 4, !tbaa !33
I:   %21 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err15, align 8, !tbaa !21
Last:   br label %if.end33
Schedulable: 1
Loop Rolling: jinit_2pass_quantizer
Generating tree
Generating MATCH
Match: 
  store i32 55, i32* %msg_code16, align 8, !tbaa !22
  store i32 8, i32* %arrayidx19, align 4, !tbaa !33
Generating INTSEQ
Gen:   %39 = add i32 %38, 55
Generating ALTSEQ
Values:
  %msg_code16 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 5
  %arrayidx19 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %40 = icmp eq i8 %36, 0
  %41 = select i1 %40, i32* %msg_code16, i32* %arrayidx19
Operands done!
Generated:   store i32 %39, i32* %41, align 1
Gen:   store i32 %39, i32* %41, align 1
Graph code generated!
Root:
  store i32 55, i32* %msg_code16, align 8, !tbaa !22
  store i32 8, i32* %arrayidx19, align 4, !tbaa !33
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="55..8, -47", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code16, %arrayidx19", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; jinit_2pass_quantizer
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 56, i32* %msg_code26, align 8, !tbaa !22
  store i32 256, i32* %arrayidx30, align 4, !tbaa !33
Creating Node
  store i32 56, i32* %msg_code26, align 8, !tbaa !22
  store i32 256, i32* %arrayidx30, align 4, !tbaa !33
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 56
i32 256
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 56
Int Seq
Creating Node
  %msg_code26 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %23, i64 0, i32 5
  %arrayidx30 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %23, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code26 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %23, i64 0, i32 5
  %arrayidx30 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %23, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code26 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %23, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 56, i32* %msg_code26, align 8, !tbaa !22
}
ScheduleNode: {
  store i32 256, i32* %arrayidx30, align 4, !tbaa !33
}
ScheduleNode: {
  store i32 56, i32* %msg_code26, align 8, !tbaa !22
}
Count: 1
Start:   store i32 56, i32* %msg_code26, align 8, !tbaa !22
Processing:   store i32 56, i32* %msg_code26, align 8, !tbaa !22
Count: 1
Found:   store i32 56, i32* %msg_code26, align 8, !tbaa !22
ScheduleNode: {
  store i32 256, i32* %arrayidx30, align 4, !tbaa !33
}
Non-memory:   %arrayidx30 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %23, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 256, i32* %arrayidx30, align 4, !tbaa !33
Count: 1
Found:   store i32 256, i32* %arrayidx30, align 4, !tbaa !33
I:   %24 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err25, align 8, !tbaa !21
Last:   br label %if.end33
Schedulable: 1
Loop Rolling: jinit_2pass_quantizer
Generating tree
Generating MATCH
Match: 
  store i32 56, i32* %msg_code26, align 8, !tbaa !22
  store i32 256, i32* %arrayidx30, align 4, !tbaa !33
Generating INTSEQ
Gen:   %39 = add i32 %38, 56
Generating ALTSEQ
Values:
  %msg_code26 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %23, i64 0, i32 5
  %arrayidx30 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %23, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %40 = icmp eq i8 %36, 0
  %41 = select i1 %40, i32* %msg_code26, i32* %arrayidx30
Operands done!
Generated:   store i32 %39, i32* %41, align 1
Gen:   store i32 %39, i32* %41, align 1
Graph code generated!
Root:
  store i32 56, i32* %msg_code26, align 8, !tbaa !22
  store i32 256, i32* %arrayidx30, align 4, !tbaa !33
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="56..256, 200", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code26, %arrayidx30", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; jinit_2pass_quantizer
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8** %call35, i8*** %28, align 8, !tbaa !35
looking for reduction
Attempting Group:
  store i8** null, i8*** %30, align 8, !tbaa !35
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul = mul nuw nsw i64 %conv, 6
looking for reduction
looking for reduction
Attempting Group:
  store i8* %call48, i8** %35, align 8, !tbaa !18
Attempting Group:
  store i32 2, i32* %dither_mode, align 8, !tbaa !37
Attempting Group:
  tail call fastcc void @init_error_limit(%struct.jpeg_decompress_struct* nonnull %cinfo) #4
looking for reduction
Done Loop Roller: 0/2
Optimizing: start_pass_2_quant
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 2, i32* %dither_mode, align 8, !tbaa !13
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, i8**, i8**, i32)* @prescan_quantize, void (%struct.jpeg_decompress_struct*, i8**, i8**, i32)** %color_quantize, align 8, !tbaa !14
  %pass2_no_dither.sink = phi void (%struct.jpeg_decompress_struct*, i8**, i8**, i32)* [ @pass2_fs_dither, %if.end.thread ], [ @pass2_no_dither, %if.end ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, i8**, i8**, i32)* %pass2_no_dither.sink, void (%struct.jpeg_decompress_struct*, i8**, i8**, i32)** %4, align 8
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 55, i32* %msg_code, align 8, !tbaa !19
  store i32 1, i32* %arrayidx, align 4, !tbaa !22
Creating Node
  store i32 55, i32* %msg_code, align 8, !tbaa !19
  store i32 1, i32* %arrayidx, align 4, !tbaa !22
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 55
i32 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 55
Int Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 55, i32* %msg_code, align 8, !tbaa !19
}
ScheduleNode: {
  store i32 1, i32* %arrayidx, align 4, !tbaa !22
}
ScheduleNode: {
  store i32 55, i32* %msg_code, align 8, !tbaa !19
}
Count: 1
Start:   store i32 55, i32* %msg_code, align 8, !tbaa !19
Processing:   store i32 55, i32* %msg_code, align 8, !tbaa !19
Count: 1
Found:   store i32 55, i32* %msg_code, align 8, !tbaa !19
ScheduleNode: {
  store i32 1, i32* %arrayidx, align 4, !tbaa !22
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 1, i32* %arrayidx, align 4, !tbaa !22
Count: 1
Found:   store i32 1, i32* %arrayidx, align 4, !tbaa !22
I:   %7 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !18
Last:   br label %if.end35
Schedulable: 1
Loop Rolling: start_pass_2_quant
Generating tree
Generating MATCH
Match: 
  store i32 55, i32* %msg_code, align 8, !tbaa !19
  store i32 1, i32* %arrayidx, align 4, !tbaa !22
Generating INTSEQ
Gen:   %30 = add i32 %29, 55
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %31 = icmp eq i8 %27, 0
  %32 = select i1 %31, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %30, i32* %32, align 1
Gen:   store i32 %30, i32* %32, align 1
Graph code generated!
Root:
  store i32 55, i32* %msg_code, align 8, !tbaa !19
  store i32 1, i32* %arrayidx, align 4, !tbaa !22
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="55..1, -54", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; start_pass_2_quant
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 56, i32* %msg_code28, align 8, !tbaa !19
  store i32 256, i32* %arrayidx32, align 4, !tbaa !22
Creating Node
  store i32 56, i32* %msg_code28, align 8, !tbaa !19
  store i32 256, i32* %arrayidx32, align 4, !tbaa !22
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 56
i32 256
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 56
Int Seq
Creating Node
  %msg_code28 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 5
  %arrayidx32 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code28 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 5
  %arrayidx32 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code28 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 56, i32* %msg_code28, align 8, !tbaa !19
}
ScheduleNode: {
  store i32 256, i32* %arrayidx32, align 4, !tbaa !22
}
ScheduleNode: {
  store i32 56, i32* %msg_code28, align 8, !tbaa !19
}
Count: 1
Start:   store i32 56, i32* %msg_code28, align 8, !tbaa !19
Processing:   store i32 56, i32* %msg_code28, align 8, !tbaa !19
Count: 1
Found:   store i32 56, i32* %msg_code28, align 8, !tbaa !19
ScheduleNode: {
  store i32 256, i32* %arrayidx32, align 4, !tbaa !22
}
Non-memory:   %arrayidx32 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 256, i32* %arrayidx32, align 4, !tbaa !22
Count: 1
Found:   store i32 256, i32* %arrayidx32, align 4, !tbaa !22
I:   %11 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err27, align 8, !tbaa !18
Last:   br label %if.end35
Schedulable: 1
Loop Rolling: start_pass_2_quant
Generating tree
Generating MATCH
Match: 
  store i32 56, i32* %msg_code28, align 8, !tbaa !19
  store i32 256, i32* %arrayidx32, align 4, !tbaa !22
Generating INTSEQ
Gen:   %30 = add i32 %29, 56
Generating ALTSEQ
Values:
  %msg_code28 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 5
  %arrayidx32 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %31 = icmp eq i8 %27, 0
  %32 = select i1 %31, i32* %msg_code28, i32* %arrayidx32
Operands done!
Generated:   store i32 %30, i32* %32, align 1
Gen:   store i32 %30, i32* %32, align 1
Graph code generated!
Root:
  store i32 56, i32* %msg_code28, align 8, !tbaa !19
  store i32 256, i32* %arrayidx32, align 4, !tbaa !22
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="56..256, 200", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code28, %arrayidx32", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; start_pass_2_quant
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul = mul nuw nsw i64 %conv, 6
looking for reduction
Attempting Group:
  store i8* %call, i8** %21, align 8, !tbaa !25
  %22 = phi i8* [ %call, %if.then41 ], [ %17, %if.then38.if.end43_crit_edge ]
looking for reduction
looking for reduction
  %mul = mul nuw nsw i64 %conv, 6
looking for reduction
Attempting Group:
  tail call void @jzero_far(i8* %22, i64 %mul) #3
looking for reduction
Attempting Group:
  tail call fastcc void @init_error_limit(%struct.jpeg_decompress_struct* nonnull %cinfo) #4
looking for reduction
Attempting Group:
  store i32 0, i32* %on_odd_row, align 8, !tbaa !30
looking for reduction
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.cond.preheader ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call void @jzero_far(i8* %26, i64 4096) #3
looking for reduction
Attempting Group:
  store i32 0, i32* %needs_zeroed51, align 8, !tbaa !16
looking for reduction
Done Loop Roller: 0/2
Optimizing: new_color_map_2_quant
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %needs_zeroed, align 8, !tbaa !10
Done Loop Roller: 0/0
Nothing found in: new_color_map_2_quant
Optimizing: prescan_quantize
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc23 ], [ 0, %entry ]
looking for reduction
  %col.0 = phi i32 [ %3, %for.body ], [ %dec22, %for.body5 ]
  %ptr.0 = phi i8* [ %5, %for.body ], [ %add.ptr, %for.body5 ]
looking for reduction
looking for reduction
Attempting Group:
  store i16 %spec.select, i16* %arrayidx18, align 2, !tbaa !16
looking for reduction
Done Loop Roller: 0/0
Nothing found in: prescan_quantize
Optimizing: update_box
looking for reduction
  %indvars.iv482 = phi i64 [ %11, %for.cond.preheader ], [ %indvars.iv.next483, %for.inc27 ]
looking for reduction
  %indvars.iv480 = phi i64 [ %9, %for.cond10.preheader ], [ %indvars.iv.next481, %for.inc24 ]
looking for reduction
  %c2.0 = phi i32 [ %7, %for.body12 ], [ %inc, %for.inc ]
  %histp.0 = phi i16* [ %arrayidx16, %for.body12 ], [ %incdec.ptr, %for.inc ]
looking for reduction
looking for reduction
  %indvars.iv482.lcssa500 = phi i64 [ %indvars.iv482, %for.body19 ]
looking for reduction
Attempting Group:
  store i32 %15, i32* %c0min3, align 8, !tbaa !13
  %c0min.0 = phi i32 [ %15, %if.then22 ], [ %3, %entry ], [ %3, %have_c0min.loopexit ]
looking for reduction
  %indvars.iv478 = phi i64 [ %18, %for.cond34.preheader ], [ %indvars.iv.next479, %for.inc65 ]
looking for reduction
  %indvars.iv476 = phi i64 [ %16, %for.cond38.preheader ], [ %indvars.iv.next477, %for.inc62 ]
looking for reduction
  %c2.1 = phi i32 [ %7, %for.body41 ], [ %inc60, %for.inc59 ]
  %histp.1 = phi i16* [ %arrayidx47, %for.body41 ], [ %incdec.ptr52, %for.inc59 ]
looking for reduction
looking for reduction
  %indvars.iv478.lcssa499 = phi i64 [ %indvars.iv478, %for.body51 ]
looking for reduction
Attempting Group:
  store i32 %22, i32* %c0max4, align 4, !tbaa !16
  %c0max.0 = phi i32 [ %22, %if.then56 ], [ %4, %have_c0min ], [ %4, %have_c0max.loopexit ]
looking for reduction
  %indvars.iv474 = phi i64 [ %25, %for.cond71.preheader ], [ %indvars.iv.next475, %for.inc102 ]
looking for reduction
  %indvars.iv472 = phi i64 [ %indvars.iv.next473, %for.inc99 ], [ %23, %for.cond75.preheader ]
looking for reduction
  %c2.2 = phi i32 [ %7, %for.body78 ], [ %inc97, %for.inc96 ]
  %histp.2 = phi i16* [ %arrayidx84, %for.body78 ], [ %incdec.ptr89, %for.inc96 ]
looking for reduction
looking for reduction
  %indvars.iv474.lcssa498 = phi i64 [ %indvars.iv474, %for.body88 ]
looking for reduction
Attempting Group:
  store i32 %29, i32* %c1min5, align 8, !tbaa !17
  %c1min.0 = phi i32 [ %29, %if.then93 ], [ %5, %have_c0max ], [ %5, %have_c1min.loopexit ]
looking for reduction
  %indvars.iv470 = phi i64 [ %32, %for.cond109.preheader ], [ %indvars.iv.next471, %for.inc140 ]
looking for reduction
  %indvars.iv468 = phi i64 [ %indvars.iv.next469, %for.inc137 ], [ %30, %for.cond113.preheader ]
looking for reduction
  %c2.3 = phi i32 [ %7, %for.body116 ], [ %inc135, %for.inc134 ]
  %histp.3 = phi i16* [ %arrayidx122, %for.body116 ], [ %incdec.ptr127, %for.inc134 ]
looking for reduction
looking for reduction
  %indvars.iv470.lcssa497 = phi i64 [ %indvars.iv470, %for.body126 ]
looking for reduction
Attempting Group:
  store i32 %36, i32* %c1max6, align 4, !tbaa !18
  %c1max.0 = phi i32 [ %36, %if.then131 ], [ %6, %have_c1min ], [ %6, %have_c1max.loopexit ]
looking for reduction
  %indvars.iv466 = phi i64 [ %39, %for.cond147.preheader ], [ %indvars.iv.next467, %for.inc177 ]
looking for reduction
  %indvars.iv464 = phi i64 [ %indvars.iv.next465, %for.inc174 ], [ %37, %for.cond151.preheader ]
looking for reduction
  %c1.4 = phi i32 [ %c1min.0, %for.body154 ], [ %inc172, %for.inc171 ]
  %histp.4 = phi i16* [ %arrayidx160, %for.body154 ], [ %add.ptr, %for.inc171 ]
looking for reduction
looking for reduction
  %indvars.iv466.lcssa496 = phi i64 [ %indvars.iv466, %for.body164 ]
looking for reduction
Attempting Group:
  store i32 %43, i32* %c2min7, align 8, !tbaa !19
  %c2min.0 = phi i32 [ %43, %if.then168 ], [ %7, %have_c1max ], [ %7, %have_c2min.loopexit ]
looking for reduction
  %indvars.iv462 = phi i64 [ %46, %for.cond184.preheader ], [ %indvars.iv.next463, %for.inc215 ]
looking for reduction
  %indvars.iv460 = phi i64 [ %indvars.iv.next461, %for.inc212 ], [ %44, %for.cond188.preheader ]
looking for reduction
  %c1.5 = phi i32 [ %c1min.0, %for.body191 ], [ %inc209, %for.inc208 ]
  %histp.5 = phi i16* [ %arrayidx197, %for.body191 ], [ %add.ptr210, %for.inc208 ]
looking for reduction
looking for reduction
  %indvars.iv462.lcssa495 = phi i64 [ %indvars.iv462, %for.body201 ]
looking for reduction
Attempting Group:
  store i32 %50, i32* %c2max8, align 4, !tbaa !20
  %.pre-phi488 = phi i64 [ %.pre487, %have_c2min.have_c2max_crit_edge ], [ %45, %if.then205 ], [ %45, %have_c2max.loopexit ]
  %.pre-phi486 = phi i64 [ %.pre485, %have_c2min.have_c2max_crit_edge ], [ %44, %if.then205 ], [ %44, %have_c2max.loopexit ]
  %.pre-phi = phi i64 [ %.pre484, %have_c2min.have_c2max_crit_edge ], [ %idxprom194, %if.then205 ], [ %idxprom194, %have_c2max.loopexit ]
  %idxprom244.pre-phi = phi i64 [ %.pre, %have_c2min.have_c2max_crit_edge ], [ %47, %if.then205 ], [ %47, %have_c2max.loopexit ]
  %c2max.0 = phi i32 [ %8, %have_c2min.have_c2max_crit_edge ], [ %50, %if.then205 ], [ %8, %have_c2max.loopexit ]
looking for reduction
  %add231 = add nuw nsw i64 %add, %mul230
Found
Attempting Group:
  store i64 %add231, i64* %volume, align 8, !tbaa !42
Building reduction
  store i64 %add231, i64* %volume, align 8, !tbaa !42
  %add231 = add nuw nsw i64 %add, %mul230
BOs:
  %add231 = add nuw nsw i64 %add, %mul230
  %add = add nuw nsw i64 %mul229, %mul228
Operands:
  %mul229 = mul nsw i64 %conv223, %conv223
  %mul228 = mul nsw i64 %conv219, %conv219
  %mul230 = mul nsw i64 %conv227, %conv227
Operands:
  %mul228 = mul nsw i64 %conv219, %conv219
  %mul229 = mul nsw i64 %conv223, %conv223
  %mul230 = mul nsw i64 %conv227, %conv227
ReductionNode
Creating Node
  %mul228 = mul nsw i64 %conv219, %conv219
  %mul229 = mul nsw i64 %conv223, %conv223
  %mul230 = mul nsw i64 %conv227, %conv227
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %conv219 = sext i32 %mul to i64
  %conv223 = sext i32 %mul222 to i64
  %conv227 = sext i32 %shl225 to i64
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %mul = shl i32 %sub, 4
  %mul222 = mul i32 %sub220, 12
  %shl225 = shl i32 %sub224, 3
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %mul = shl i32 %sub, 4
New Alternating Pattern:
1:  %mul = shl i32 %sub, 4
1:  %shl225 = shl i32 %sub224, 3
2:  %mul222 = mul i32 %sub220, 12

have_c2max:                                       ; preds = %have_c2max.loopexit, %have_c2min.have_c2max_crit_edge, %if.then205
  %.pre-phi488 = phi i64 [ %.pre487, %have_c2min.have_c2max_crit_edge ], [ %45, %if.then205 ], [ %45, %have_c2max.loopexit ]
  %.pre-phi486 = phi i64 [ %.pre485, %have_c2min.have_c2max_crit_edge ], [ %44, %if.then205 ], [ %44, %have_c2max.loopexit ]
  %.pre-phi = phi i64 [ %.pre484, %have_c2min.have_c2max_crit_edge ], [ %idxprom194, %if.then205 ], [ %idxprom194, %have_c2max.loopexit ]
  %idxprom244.pre-phi = phi i64 [ %.pre, %have_c2min.have_c2max_crit_edge ], [ %47, %if.then205 ], [ %47, %have_c2max.loopexit ]
  %c2max.0 = phi i32 [ %8, %have_c2min.have_c2max_crit_edge ], [ %50, %if.then205 ], [ %8, %have_c2max.loopexit ]
  %sub = sub nsw i32 %c0max.0, %c0min.0
  %mul = shl i32 %sub, 4
  %conv219 = sext i32 %mul to i64
  %sub220 = sub nsw i32 %c1max.0, %c1min.0
  %mul222 = mul i32 %sub220, 12
  %conv223 = sext i32 %mul222 to i64
  %sub224 = sub nsw i32 %c2max.0, %c2min.0
  %shl225 = shl i32 %sub224, 3
  %conv227 = sext i32 %shl225 to i64
  %mul228 = mul nsw i64 %conv219, %conv219
  %mul229 = mul nsw i64 %conv223, %conv223
  %add = add nuw nsw i64 %mul229, %mul228
  %mul230 = mul nsw i64 %conv227, %conv227
  %add231 = add nuw nsw i64 %add, %mul230
  %volume = getelementptr inbounds %struct.box, %struct.box* %boxp, i64 0, i32 6
  store i64 %add231, i64* %volume, align 8, !tbaa !42
  %51 = sext i32 %c1max.0 to i64
  br label %for.cond232

Mismatching
Empty scheduling entries
Loop Rolling: update_box
Generating tree
Generating REDUCTION
Generating MATCH
Match: 
  %mul228 = mul nsw i64 %conv219, %conv219
  %mul229 = mul nsw i64 %conv223, %conv223
  %mul230 = mul nsw i64 %conv227, %conv227
Generating MATCH
Match: 
  %conv219 = sext i32 %mul to i64
  %conv223 = sext i32 %mul222 to i64
  %conv227 = sext i32 %shl225 to i64
Generating Mismatch
Mismatched Values:
inst:   %mul = shl i32 %sub, 4
inst:   %mul222 = mul i32 %sub220, 12
inst:   %shl225 = shl i32 %sub224, 3
Non constants
Array Type: 3:i32
Created array:   %54 = alloca i32, i8 3, align 4
Gen:   %60 = load i32, i32* %59, align 4
Operands done!
Generated:   %61 = sext i32 %60 to i64
Gen:   %61 = sext i32 %60 to i64
Operands done!
Generated:   %62 = mul nsw i64 %61, %61
Gen:   %62 = mul nsw i64 %61, %61
Closing REDUCTION
Found use: 0:   store i64 %add231, i64* %volume, align 8, !tbaa !42
Extracting:   %64 = add nuw nsw i64 %59, %63
Gen:   %64 = add nuw nsw i64 %59, %63
Graph code generated!
Root:
  %add231 = add nuw nsw i64 %add, %mul230
  %add = add nuw nsw i64 %mul229, %mul228
Root size: 2
digraph VTree {
0 [label="add red.", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mul", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->1 
2->1 
3->2 
4 [label="store", style="filled" , fillcolor="#f2eb5c", shape=box];
0->4
}

Gains: 8 - 44 = -36; Width: 2; Reduction Unprofitable; update_box
  %indvars.iv458 = phi i64 [ %indvars.iv.next459, %for.inc263 ], [ %.pre-phi486, %have_c2max ]
  %ccount.0 = phi i64 [ %ccount.1.lcssa, %for.inc263 ], [ 0, %have_c2max ]
looking for reduction
  %indvars.iv = phi i64 [ %.pre-phi, %for.cond236.preheader ], [ %indvars.iv.next, %for.inc260 ]
  %ccount.1 = phi i64 [ %ccount.0, %for.cond236.preheader ], [ %ccount.2.lcssa, %for.inc260 ]
looking for reduction
  %c2.6 = phi i32 [ %c2min.0, %for.body239 ], [ %inc257, %for.body249 ]
  %histp.6 = phi i16* [ %arrayidx245, %for.body239 ], [ %incdec.ptr258, %for.body249 ]
  %ccount.2 = phi i64 [ %ccount.1, %for.body239 ], [ %spec.select, %for.body249 ]
looking for reduction
  %ccount.2.lcssa = phi i64 [ %ccount.2, %for.cond246 ]
  %ccount.1.lcssa = phi i64 [ %ccount.1, %for.cond236 ]
  %ccount.0.lcssa = phi i64 [ %ccount.0, %for.cond232 ]
looking for reduction
looking for reduction
Attempting Group:
  store i64 %ccount.0.lcssa, i64* %colorcount, align 8, !tbaa !46
Done Loop Roller: 0/1
Optimizing: find_biggest_color_pop
  %boxp.0 = phi %struct.box* [ %boxlist, %entry ], [ %incdec.ptr, %for.inc ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %maxc.0 = phi i64 [ 0, %entry ], [ %maxc.1, %for.inc ]
  %which.0 = phi %struct.box* [ null, %entry ], [ %which.1, %for.inc ]
looking for reduction
looking for reduction
  %maxc.1 = phi i64 [ %maxc.0, %for.body ], [ %spec.select, %land.lhs.true ]
  %which.1 = phi %struct.box* [ %which.0, %for.body ], [ %spec.select13, %land.lhs.true ]
  %which.0.lcssa = phi %struct.box* [ %which.0, %for.cond ]
looking for reduction
Done Loop Roller: 0/0
Nothing found in: find_biggest_color_pop
Optimizing: find_biggest_volume
  %boxp.0 = phi %struct.box* [ %boxlist, %entry ], [ %incdec.ptr, %for.body ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %maxv.0 = phi i64 [ 0, %entry ], [ %spec.select, %for.body ]
  %which.0 = phi %struct.box* [ null, %entry ], [ %spec.select11, %for.body ]
looking for reduction
  %which.0.lcssa = phi %struct.box* [ %which.0, %for.cond ]
looking for reduction
Done Loop Roller: 0/0
Nothing found in: find_biggest_volume
Optimizing: median_cut
  %indvars.iv = phi i64 [ %indvars.iv.next, %sw.epilog ], [ 1, %entry ]
looking for reduction
looking for reduction
  %boxp.0.i = phi %struct.box* [ %incdec.ptr.i, %for.inc.i ], [ %boxlist, %for.cond.i.preheader ]
  %i.0.i = phi i32 [ %inc.i, %for.inc.i ], [ 0, %for.cond.i.preheader ]
  %maxc.0.i = phi i64 [ %maxc.1.i, %for.inc.i ], [ 0, %for.cond.i.preheader ]
  %which.0.i = phi %struct.box* [ %which.1.i, %for.inc.i ], [ null, %for.cond.i.preheader ]
looking for reduction
looking for reduction
  %maxc.1.i = phi i64 [ %maxc.0.i, %for.body.i ], [ %spec.select.i, %land.lhs.true.i ]
  %which.1.i = phi %struct.box* [ %which.0.i, %for.body.i ], [ %spec.select13.i, %land.lhs.true.i ]
  %boxp.0.i2 = phi %struct.box* [ %incdec.ptr.i11, %for.body.i12 ], [ %boxlist, %for.cond.i6.preheader ]
  %i.0.i3 = phi i32 [ %inc.i10, %for.body.i12 ], [ 0, %for.cond.i6.preheader ]
  %maxv.0.i = phi i64 [ %spec.select.i9, %for.body.i12 ], [ 0, %for.cond.i6.preheader ]
  %which.0.i4 = phi %struct.box* [ %spec.select11.i, %for.body.i12 ], [ null, %for.cond.i6.preheader ]
looking for reduction
  %which.0.i4.lcssa = phi %struct.box* [ %which.0.i4, %for.cond.i6 ]
  %which.0.i.lcssa = phi %struct.box* [ %which.0.i, %for.cond.i ]
  %b1.0 = phi %struct.box* [ %which.0.i4.lcssa, %if.end.loopexit ], [ %which.0.i.lcssa, %if.end.loopexit19 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %8, i32* %c0max6, align 4, !tbaa !12
  store i32 %9, i32* %c1max7, align 4, !tbaa !13
  store i32 %10, i32* %c2max8, align 4, !tbaa !14
  store i32 %11, i32* %c0min9, align 8, !tbaa !15
  store i32 %12, i32* %c1min10, align 8, !tbaa !16
  store i32 %13, i32* %c2min11, align 8, !tbaa !17
Creating Node
  store i32 %8, i32* %c0max6, align 4, !tbaa !12
  store i32 %9, i32* %c1max7, align 4, !tbaa !13
  store i32 %10, i32* %c2max8, align 4, !tbaa !14
  store i32 %11, i32* %c0min9, align 8, !tbaa !15
  store i32 %12, i32* %c1min10, align 8, !tbaa !16
  store i32 %13, i32* %c2min11, align 8, !tbaa !17
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
  %8 = load i32, i32* %c0max, align 4, !tbaa !12
  %9 = load i32, i32* %c1max, align 4, !tbaa !13
  %10 = load i32, i32* %c2max, align 4, !tbaa !14
  %11 = load i32, i32* %c0min, align 8, !tbaa !15
  %12 = load i32, i32* %c1min, align 8, !tbaa !16
  %13 = load i32, i32* %c2min, align 8, !tbaa !17
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
  %c0max = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 1
  %c1max = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 3
  %c2max = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 5
  %c0min = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 0
  %c1min = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 2
  %c2min = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 4
Match: 0
6 x 6
Final Match: 0
  %c0max = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 1
  %c1max = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 3
  %c2max = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 5
  %c0min = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 0
  %c1min = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 2
  %c2min = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 4
GEPSeq2
%struct.box = type { i32, i32, i32, i32, i32, i32, i64, i64 }
BinOP?
  %c0max = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 1
Mismatching
Creating Node
  %c0max6 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 1
  %c1max7 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 3
  %c2max8 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 5
  %c0min9 = getelementptr inbounds %struct.box, %struct.box* %arrayidx, i64 0, i32 0
  %c1min10 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 2
  %c2min11 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 4
Match: 0
6 x 6
Final Match: 0
  %c0max6 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 1
  %c1max7 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 3
  %c2max8 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 5
  %c0min9 = getelementptr inbounds %struct.box, %struct.box* %arrayidx, i64 0, i32 0
  %c1min10 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 2
  %c2min11 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 4
GEPSeq2
%struct.box = type { i32, i32, i32, i32, i32, i32, i64, i64 }
BinOP?
  %c0max6 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 1
Mismatching
ScheduleNode: {
  %8 = load i32, i32* %c0max, align 4, !tbaa !12
}
ScheduleNode: {
  store i32 %8, i32* %c0max6, align 4, !tbaa !12
}
ScheduleNode: {
  %9 = load i32, i32* %c1max, align 4, !tbaa !13
}
ScheduleNode: {
  store i32 %9, i32* %c1max7, align 4, !tbaa !13
}
ScheduleNode: {
  %10 = load i32, i32* %c2max, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 %10, i32* %c2max8, align 4, !tbaa !14
}
ScheduleNode: {
  %11 = load i32, i32* %c0min, align 8, !tbaa !15
}
ScheduleNode: {
  store i32 %11, i32* %c0min9, align 8, !tbaa !15
}
ScheduleNode: {
  %12 = load i32, i32* %c1min, align 8, !tbaa !16
}
ScheduleNode: {
  store i32 %12, i32* %c1min10, align 8, !tbaa !16
}
ScheduleNode: {
  %13 = load i32, i32* %c2min, align 8, !tbaa !17
}
ScheduleNode: {
  store i32 %13, i32* %c2min11, align 8, !tbaa !17
}
ScheduleNode: {
  %8 = load i32, i32* %c0max, align 4, !tbaa !12
}
Count: 1
Start:   %8 = load i32, i32* %c0max, align 4, !tbaa !12
Processing:   %8 = load i32, i32* %c0max, align 4, !tbaa !12
Count: 1
Found:   %8 = load i32, i32* %c0max, align 4, !tbaa !12
ScheduleNode: {
  store i32 %8, i32* %c0max6, align 4, !tbaa !12
}
Non-memory:   %c0max6 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 1
Processing:   store i32 %8, i32* %c0max6, align 4, !tbaa !12
Count: 1
Found:   store i32 %8, i32* %c0max6, align 4, !tbaa !12
ScheduleNode: {
  %9 = load i32, i32* %c1max, align 4, !tbaa !13
}
Non-memory:   %c1max = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 3
Processing:   %9 = load i32, i32* %c1max, align 4, !tbaa !13
Count: 1
Found:   %9 = load i32, i32* %c1max, align 4, !tbaa !13
ScheduleNode: {
  store i32 %9, i32* %c1max7, align 4, !tbaa !13
}
Non-memory:   %c1max7 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 3
Processing:   store i32 %9, i32* %c1max7, align 4, !tbaa !13
Count: 1
Found:   store i32 %9, i32* %c1max7, align 4, !tbaa !13
ScheduleNode: {
  %10 = load i32, i32* %c2max, align 4, !tbaa !14
}
Non-memory:   %c2max = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 5
Processing:   %10 = load i32, i32* %c2max, align 4, !tbaa !14
Count: 1
Found:   %10 = load i32, i32* %c2max, align 4, !tbaa !14
ScheduleNode: {
  store i32 %10, i32* %c2max8, align 4, !tbaa !14
}
Non-memory:   %c2max8 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 5
Processing:   store i32 %10, i32* %c2max8, align 4, !tbaa !14
Count: 1
Found:   store i32 %10, i32* %c2max8, align 4, !tbaa !14
ScheduleNode: {
  %11 = load i32, i32* %c0min, align 8, !tbaa !15
}
Non-memory:   %c0min = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 0
Processing:   %11 = load i32, i32* %c0min, align 8, !tbaa !15
Count: 1
Found:   %11 = load i32, i32* %c0min, align 8, !tbaa !15
ScheduleNode: {
  store i32 %11, i32* %c0min9, align 8, !tbaa !15
}
Non-memory:   %c0min9 = getelementptr inbounds %struct.box, %struct.box* %arrayidx, i64 0, i32 0
Processing:   store i32 %11, i32* %c0min9, align 8, !tbaa !15
Count: 1
Found:   store i32 %11, i32* %c0min9, align 8, !tbaa !15
ScheduleNode: {
  %12 = load i32, i32* %c1min, align 8, !tbaa !16
}
Non-memory:   %c1min = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 2
Processing:   %12 = load i32, i32* %c1min, align 8, !tbaa !16
Count: 1
Found:   %12 = load i32, i32* %c1min, align 8, !tbaa !16
ScheduleNode: {
  store i32 %12, i32* %c1min10, align 8, !tbaa !16
}
Non-memory:   %c1min10 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 2
Processing:   store i32 %12, i32* %c1min10, align 8, !tbaa !16
Count: 1
Found:   store i32 %12, i32* %c1min10, align 8, !tbaa !16
ScheduleNode: {
  %13 = load i32, i32* %c2min, align 8, !tbaa !17
}
Non-memory:   %c2min = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 4
Processing:   %13 = load i32, i32* %c2min, align 8, !tbaa !17
Count: 1
Found:   %13 = load i32, i32* %c2min, align 8, !tbaa !17
ScheduleNode: {
  store i32 %13, i32* %c2min11, align 8, !tbaa !17
}
Non-memory:   %c2min11 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 4
Processing:   store i32 %13, i32* %c2min11, align 8, !tbaa !17
Count: 1
Found:   store i32 %13, i32* %c2min11, align 8, !tbaa !17
I:   %14 = load i32, i32* %c0max, align 4, !tbaa !12
Last:   switch i32 %n.1, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb36
    i32 2, label %sw.bb44
  ]
Schedulable: 1
Loop Rolling: median_cut
Generating tree
Generating MATCH
Match: 
  store i32 %8, i32* %c0max6, align 4, !tbaa !12
  store i32 %9, i32* %c1max7, align 4, !tbaa !13
  store i32 %10, i32* %c2max8, align 4, !tbaa !14
  store i32 %11, i32* %c0min9, align 8, !tbaa !15
  store i32 %12, i32* %c1min10, align 8, !tbaa !16
  store i32 %13, i32* %c2min11, align 8, !tbaa !17
Generating MATCH
Match: 
  %8 = load i32, i32* %c0max, align 4, !tbaa !12
  %9 = load i32, i32* %c1max, align 4, !tbaa !13
  %10 = load i32, i32* %c2max, align 4, !tbaa !14
  %11 = load i32, i32* %c0min, align 8, !tbaa !15
  %12 = load i32, i32* %c1min, align 8, !tbaa !16
  %13 = load i32, i32* %c2min, align 8, !tbaa !17
Generating Mismatch
Mismatched Values:
inst:   %c0max = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 1
inst:   %c1max = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 3
inst:   %c2max = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 5
inst:   %c0min = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 0
inst:   %c1min = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 2
inst:   %c2min = getelementptr inbounds %struct.box, %struct.box* %b1.0, i64 0, i32 4
Non constants
Array Type: 6:i32*
Created array:   %21 = alloca i32*, i8 6, align 8
Gen:   %30 = load i32*, i32** %29, align 8
Operands done!
Generated:   %31 = load i32, i32* %30, align 1
Gen:   %31 = load i32, i32* %30, align 1
Generating Mismatch
Mismatched Values:
inst:   %c0max6 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 1
inst:   %c1max7 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 3
inst:   %c2max8 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 5
inst:   %c0min9 = getelementptr inbounds %struct.box, %struct.box* %arrayidx, i64 0, i32 0
inst:   %c1min10 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 2
inst:   %c2min11 = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv, i32 4
Non constants
Array Type: 6:i32*
Created array:   %28 = alloca i32*, i8 6, align 8
Gen:   %40 = load i32*, i32** %39, align 8
Operands done!
Generated:   store i32 %38, i32* %40, align 1
Gen:   store i32 %38, i32* %40, align 1
Graph code generated!
Root:
  store i32 %8, i32* %c0max6, align 4, !tbaa !12
  store i32 %9, i32* %c1max7, align 4, !tbaa !13
  store i32 %10, i32* %c2max8, align 4, !tbaa !14
  store i32 %11, i32* %c0min9, align 8, !tbaa !15
  store i32 %12, i32* %c1min10, align 8, !tbaa !16
  store i32 %13, i32* %c2min11, align 8, !tbaa !17
Root size: 6
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
3->0 
2->1 
}

Gains: 24 - 156 = -132; Width: 6; Unprofitable; median_cut
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
looking for reduction
  %div = sdiv i32 %add, 2
looking for reduction
  %add34 = add nsw i32 %div, 1
Attempting Group:
  store i32 %add34, i32* %c0min9, align 8, !tbaa !15
Attempting Group:
  store i32 %div, i32* %c0max, align 4, !tbaa !12
looking for reduction
  %div40 = sdiv i32 %add39, 2
looking for reduction
  %add42 = add nsw i32 %div40, 1
Attempting Group:
  store i32 %add42, i32* %c1min10, align 8, !tbaa !16
Attempting Group:
  store i32 %div40, i32* %c1max, align 4, !tbaa !13
looking for reduction
  %div48 = sdiv i32 %add47, 2
looking for reduction
  %add50 = add nsw i32 %div48, 1
Attempting Group:
  store i32 %add50, i32* %c2min11, align 8, !tbaa !17
Attempting Group:
  store i32 %div48, i32* %c2max, align 4, !tbaa !14
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0) #4
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx) #4
Creating Node
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0) #4
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx) #4
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
%struct.jpeg_decompress_struct* %cinfo
%struct.jpeg_decompress_struct* %cinfo
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %b1.0 = phi %struct.box* [ %which.0.i4.lcssa, %if.end.loopexit ], [ %which.0.i.lcssa, %if.end.loopexit19 ]
  %arrayidx = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv
Match: 0
2 x 2
Final Match: 0
  %b1.0 = phi %struct.box* [ %which.0.i4.lcssa, %if.end.loopexit ], [ %which.0.i.lcssa, %if.end.loopexit19 ]
  %arrayidx = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv
GEPSeq2
BinOP?
  %b1.0 = phi %struct.box* [ %which.0.i4.lcssa, %if.end.loopexit ], [ %which.0.i.lcssa, %if.end.loopexit19 ]
Alt Seq
Creating Node
Function: update_box
Function: update_box
Match: 1
1 x 2
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0) #4
}
ScheduleNode: {
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx) #4
}
ScheduleNode: {
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0) #4
}
Count: 1
Start:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0) #4
Processing:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0) #4
Count: 1
Found:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0) #4
ScheduleNode: {
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx) #4
}
Processing:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx) #4
Count: 1
Found:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx) #4
I:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
Last:   br label %while.cond, !llvm.loop !18
Schedulable: 1
Loop Rolling: median_cut
Generating tree
Generating MATCH
Match: 
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0) #4
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx) #4
Generating IDENTICAL
Generating ALTSEQ
Values:
  %b1.0 = phi %struct.box* [ %which.0.i4.lcssa, %if.end.loopexit ], [ %which.0.i.lcssa, %if.end.loopexit19 ]
  %arrayidx = getelementptr inbounds %struct.box, %struct.box* %boxlist, i64 %indvars.iv
Generated Version 4:
  %22 = icmp eq i8 %21, 0
  %23 = select i1 %22, %struct.box* %b1.0, %struct.box* %arrayidx
Generating IDENTICAL
Operands done!
Generated:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %23) #4
Gen:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %23) #4
Graph code generated!
Root:
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0) #4
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx) #4
Root size: 2
digraph VTree {
0 [label="call: update_box", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %b1.0, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="func: update_box", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->0 
}

Gains: 6 - 6 = 0; Width: 2; Unprofitable; median_cut
  %indvars.iv.lcssa20 = phi i64 [ %indvars.iv, %if.end ]
  %numboxes.addr.0.lcssa = phi i32 [ %20, %while.end.split.loop.exit ], [ %smax, %while.end.loopexit ]
looking for reduction
Done Loop Roller: 0/2
Optimizing: compute_color
  %indvars.iv111 = phi i64 [ %indvars.iv.next112, %for.inc37 ], [ %12, %entry ]
  %total.0 = phi i64 [ %total.1.lcssa, %for.inc37 ], [ 0, %entry ]
  %c0total.0 = phi i64 [ %c0total.1.lcssa, %for.inc37 ], [ 0, %entry ]
  %c1total.0 = phi i64 [ %c1total.1.lcssa, %for.inc37 ], [ 0, %entry ]
  %c2total.0 = phi i64 [ %c2total.1.lcssa, %for.inc37 ], [ 0, %entry ]
looking for reduction
  %indvars.iv109 = phi i64 [ %10, %for.cond9.preheader ], [ %indvars.iv.next110, %for.inc34 ]
  %total.1 = phi i64 [ %total.0, %for.cond9.preheader ], [ %total.2.lcssa, %for.inc34 ]
  %c0total.1 = phi i64 [ %c0total.0, %for.cond9.preheader ], [ %c0total.2.lcssa, %for.inc34 ]
  %c1total.1 = phi i64 [ %c1total.0, %for.cond9.preheader ], [ %c1total.2.lcssa, %for.inc34 ]
  %c2total.1 = phi i64 [ %c2total.0, %for.cond9.preheader ], [ %c2total.2.lcssa, %for.inc34 ]
looking for reduction
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ %idxprom14, %for.body11 ]
  %histp.0 = phi i16* [ %incdec.ptr, %for.inc ], [ %arrayidx15, %for.body11 ]
  %total.2 = phi i64 [ %total.3, %for.inc ], [ %total.1, %for.body11 ]
  %c0total.2 = phi i64 [ %c0total.3, %for.inc ], [ %c0total.1, %for.body11 ]
  %c1total.2 = phi i64 [ %c1total.3, %for.inc ], [ %c1total.1, %for.body11 ]
  %c2total.2 = phi i64 [ %c2total.3, %for.inc ], [ %c2total.1, %for.body11 ]
looking for reduction
looking for reduction
  %total.3 = phi i64 [ %add, %if.then ], [ %total.2, %for.body18 ]
  %c0total.3 = phi i64 [ %add23, %if.then ], [ %c0total.2, %for.body18 ]
  %c1total.3 = phi i64 [ %add28, %if.then ], [ %c1total.2, %for.body18 ]
  %c2total.3 = phi i64 [ %add33, %if.then ], [ %c2total.2, %for.body18 ]
  %total.2.lcssa = phi i64 [ %total.2, %for.cond16 ]
  %c0total.2.lcssa = phi i64 [ %c0total.2, %for.cond16 ]
  %c1total.2.lcssa = phi i64 [ %c1total.2, %for.cond16 ]
  %c2total.2.lcssa = phi i64 [ %c2total.2, %for.cond16 ]
  %total.1.lcssa = phi i64 [ %total.1, %for.cond9 ]
  %c0total.1.lcssa = phi i64 [ %c0total.1, %for.cond9 ]
  %c1total.1.lcssa = phi i64 [ %c1total.1, %for.cond9 ]
  %c2total.1.lcssa = phi i64 [ %c2total.1, %for.cond9 ]
  %total.0.lcssa = phi i64 [ %total.0, %for.cond ]
  %c0total.0.lcssa = phi i64 [ %c0total.0, %for.cond ]
  %c1total.0.lcssa = phi i64 [ %c1total.0, %for.cond ]
  %c2total.0.lcssa = phi i64 [ %c2total.0, %for.cond ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv56, i8* %arrayidx60, align 1, !tbaa !28
Attempting Group:
  store i8 %conv41, i8* %arrayidx44, align 1, !tbaa !28
Attempting Group:
  store i8 %conv48, i8* %arrayidx52, align 1, !tbaa !28
Done Loop Roller: 0/0
Nothing found in: compute_color
Optimizing: select_colors
looking for reduction
looking for reduction
looking for reduction
  %mul = mul nsw i64 %conv, 40
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %c0min, align 8, !tbaa !13
  store i32 31, i32* %4, align 4, !tbaa !15
  store i32 0, i32* %5, align 8, !tbaa !16
  store i32 63, i32* %6, align 4, !tbaa !17
  store i32 0, i32* %7, align 8, !tbaa !18
  store i32 31, i32* %8, align 4, !tbaa !19
Attempting Group:
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* %3) #5
Creating Node
  store i32 0, i32* %c0min, align 8, !tbaa !13
  store i32 31, i32* %4, align 4, !tbaa !15
  store i32 0, i32* %5, align 8, !tbaa !16
  store i32 63, i32* %6, align 4, !tbaa !17
  store i32 0, i32* %7, align 8, !tbaa !18
  store i32 31, i32* %8, align 4, !tbaa !19
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
i32 0
i32 31
i32 0
i32 63
i32 0
i32 31
Match: 0
3 x 6
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %c0min = bitcast i8* %call to i32*
  %4 = bitcast i8* %c0max to i32*
  %5 = bitcast i8* %c1min to i32*
  %6 = bitcast i8* %c1max to i32*
  %7 = bitcast i8* %c2min to i32*
  %8 = bitcast i8* %c2max to i32*
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
  %call = tail call i8* %1(%struct.jpeg_common_struct* %2, i32 1, i64 %mul) #4
  %c0max = getelementptr inbounds i8, i8* %call, i64 4
  %c1min = getelementptr inbounds i8, i8* %call, i64 8
  %c1max = getelementptr inbounds i8, i8* %call, i64 12
  %c2min = getelementptr inbounds i8, i8* %call, i64 16
  %c2max = getelementptr inbounds i8, i8* %call, i64 20
Match: 0
6 x 6
Final Match: 0
  %call = tail call i8* %1(%struct.jpeg_common_struct* %2, i32 1, i64 %mul) #4
  %c0max = getelementptr inbounds i8, i8* %call, i64 4
  %c1min = getelementptr inbounds i8, i8* %call, i64 8
  %c1max = getelementptr inbounds i8, i8* %call, i64 12
  %c2min = getelementptr inbounds i8, i8* %call, i64 16
  %c2max = getelementptr inbounds i8, i8* %call, i64 20
Ptr:   %call = tail call i8* %1(%struct.jpeg_common_struct* %2, i32 1, i64 %mul) #4
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 4
i64 8
i64 12
i64 16
i64 20
Match: 0
6 x 6
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
ScheduleNode: {
  store i32 0, i32* %c0min, align 8, !tbaa !13
}
ScheduleNode: {
  store i32 31, i32* %4, align 4, !tbaa !15
}
ScheduleNode: {
  store i32 0, i32* %5, align 8, !tbaa !16
}
ScheduleNode: {
  store i32 63, i32* %6, align 4, !tbaa !17
}
ScheduleNode: {
  store i32 0, i32* %7, align 8, !tbaa !18
}
ScheduleNode: {
  store i32 31, i32* %8, align 4, !tbaa !19
}
ScheduleNode: {
  store i32 0, i32* %c0min, align 8, !tbaa !13
}
Count: 1
Start:   %c0min = bitcast i8* %call to i32*
Non-memory:   %c0min = bitcast i8* %call to i32*
Processing:   store i32 0, i32* %c0min, align 8, !tbaa !13
Count: 1
Found:   store i32 0, i32* %c0min, align 8, !tbaa !13
ScheduleNode: {
  store i32 31, i32* %4, align 4, !tbaa !15
}
Non-memory:   %c0max = getelementptr inbounds i8, i8* %call, i64 4
Non-memory:   %4 = bitcast i8* %c0max to i32*
Processing:   store i32 31, i32* %4, align 4, !tbaa !15
Count: 1
Found:   store i32 31, i32* %4, align 4, !tbaa !15
ScheduleNode: {
  store i32 0, i32* %5, align 8, !tbaa !16
}
Non-memory:   %c1min = getelementptr inbounds i8, i8* %call, i64 8
Non-memory:   %5 = bitcast i8* %c1min to i32*
Processing:   store i32 0, i32* %5, align 8, !tbaa !16
Count: 1
Found:   store i32 0, i32* %5, align 8, !tbaa !16
ScheduleNode: {
  store i32 63, i32* %6, align 4, !tbaa !17
}
Non-memory:   %c1max = getelementptr inbounds i8, i8* %call, i64 12
Non-memory:   %6 = bitcast i8* %c1max to i32*
Processing:   store i32 63, i32* %6, align 4, !tbaa !17
Count: 1
Found:   store i32 63, i32* %6, align 4, !tbaa !17
ScheduleNode: {
  store i32 0, i32* %7, align 8, !tbaa !18
}
Non-memory:   %c2min = getelementptr inbounds i8, i8* %call, i64 16
Non-memory:   %7 = bitcast i8* %c2min to i32*
Processing:   store i32 0, i32* %7, align 8, !tbaa !18
Count: 1
Found:   store i32 0, i32* %7, align 8, !tbaa !18
ScheduleNode: {
  store i32 31, i32* %8, align 4, !tbaa !19
}
Non-memory:   %c2max = getelementptr inbounds i8, i8* %call, i64 20
Non-memory:   %8 = bitcast i8* %c2max to i32*
Processing:   store i32 31, i32* %8, align 4, !tbaa !19
Count: 1
Found:   store i32 31, i32* %8, align 4, !tbaa !19
I:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* %3) #5
Last:   br label %while.cond.i
Schedulable: 1
Loop Rolling: select_colors
Generating tree
Generating MATCH
Match: 
  store i32 0, i32* %c0min, align 8, !tbaa !13
  store i32 31, i32* %4, align 4, !tbaa !15
  store i32 0, i32* %5, align 8, !tbaa !16
  store i32 63, i32* %6, align 4, !tbaa !17
  store i32 0, i32* %7, align 8, !tbaa !18
  store i32 31, i32* %8, align 4, !tbaa !19
Generating Mismatch
Mismatched Values:
int: i32 0
int: i32 31
int: i32 0
int: i32 63
int: i32 0
int: i32 31
All constants
Created array: @0 = private constant [6 x i32] [i32 0, i32 31, i32 0, i32 63, i32 0, i32 31]
Gen:   %56 = load i32, i32* %55, align 4
Generating MATCH
Match: 
  %c0min = bitcast i8* %call to i32*
  %4 = bitcast i8* %c0max to i32*
  %5 = bitcast i8* %c1min to i32*
  %6 = bitcast i8* %c1max to i32*
  %7 = bitcast i8* %c2min to i32*
  %8 = bitcast i8* %c2max to i32*
Generating GEPSEQ
Generating INTSEQ
Gen:   %59 = add i64 %58, 0
Closing GEPSEQ
Gen:   %60 = getelementptr i8, i8* %call, i64 %59
Operands done!
Generated:   %61 = bitcast i8* %60 to i32*
Gen:   %61 = bitcast i8* %60 to i32*
Operands done!
Generated:   store i32 %56, i32* %61, align 1
Gen:   store i32 %56, i32* %61, align 1
Graph code generated!
Root:
  store i32 0, i32* %c0min, align 8, !tbaa !13
  store i32 31, i32* %4, align 4, !tbaa !15
  store i32 0, i32* %5, align 8, !tbaa !16
  store i32 63, i32* %6, align 4, !tbaa !17
  store i32 0, i32* %7, align 8, !tbaa !18
  store i32 31, i32* %8, align 4, !tbaa !19
Root size: 6
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0..20, 4", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->2 
4->3 
}

Gains: 23 - 17 = 6; Width: 6; Profitable; select_colors

entry:
  %mem = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 1
  %0 = load %struct.jpeg_memory_mgr*, %struct.jpeg_memory_mgr** %mem, align 8, !tbaa !2
  %alloc_small = getelementptr inbounds %struct.jpeg_memory_mgr, %struct.jpeg_memory_mgr* %0, i64 0, i32 0
  %1 = load i8* (%struct.jpeg_common_struct*, i32, i64)*, i8* (%struct.jpeg_common_struct*, i32, i64)** %alloc_small, align 8, !tbaa !10
  %2 = bitcast %struct.jpeg_decompress_struct* %cinfo to %struct.jpeg_common_struct*
  %conv = sext i32 %desired_colors to i64
  %mul = mul nsw i64 %conv, 40
  %call = tail call i8* %1(%struct.jpeg_common_struct* %2, i32 1, i64 %mul) #4
  %3 = bitcast i8* %call to %struct.box*
  %c0min = bitcast i8* %call to i32*
  %c0max = getelementptr inbounds i8, i8* %call, i64 4
  %4 = bitcast i8* %c0max to i32*
  %c1min = getelementptr inbounds i8, i8* %call, i64 8
  %5 = bitcast i8* %c1min to i32*
  %c1max = getelementptr inbounds i8, i8* %call, i64 12
  %6 = bitcast i8* %c1max to i32*
  %c2min = getelementptr inbounds i8, i8* %call, i64 16
  %7 = bitcast i8* %c2min to i32*
  %c2max = getelementptr inbounds i8, i8* %call, i64 20
  %8 = bitcast i8* %c2max to i32*
  br label %rolled.pre


rolled.pre:                                       ; preds = %entry
  br label %rolled.loop


rolled.loop:                                      ; preds = %rolled.pre, %rolled.loop
  %53 = phi i8 [ 0, %rolled.pre ], [ %61, %rolled.loop ]
  %54 = getelementptr [6 x i32], [6 x i32]* @0, i8 0, i8 %53
  %55 = load i32, i32* %54, align 4
  %56 = zext i8 %53 to i64
  %57 = mul i64 %56, 4
  %58 = add i64 %57, 0
  %59 = getelementptr i8, i8* %call, i64 %58
  %60 = bitcast i8* %59 to i32*
  store i32 %55, i32* %60, align 1
  %61 = add i8 %53, 1
  %62 = icmp ne i8 %61, 6
  br i1 %62, label %rolled.loop, label %rolled.exit


rolled.exit:                                      ; preds = %rolled.loop
  store i32 0, i32* %c0min, align 8, !tbaa !22
  store i32 31, i32* %4, align 4, !tbaa !19
  store i32 0, i32* %5, align 8, !tbaa !23
  store i32 63, i32* %6, align 4, !tbaa !20
  store i32 0, i32* %7, align 8, !tbaa !24
  store i32 31, i32* %8, align 4, !tbaa !21
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* %3) #5
  %63 = icmp sgt i32 %desired_colors, 1
  %64 = select i1 %63, i32 %desired_colors, i32 1
  br label %while.cond.i

Done!
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %sw.epilog.i ], [ 1, %rolled.exit ]
looking for reduction
looking for reduction
  %indvars.iv52 = phi i64 [ %indvars.iv.next53, %for.inc.i.i ], [ 0, %for.cond.i.i.preheader ]
  %boxp.0.i.i = phi %struct.box* [ %incdec.ptr.i.i, %for.inc.i.i ], [ %3, %for.cond.i.i.preheader ]
  %maxc.0.i.i = phi i64 [ %maxc.1.i.i, %for.inc.i.i ], [ 0, %for.cond.i.i.preheader ]
  %which.0.i.i = phi %struct.box* [ %which.1.i.i, %for.inc.i.i ], [ null, %for.cond.i.i.preheader ]
looking for reduction
looking for reduction
  %maxc.1.i.i = phi i64 [ %maxc.0.i.i, %for.body.i.i ], [ %spec.select.i.i, %land.lhs.true.i.i ]
  %which.1.i.i = phi %struct.box* [ %which.0.i.i, %for.body.i.i ], [ %spec.select13.i.i, %land.lhs.true.i.i ]
  %indvars.iv54 = phi i64 [ %indvars.iv.next55, %for.body.i12.i ], [ 0, %for.cond.i6.i.preheader ]
  %boxp.0.i2.i = phi %struct.box* [ %incdec.ptr.i11.i, %for.body.i12.i ], [ %3, %for.cond.i6.i.preheader ]
  %maxv.0.i.i = phi i64 [ %spec.select.i9.i, %for.body.i12.i ], [ 0, %for.cond.i6.i.preheader ]
  %which.0.i4.i = phi %struct.box* [ %spec.select11.i.i, %for.body.i12.i ], [ null, %for.cond.i6.i.preheader ]
looking for reduction
  %which.0.i4.i.lcssa = phi %struct.box* [ %which.0.i4.i, %for.cond.i6.i ]
  %which.0.i.i.lcssa = phi %struct.box* [ %which.0.i.i, %for.cond.i.i ]
  %b1.0.i = phi %struct.box* [ %which.0.i4.i.lcssa, %if.end.i.loopexit ], [ %which.0.i.i.lcssa, %if.end.i.loopexit59 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %div.i = sdiv i32 %add.i, 2
looking for reduction
  %add34.i = add nsw i32 %div.i, 1
looking for reduction
  %div40.i = sdiv i32 %add39.i, 2
looking for reduction
  %add42.i = add nsw i32 %div40.i, 1
looking for reduction
  %div48.i = sdiv i32 %add47.i, 2
looking for reduction
  %add50.i = add nsw i32 %div48.i, 1
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %indvars.iv.i.lcssa60 = phi i64 [ %indvars.iv.i, %if.end.i ]
  %numboxes.addr.0.lcssa.i = phi i32 [ %indvars.iv.tr.i.le, %median_cut.exit.split.loop.exit57 ], [ %59, %median_cut.exit.loopexit ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %compute_color.exit ], [ 0, %median_cut.exit ]
looking for reduction
  %indvars.iv111.i = phi i64 [ %indvars.iv.next112.i, %for.inc37.i ], [ %32, %for.body ]
  %total.0.i = phi i64 [ %total.1.i.lcssa, %for.inc37.i ], [ 0, %for.body ]
  %c0total.0.i = phi i64 [ %c0total.1.i.lcssa, %for.inc37.i ], [ 0, %for.body ]
  %c1total.0.i = phi i64 [ %c1total.1.i.lcssa, %for.inc37.i ], [ 0, %for.body ]
  %c2total.0.i = phi i64 [ %c2total.1.i.lcssa, %for.inc37.i ], [ 0, %for.body ]
looking for reduction
  %indvars.iv109.i = phi i64 [ %30, %for.cond9.preheader.i ], [ %indvars.iv.next110.i, %for.inc34.i ]
  %total.1.i = phi i64 [ %total.0.i, %for.cond9.preheader.i ], [ %total.2.i.lcssa, %for.inc34.i ]
  %c0total.1.i = phi i64 [ %c0total.0.i, %for.cond9.preheader.i ], [ %c0total.2.i.lcssa, %for.inc34.i ]
  %c1total.1.i = phi i64 [ %c1total.0.i, %for.cond9.preheader.i ], [ %c1total.2.i.lcssa, %for.inc34.i ]
  %c2total.1.i = phi i64 [ %c2total.0.i, %for.cond9.preheader.i ], [ %c2total.2.i.lcssa, %for.inc34.i ]
looking for reduction
  %indvars.iv.i43 = phi i64 [ %indvars.iv.next.i45, %for.inc.i ], [ %idxprom14.i, %for.body11.i ]
  %histp.0.i = phi i16* [ %incdec.ptr.i, %for.inc.i ], [ %arrayidx15.i, %for.body11.i ]
  %total.2.i = phi i64 [ %total.3.i, %for.inc.i ], [ %total.1.i, %for.body11.i ]
  %c0total.2.i = phi i64 [ %c0total.3.i, %for.inc.i ], [ %c0total.1.i, %for.body11.i ]
  %c1total.2.i = phi i64 [ %c1total.3.i, %for.inc.i ], [ %c1total.1.i, %for.body11.i ]
  %c2total.2.i = phi i64 [ %c2total.3.i, %for.inc.i ], [ %c2total.1.i, %for.body11.i ]
looking for reduction
looking for reduction
  %total.3.i = phi i64 [ %add.i44, %if.then.i ], [ %total.2.i, %for.body18.i ]
  %c0total.3.i = phi i64 [ %add23.i, %if.then.i ], [ %c0total.2.i, %for.body18.i ]
  %c1total.3.i = phi i64 [ %add28.i, %if.then.i ], [ %c1total.2.i, %for.body18.i ]
  %c2total.3.i = phi i64 [ %add33.i, %if.then.i ], [ %c2total.2.i, %for.body18.i ]
  %total.2.i.lcssa = phi i64 [ %total.2.i, %for.cond16.i ]
  %c0total.2.i.lcssa = phi i64 [ %c0total.2.i, %for.cond16.i ]
  %c1total.2.i.lcssa = phi i64 [ %c1total.2.i, %for.cond16.i ]
  %c2total.2.i.lcssa = phi i64 [ %c2total.2.i, %for.cond16.i ]
  %total.1.i.lcssa = phi i64 [ %total.1.i, %for.cond9.i ]
  %c0total.1.i.lcssa = phi i64 [ %c0total.1.i, %for.cond9.i ]
  %c1total.1.i.lcssa = phi i64 [ %c1total.1.i, %for.cond9.i ]
  %c2total.1.i.lcssa = phi i64 [ %c2total.1.i, %for.cond9.i ]
  %total.0.i.lcssa = phi i64 [ %total.0.i, %for.cond.i ]
  %c0total.0.i.lcssa = phi i64 [ %c0total.0.i, %for.cond.i ]
  %c1total.0.i.lcssa = phi i64 [ %c1total.0.i, %for.cond.i ]
  %c2total.0.i.lcssa = phi i64 [ %c2total.0.i, %for.cond.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 1/1
Optimizing: finish_pass1
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul.i = mul nsw i64 %conv.i, 40
Attempting Group:
  store i8** %2, i8*** %colormap, align 8, !tbaa !13
  %indvars.iv.i.i = phi i64 [ %indvars.iv.next.i.i, %sw.epilog.i.i ], [ 1, %rolled.exit.i ]
looking for reduction
looking for reduction
  %indvars.iv52.i = phi i64 [ %indvars.iv.next53.i, %for.inc.i.i.i ], [ 0, %for.cond.i.i.i.preheader ]
  %boxp.0.i.i.i = phi %struct.box* [ %incdec.ptr.i.i.i, %for.inc.i.i.i ], [ %52, %for.cond.i.i.i.preheader ]
  %maxc.0.i.i.i = phi i64 [ %maxc.1.i.i.i, %for.inc.i.i.i ], [ 0, %for.cond.i.i.i.preheader ]
  %which.0.i.i.i = phi %struct.box* [ %which.1.i.i.i, %for.inc.i.i.i ], [ null, %for.cond.i.i.i.preheader ]
looking for reduction
looking for reduction
  %maxc.1.i.i.i = phi i64 [ %maxc.0.i.i.i, %for.body.i.i.i ], [ %spec.select.i.i.i, %land.lhs.true.i.i.i ]
  %which.1.i.i.i = phi %struct.box* [ %which.0.i.i.i, %for.body.i.i.i ], [ %spec.select13.i.i.i, %land.lhs.true.i.i.i ]
  %indvars.iv54.i = phi i64 [ %indvars.iv.next55.i, %for.body.i12.i.i ], [ 0, %for.cond.i6.i.i.preheader ]
  %boxp.0.i2.i.i = phi %struct.box* [ %incdec.ptr.i11.i.i, %for.body.i12.i.i ], [ %52, %for.cond.i6.i.i.preheader ]
  %maxv.0.i.i.i = phi i64 [ %spec.select.i9.i.i, %for.body.i12.i.i ], [ 0, %for.cond.i6.i.i.preheader ]
  %which.0.i4.i.i = phi %struct.box* [ %spec.select11.i.i.i, %for.body.i12.i.i ], [ null, %for.cond.i6.i.i.preheader ]
looking for reduction
  %which.0.i4.i.i.lcssa = phi %struct.box* [ %which.0.i4.i.i, %for.cond.i6.i.i ]
  %which.0.i.i.i.lcssa = phi %struct.box* [ %which.0.i.i.i, %for.cond.i.i.i ]
  %b1.0.i.i = phi %struct.box* [ %which.0.i4.i.i.lcssa, %if.end.i.i.loopexit ], [ %which.0.i.i.i.lcssa, %if.end.i.i.loopexit15 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %11, i32* %c0max6.i.i, align 4, !tbaa !25
  store i32 %12, i32* %c1max7.i.i, align 4, !tbaa !26
  store i32 %13, i32* %c2max8.i.i, align 4, !tbaa !27
  store i32 %14, i32* %c0min9.i.i, align 8, !tbaa !28
  store i32 %15, i32* %c1min10.i.i, align 8, !tbaa !29
  store i32 %16, i32* %c2min11.i.i, align 8, !tbaa !30
Creating Node
  store i32 %11, i32* %c0max6.i.i, align 4, !tbaa !25
  store i32 %12, i32* %c1max7.i.i, align 4, !tbaa !26
  store i32 %13, i32* %c2max8.i.i, align 4, !tbaa !27
  store i32 %14, i32* %c0min9.i.i, align 8, !tbaa !28
  store i32 %15, i32* %c1min10.i.i, align 8, !tbaa !29
  store i32 %16, i32* %c2min11.i.i, align 8, !tbaa !30
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
  %11 = load i32, i32* %c0max.i.i, align 4, !tbaa !25
  %12 = load i32, i32* %c1max.i.i, align 4, !tbaa !26
  %13 = load i32, i32* %c2max.i.i, align 4, !tbaa !27
  %14 = load i32, i32* %c0min.i.i, align 8, !tbaa !28
  %15 = load i32, i32* %c1min.i.i, align 8, !tbaa !29
  %16 = load i32, i32* %c2min.i.i, align 8, !tbaa !30
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
  %c0max.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 1
  %c1max.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 3
  %c2max.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 5
  %c0min.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 0
  %c1min.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 2
  %c2min.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 4
Match: 0
6 x 6
Final Match: 0
  %c0max.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 1
  %c1max.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 3
  %c2max.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 5
  %c0min.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 0
  %c1min.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 2
  %c2min.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 4
GEPSeq2
%struct.box = type { i32, i32, i32, i32, i32, i32, i64, i64 }
BinOP?
  %c0max.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 1
Mismatching
Creating Node
  %c0max6.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 1
  %c1max7.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 3
  %c2max8.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 5
  %c0min9.i.i = getelementptr inbounds %struct.box, %struct.box* %arrayidx.i.i, i64 0, i32 0
  %c1min10.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 2
  %c2min11.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 4
Match: 0
6 x 6
Final Match: 0
  %c0max6.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 1
  %c1max7.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 3
  %c2max8.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 5
  %c0min9.i.i = getelementptr inbounds %struct.box, %struct.box* %arrayidx.i.i, i64 0, i32 0
  %c1min10.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 2
  %c2min11.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 4
GEPSeq2
%struct.box = type { i32, i32, i32, i32, i32, i32, i64, i64 }
BinOP?
  %c0max6.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 1
Mismatching
ScheduleNode: {
  %11 = load i32, i32* %c0max.i.i, align 4, !tbaa !25
}
ScheduleNode: {
  store i32 %11, i32* %c0max6.i.i, align 4, !tbaa !25
}
ScheduleNode: {
  %12 = load i32, i32* %c1max.i.i, align 4, !tbaa !26
}
ScheduleNode: {
  store i32 %12, i32* %c1max7.i.i, align 4, !tbaa !26
}
ScheduleNode: {
  %13 = load i32, i32* %c2max.i.i, align 4, !tbaa !27
}
ScheduleNode: {
  store i32 %13, i32* %c2max8.i.i, align 4, !tbaa !27
}
ScheduleNode: {
  %14 = load i32, i32* %c0min.i.i, align 8, !tbaa !28
}
ScheduleNode: {
  store i32 %14, i32* %c0min9.i.i, align 8, !tbaa !28
}
ScheduleNode: {
  %15 = load i32, i32* %c1min.i.i, align 8, !tbaa !29
}
ScheduleNode: {
  store i32 %15, i32* %c1min10.i.i, align 8, !tbaa !29
}
ScheduleNode: {
  %16 = load i32, i32* %c2min.i.i, align 8, !tbaa !30
}
ScheduleNode: {
  store i32 %16, i32* %c2min11.i.i, align 8, !tbaa !30
}
ScheduleNode: {
  %11 = load i32, i32* %c0max.i.i, align 4, !tbaa !25
}
Count: 1
Start:   %11 = load i32, i32* %c0max.i.i, align 4, !tbaa !25
Processing:   %11 = load i32, i32* %c0max.i.i, align 4, !tbaa !25
Count: 1
Found:   %11 = load i32, i32* %c0max.i.i, align 4, !tbaa !25
ScheduleNode: {
  store i32 %11, i32* %c0max6.i.i, align 4, !tbaa !25
}
Non-memory:   %c0max6.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 1
Processing:   store i32 %11, i32* %c0max6.i.i, align 4, !tbaa !25
Count: 1
Found:   store i32 %11, i32* %c0max6.i.i, align 4, !tbaa !25
ScheduleNode: {
  %12 = load i32, i32* %c1max.i.i, align 4, !tbaa !26
}
Non-memory:   %c1max.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 3
Processing:   %12 = load i32, i32* %c1max.i.i, align 4, !tbaa !26
Count: 1
Found:   %12 = load i32, i32* %c1max.i.i, align 4, !tbaa !26
ScheduleNode: {
  store i32 %12, i32* %c1max7.i.i, align 4, !tbaa !26
}
Non-memory:   %c1max7.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 3
Processing:   store i32 %12, i32* %c1max7.i.i, align 4, !tbaa !26
Count: 1
Found:   store i32 %12, i32* %c1max7.i.i, align 4, !tbaa !26
ScheduleNode: {
  %13 = load i32, i32* %c2max.i.i, align 4, !tbaa !27
}
Non-memory:   %c2max.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 5
Processing:   %13 = load i32, i32* %c2max.i.i, align 4, !tbaa !27
Count: 1
Found:   %13 = load i32, i32* %c2max.i.i, align 4, !tbaa !27
ScheduleNode: {
  store i32 %13, i32* %c2max8.i.i, align 4, !tbaa !27
}
Non-memory:   %c2max8.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 5
Processing:   store i32 %13, i32* %c2max8.i.i, align 4, !tbaa !27
Count: 1
Found:   store i32 %13, i32* %c2max8.i.i, align 4, !tbaa !27
ScheduleNode: {
  %14 = load i32, i32* %c0min.i.i, align 8, !tbaa !28
}
Non-memory:   %c0min.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 0
Processing:   %14 = load i32, i32* %c0min.i.i, align 8, !tbaa !28
Count: 1
Found:   %14 = load i32, i32* %c0min.i.i, align 8, !tbaa !28
ScheduleNode: {
  store i32 %14, i32* %c0min9.i.i, align 8, !tbaa !28
}
Non-memory:   %c0min9.i.i = getelementptr inbounds %struct.box, %struct.box* %arrayidx.i.i, i64 0, i32 0
Processing:   store i32 %14, i32* %c0min9.i.i, align 8, !tbaa !28
Count: 1
Found:   store i32 %14, i32* %c0min9.i.i, align 8, !tbaa !28
ScheduleNode: {
  %15 = load i32, i32* %c1min.i.i, align 8, !tbaa !29
}
Non-memory:   %c1min.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 2
Processing:   %15 = load i32, i32* %c1min.i.i, align 8, !tbaa !29
Count: 1
Found:   %15 = load i32, i32* %c1min.i.i, align 8, !tbaa !29
ScheduleNode: {
  store i32 %15, i32* %c1min10.i.i, align 8, !tbaa !29
}
Non-memory:   %c1min10.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 2
Processing:   store i32 %15, i32* %c1min10.i.i, align 8, !tbaa !29
Count: 1
Found:   store i32 %15, i32* %c1min10.i.i, align 8, !tbaa !29
ScheduleNode: {
  %16 = load i32, i32* %c2min.i.i, align 8, !tbaa !30
}
Non-memory:   %c2min.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 4
Processing:   %16 = load i32, i32* %c2min.i.i, align 8, !tbaa !30
Count: 1
Found:   %16 = load i32, i32* %c2min.i.i, align 8, !tbaa !30
ScheduleNode: {
  store i32 %16, i32* %c2min11.i.i, align 8, !tbaa !30
}
Non-memory:   %c2min11.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 4
Processing:   store i32 %16, i32* %c2min11.i.i, align 8, !tbaa !30
Count: 1
Found:   store i32 %16, i32* %c2min11.i.i, align 8, !tbaa !30
I:   %17 = load i32, i32* %c0max.i.i, align 4, !tbaa !25
Last:   switch i32 %n.1.i.i, label %sw.epilog.i.i [
    i32 0, label %sw.bb.i.i
    i32 1, label %sw.bb36.i.i
    i32 2, label %sw.bb44.i.i
  ]
Schedulable: 1
Loop Rolling: finish_pass1
Generating tree
Generating MATCH
Match: 
  store i32 %11, i32* %c0max6.i.i, align 4, !tbaa !25
  store i32 %12, i32* %c1max7.i.i, align 4, !tbaa !26
  store i32 %13, i32* %c2max8.i.i, align 4, !tbaa !27
  store i32 %14, i32* %c0min9.i.i, align 8, !tbaa !28
  store i32 %15, i32* %c1min10.i.i, align 8, !tbaa !29
  store i32 %16, i32* %c2min11.i.i, align 8, !tbaa !30
Generating MATCH
Match: 
  %11 = load i32, i32* %c0max.i.i, align 4, !tbaa !25
  %12 = load i32, i32* %c1max.i.i, align 4, !tbaa !26
  %13 = load i32, i32* %c2max.i.i, align 4, !tbaa !27
  %14 = load i32, i32* %c0min.i.i, align 8, !tbaa !28
  %15 = load i32, i32* %c1min.i.i, align 8, !tbaa !29
  %16 = load i32, i32* %c2min.i.i, align 8, !tbaa !30
Generating Mismatch
Mismatched Values:
inst:   %c0max.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 1
inst:   %c1max.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 3
inst:   %c2max.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 5
inst:   %c0min.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 0
inst:   %c1min.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 2
inst:   %c2min.i.i = getelementptr inbounds %struct.box, %struct.box* %b1.0.i.i, i64 0, i32 4
Non constants
Array Type: 6:i32*
Created array:   %58 = alloca i32*, i8 6, align 8
Gen:   %67 = load i32*, i32** %66, align 8
Operands done!
Generated:   %68 = load i32, i32* %67, align 1
Gen:   %68 = load i32, i32* %67, align 1
Generating Mismatch
Mismatched Values:
inst:   %c0max6.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 1
inst:   %c1max7.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 3
inst:   %c2max8.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 5
inst:   %c0min9.i.i = getelementptr inbounds %struct.box, %struct.box* %arrayidx.i.i, i64 0, i32 0
inst:   %c1min10.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 2
inst:   %c2min11.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i, i32 4
Non constants
Array Type: 6:i32*
Created array:   %65 = alloca i32*, i8 6, align 8
Gen:   %77 = load i32*, i32** %76, align 8
Operands done!
Generated:   store i32 %75, i32* %77, align 1
Gen:   store i32 %75, i32* %77, align 1
Graph code generated!
Root:
  store i32 %11, i32* %c0max6.i.i, align 4, !tbaa !25
  store i32 %12, i32* %c1max7.i.i, align 4, !tbaa !26
  store i32 %13, i32* %c2max8.i.i, align 4, !tbaa !27
  store i32 %14, i32* %c0min9.i.i, align 8, !tbaa !28
  store i32 %15, i32* %c1min10.i.i, align 8, !tbaa !29
  store i32 %16, i32* %c2min11.i.i, align 8, !tbaa !30
Root size: 6
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
3->0 
2->1 
}

Gains: 24 - 156 = -132; Width: 6; Unprofitable; finish_pass1
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
looking for reduction
  %div.i.i = sdiv i32 %add.i.i, 2
looking for reduction
  %add34.i.i = add nsw i32 %div.i.i, 1
Attempting Group:
  store i32 %add34.i.i, i32* %c0min9.i.i, align 8, !tbaa !28
Attempting Group:
  store i32 %div.i.i, i32* %c0max.i.i, align 4, !tbaa !25
looking for reduction
  %div40.i.i = sdiv i32 %add39.i.i, 2
looking for reduction
  %add42.i.i = add nsw i32 %div40.i.i, 1
Attempting Group:
  store i32 %add42.i.i, i32* %c1min10.i.i, align 8, !tbaa !29
Attempting Group:
  store i32 %div40.i.i, i32* %c1max.i.i, align 4, !tbaa !26
looking for reduction
  %div48.i.i = sdiv i32 %add47.i.i, 2
looking for reduction
  %add50.i.i = add nsw i32 %div48.i.i, 1
Attempting Group:
  store i32 %add50.i.i, i32* %c2min11.i.i, align 8, !tbaa !30
Attempting Group:
  store i32 %div48.i.i, i32* %c2max.i.i, align 4, !tbaa !27
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0.i.i) #4
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx.i.i) #4
Creating Node
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0.i.i) #4
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx.i.i) #4
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
%struct.jpeg_decompress_struct* %cinfo
%struct.jpeg_decompress_struct* %cinfo
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %b1.0.i.i = phi %struct.box* [ %which.0.i4.i.i.lcssa, %if.end.i.i.loopexit ], [ %which.0.i.i.i.lcssa, %if.end.i.i.loopexit15 ]
  %arrayidx.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i
Match: 0
2 x 2
Final Match: 0
  %b1.0.i.i = phi %struct.box* [ %which.0.i4.i.i.lcssa, %if.end.i.i.loopexit ], [ %which.0.i.i.i.lcssa, %if.end.i.i.loopexit15 ]
  %arrayidx.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i
GEPSeq2
BinOP?
  %b1.0.i.i = phi %struct.box* [ %which.0.i4.i.i.lcssa, %if.end.i.i.loopexit ], [ %which.0.i.i.i.lcssa, %if.end.i.i.loopexit15 ]
Alt Seq
Creating Node
Function: update_box
Function: update_box
Match: 1
1 x 2
Final Match: 1
All the Same
ScheduleNode: {
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0.i.i) #4
}
ScheduleNode: {
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx.i.i) #4
}
ScheduleNode: {
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0.i.i) #4
}
Count: 1
Start:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0.i.i) #4
Processing:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0.i.i) #4
Count: 1
Found:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0.i.i) #4
ScheduleNode: {
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx.i.i) #4
}
Processing:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx.i.i) #4
Count: 1
Found:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx.i.i) #4
I:   %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
Last:   br label %while.cond.i.i, !llvm.loop !31
Schedulable: 1
Loop Rolling: finish_pass1
Generating tree
Generating MATCH
Match: 
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0.i.i) #4
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx.i.i) #4
Generating IDENTICAL
Generating ALTSEQ
Values:
  %b1.0.i.i = phi %struct.box* [ %which.0.i4.i.i.lcssa, %if.end.i.i.loopexit ], [ %which.0.i.i.i.lcssa, %if.end.i.i.loopexit15 ]
  %arrayidx.i.i = getelementptr inbounds %struct.box, %struct.box* %52, i64 %indvars.iv.i.i
Generated Version 4:
  %59 = icmp eq i8 %58, 0
  %60 = select i1 %59, %struct.box* %b1.0.i.i, %struct.box* %arrayidx.i.i
Generating IDENTICAL
Operands done!
Generated:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %60) #4
Gen:   tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %60) #4
Graph code generated!
Root:
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %b1.0.i.i) #4
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %arrayidx.i.i) #4
Root size: 2
digraph VTree {
0 [label="call: update_box", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %b1.0.i.i, %arrayidx.i.i", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="func: update_box", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->0 
}

Gains: 6 - 6 = 0; Width: 2; Unprofitable; finish_pass1
  %indvars.iv.i.i.lcssa16 = phi i64 [ %indvars.iv.i.i, %if.end.i.i ]
  %numboxes.addr.0.lcssa.i.i = phi i32 [ %indvars.iv.tr.i.i.le, %median_cut.exit.i.split.loop.exit13 ], [ %54, %median_cut.exit.i.loopexit ]
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %compute_color.exit.i ], [ 0, %median_cut.exit.i ]
looking for reduction
  %indvars.iv111.i.i = phi i64 [ %indvars.iv.next112.i.i, %for.inc37.i.i ], [ %34, %for.body.i ]
  %total.0.i.i = phi i64 [ %total.1.i.i.lcssa, %for.inc37.i.i ], [ 0, %for.body.i ]
  %c0total.0.i.i = phi i64 [ %c0total.1.i.i.lcssa, %for.inc37.i.i ], [ 0, %for.body.i ]
  %c1total.0.i.i = phi i64 [ %c1total.1.i.i.lcssa, %for.inc37.i.i ], [ 0, %for.body.i ]
  %c2total.0.i.i = phi i64 [ %c2total.1.i.i.lcssa, %for.inc37.i.i ], [ 0, %for.body.i ]
looking for reduction
  %indvars.iv109.i.i = phi i64 [ %32, %for.cond9.preheader.i.i ], [ %indvars.iv.next110.i.i, %for.inc34.i.i ]
  %total.1.i.i = phi i64 [ %total.0.i.i, %for.cond9.preheader.i.i ], [ %total.2.i.i.lcssa, %for.inc34.i.i ]
  %c0total.1.i.i = phi i64 [ %c0total.0.i.i, %for.cond9.preheader.i.i ], [ %c0total.2.i.i.lcssa, %for.inc34.i.i ]
  %c1total.1.i.i = phi i64 [ %c1total.0.i.i, %for.cond9.preheader.i.i ], [ %c1total.2.i.i.lcssa, %for.inc34.i.i ]
  %c2total.1.i.i = phi i64 [ %c2total.0.i.i, %for.cond9.preheader.i.i ], [ %c2total.2.i.i.lcssa, %for.inc34.i.i ]
looking for reduction
  %indvars.iv.i43.i = phi i64 [ %indvars.iv.next.i45.i, %for.inc.i.i ], [ %idxprom14.i.i, %for.body11.i.i ]
  %histp.0.i.i = phi i16* [ %incdec.ptr.i.i, %for.inc.i.i ], [ %arrayidx15.i.i, %for.body11.i.i ]
  %total.2.i.i = phi i64 [ %total.3.i.i, %for.inc.i.i ], [ %total.1.i.i, %for.body11.i.i ]
  %c0total.2.i.i = phi i64 [ %c0total.3.i.i, %for.inc.i.i ], [ %c0total.1.i.i, %for.body11.i.i ]
  %c1total.2.i.i = phi i64 [ %c1total.3.i.i, %for.inc.i.i ], [ %c1total.1.i.i, %for.body11.i.i ]
  %c2total.2.i.i = phi i64 [ %c2total.3.i.i, %for.inc.i.i ], [ %c2total.1.i.i, %for.body11.i.i ]
looking for reduction
looking for reduction
  %total.3.i.i = phi i64 [ %add.i44.i, %if.then.i.i ], [ %total.2.i.i, %for.body18.i.i ]
  %c0total.3.i.i = phi i64 [ %add23.i.i, %if.then.i.i ], [ %c0total.2.i.i, %for.body18.i.i ]
  %c1total.3.i.i = phi i64 [ %add28.i.i, %if.then.i.i ], [ %c1total.2.i.i, %for.body18.i.i ]
  %c2total.3.i.i = phi i64 [ %add33.i.i, %if.then.i.i ], [ %c2total.2.i.i, %for.body18.i.i ]
  %total.2.i.i.lcssa = phi i64 [ %total.2.i.i, %for.cond16.i.i ]
  %c0total.2.i.i.lcssa = phi i64 [ %c0total.2.i.i, %for.cond16.i.i ]
  %c1total.2.i.i.lcssa = phi i64 [ %c1total.2.i.i, %for.cond16.i.i ]
  %c2total.2.i.i.lcssa = phi i64 [ %c2total.2.i.i, %for.cond16.i.i ]
  %total.1.i.i.lcssa = phi i64 [ %total.1.i.i, %for.cond9.i.i ]
  %c0total.1.i.i.lcssa = phi i64 [ %c0total.1.i.i, %for.cond9.i.i ]
  %c1total.1.i.i.lcssa = phi i64 [ %c1total.1.i.i, %for.cond9.i.i ]
  %c2total.1.i.i.lcssa = phi i64 [ %c2total.1.i.i, %for.cond9.i.i ]
  %total.0.i.i.lcssa = phi i64 [ %total.0.i.i, %for.cond.i.i ]
  %c0total.0.i.i.lcssa = phi i64 [ %c0total.0.i.i, %for.cond.i.i ]
  %c1total.0.i.i.lcssa = phi i64 [ %c1total.0.i.i, %for.cond.i.i ]
  %c2total.0.i.i.lcssa = phi i64 [ %c2total.0.i.i, %for.cond.i.i ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv56.i.i, i8* %arrayidx60.i.i, align 1, !tbaa !38
Attempting Group:
  store i8 %conv41.i.i, i8* %arrayidx44.i.i, align 1, !tbaa !38
Attempting Group:
  store i8 %conv48.i.i, i8* %arrayidx52.i.i, align 1, !tbaa !38
  %indvars.iv = phi i64 [ %indvars.iv.next, %rolled.loop.i ], [ 0, %entry ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
looking for reduction
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
looking for reduction
looking for reduction
Attempting Group:
  store i32 %48, i32* %51, align 1
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @update_box(%struct.jpeg_decompress_struct* %cinfo, %struct.box* nonnull %52) #4
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %needs_zeroed, align 8, !tbaa !45
Attempting Group:
  store i32 95, i32* %msg_code.i, align 8, !tbaa !42
  store i32 %numboxes.addr.0.lcssa.i.i, i32* %arrayidx12.i, align 4, !tbaa !38
Attempting Group:
  store i32 %numboxes.addr.0.lcssa.i.i, i32* %actual_number_of_colors.i, align 4, !tbaa !40
Creating Node
  store i32 95, i32* %msg_code.i, align 8, !tbaa !42
  store i32 %numboxes.addr.0.lcssa.i.i, i32* %arrayidx12.i, align 4, !tbaa !38
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 95
  %numboxes.addr.0.lcssa.i.i = phi i32 [ %indvars.iv.tr.i.i.le, %median_cut.exit.i.split.loop.exit13 ], [ %54, %median_cut.exit.i.loopexit ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 95
Alt Seq
Creating Node
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %55, i64 0, i32 5
  %arrayidx12.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %55, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %55, i64 0, i32 5
  %arrayidx12.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %55, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %55, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 95, i32* %msg_code.i, align 8, !tbaa !42
}
ScheduleNode: {
  store i32 %numboxes.addr.0.lcssa.i.i, i32* %arrayidx12.i, align 4, !tbaa !38
}
ScheduleNode: {
  store i32 95, i32* %msg_code.i, align 8, !tbaa !42
}
Count: 1
Start:   store i32 95, i32* %msg_code.i, align 8, !tbaa !42
Processing:   store i32 95, i32* %msg_code.i, align 8, !tbaa !42
Count: 1
Found:   store i32 95, i32* %msg_code.i, align 8, !tbaa !42
ScheduleNode: {
  store i32 %numboxes.addr.0.lcssa.i.i, i32* %arrayidx12.i, align 4, !tbaa !38
}
Non-memory:   %arrayidx12.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %55, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %numboxes.addr.0.lcssa.i.i, i32* %arrayidx12.i, align 4, !tbaa !38
Count: 1
Found:   store i32 %numboxes.addr.0.lcssa.i.i, i32* %arrayidx12.i, align 4, !tbaa !38
I:   %56 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i, align 8, !tbaa !41
Last:   ret void
Schedulable: 1
Loop Rolling: finish_pass1
Generating tree
Generating MATCH
Match: 
  store i32 95, i32* %msg_code.i, align 8, !tbaa !42
  store i32 %numboxes.addr.0.lcssa.i.i, i32* %arrayidx12.i, align 4, !tbaa !38
Generating ALTSEQ
Values:
i32 95
  %numboxes.addr.0.lcssa.i.i = phi i32 [ %indvars.iv.tr.i.i.le, %median_cut.exit.i.split.loop.exit13 ], [ %54, %median_cut.exit.i.loopexit ]
Generated Version 4:
  %59 = icmp eq i8 %58, 0
  %60 = select i1 %59, i32 95, i32 %numboxes.addr.0.lcssa.i.i
Generating ALTSEQ
Values:
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %55, i64 0, i32 5
  %arrayidx12.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %55, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %61 = select i1 %59, i32* %msg_code.i, i32* %arrayidx12.i
Operands done!
Generated:   store i32 %60, i32* %61, align 1
Gen:   store i32 %60, i32* %61, align 1
Graph code generated!
Root:
  store i32 95, i32* %msg_code.i, align 8, !tbaa !42
  store i32 %numboxes.addr.0.lcssa.i.i, i32* %arrayidx12.i, align 4, !tbaa !38
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 95, %numboxes.addr.0.lcssa.i.i", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code.i, %arrayidx12.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; finish_pass1
Trying AGAIN
Trying AGAIN
Done Loop Roller: 0/3
Optimizing: find_nearby_colors
looking for reduction
looking for reduction
  %indvars.iv296 = phi i64 [ %indvars.iv.next297, %if.end142 ], [ 0, %entry ]
  %minmaxdist.0 = phi i64 [ %spec.select, %if.end142 ], [ 2147483647, %entry ]
looking for reduction
  %minmaxdist.0.lcssa = phi i64 [ %minmaxdist.0, %for.cond ]
looking for reduction
looking for reduction
looking for reduction
  %min_dist.0 = phi i64 [ %mul12, %if.then ], [ %mul23, %if.then19 ], [ 0, %if.then31 ], [ 0, %if.else36 ]
  %max_dist.0 = phi i64 [ %mul16, %if.then ], [ %mul27, %if.then19 ], [ %mul35, %if.then31 ], [ %mul40, %if.else36 ]
looking for reduction
looking for reduction
looking for reduction
  %min_dist.1 = phi i64 [ %add55, %if.then50 ], [ %add69, %if.then64 ], [ %min_dist.0, %if.then78 ], [ %min_dist.0, %if.else84 ]
  %mul59.pn = phi i64 [ %mul59, %if.then50 ], [ %mul73, %if.then64 ], [ %mul82, %if.then78 ], [ %mul88, %if.else84 ]
looking for reduction
looking for reduction
looking for reduction
  %min_dist.2 = phi i64 [ %add105, %if.then100 ], [ %add119, %if.then114 ], [ %min_dist.1, %if.then128 ], [ %min_dist.1, %if.else134 ]
  %mul109.pn = phi i64 [ %mul109, %if.then100 ], [ %mul123, %if.then114 ], [ %mul132, %if.then128 ], [ %mul138, %if.else134 ]
looking for reduction
Attempting Group:
  store i64 %min_dist.2, i64* %arrayidx144, align 8, !tbaa !13
  %indvars.iv = phi i64 [ 0, %for.cond149.preheader ], [ %indvars.iv.next, %for.inc163 ]
  %ncolors.0 = phi i32 [ 0, %for.cond149.preheader ], [ %ncolors.1, %for.inc163 ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv158, i8* %arrayidx161, align 1, !tbaa !12
  %ncolors.1 = phi i32 [ %inc159, %if.then157 ], [ %ncolors.0, %for.body152 ]
  %ncolors.0.lcssa = phi i32 [ %ncolors.0, %for.cond149 ]
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 0/0
Nothing found in: find_nearby_colors
Optimizing: find_best_colors
looking for reduction
looking for reduction
  %i.0 = phi i32 [ 127, %entry ], [ %dec, %for.body ]
  %bptr.0 = phi i64* [ %arraydecay, %entry ], [ %incdec.ptr, %for.body ]
looking for reduction
looking for reduction
Attempting Group:
  store i64 2147483647, i64* %bptr.0, align 8, !tbaa !2
  %indvars.iv = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next, %for.inc68 ]
looking for reduction
  %bptr.1 = phi i64* [ %arraydecay, %for.body3 ], [ %bptr.2.lcssa, %for.end62 ]
  %cptr.0 = phi i8* [ %bestcolor, %for.body3 ], [ %cptr.1.lcssa, %for.end62 ]
  %dist0.0 = phi i64 [ %add28, %for.body3 ], [ %add63, %for.end62 ]
  %xx0.0 = phi i64 [ %add30, %for.body3 ], [ %add64, %for.end62 ]
  %ic0.0 = phi i32 [ 3, %for.body3 ], [ %dec66, %for.end62 ]
looking for reduction
  %ic1.0 = phi i32 [ %dec61, %for.end57 ], [ 7, %for.cond40.preheader ]
  %bptr.2 = phi i64* [ %bptr.3.lcssa, %for.end57 ], [ %bptr.1, %for.cond40.preheader ]
  %cptr.1 = phi i8* [ %cptr.2.lcssa, %for.end57 ], [ %cptr.0, %for.cond40.preheader ]
  %dist1.0 = phi i64 [ %add58, %for.end57 ], [ %dist0.0, %for.cond40.preheader ]
  %xx1.0 = phi i64 [ %add59, %for.end57 ], [ %add32, %for.cond40.preheader ]
looking for reduction
  %ic2.0 = phi i32 [ %dec56, %if.end ], [ 3, %for.cond44.preheader ]
  %bptr.3 = phi i64* [ %incdec.ptr53, %if.end ], [ %bptr.2, %for.cond44.preheader ]
  %cptr.2 = phi i8* [ %incdec.ptr54, %if.end ], [ %cptr.1, %for.cond44.preheader ]
  %dist2.0 = phi i64 [ %add51, %if.end ], [ %dist1.0, %for.cond44.preheader ]
  %xx2.0 = phi i64 [ %add52, %if.end ], [ %add34, %for.cond44.preheader ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %2, i8* %cptr.2, align 1, !tbaa !8
Attempting Group:
  store i64 %dist2.0, i64* %bptr.3, align 8, !tbaa !2
  %bptr.3.lcssa = phi i64* [ %bptr.3, %for.cond44 ]
  %cptr.2.lcssa = phi i8* [ %cptr.2, %for.cond44 ]
  %bptr.2.lcssa = phi i64* [ %bptr.2, %for.cond40 ]
  %cptr.1.lcssa = phi i8* [ %cptr.1, %for.cond40 ]
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 0/0
Nothing found in: find_best_colors
Optimizing: fill_inverse_cmap
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %indvars.iv296.i = phi i64 [ %indvars.iv.next297.i, %if.end142.i ], [ 0, %entry ]
  %minmaxdist.0.i = phi i64 [ %spec.select.i, %if.end142.i ], [ 2147483647, %entry ]
looking for reduction
  %minmaxdist.0.i.lcssa = phi i64 [ %minmaxdist.0.i, %for.cond.i ]
looking for reduction
looking for reduction
looking for reduction
  %min_dist.0.i = phi i64 [ %mul12.i, %if.then.i ], [ %mul23.i, %if.then19.i ], [ 0, %if.then31.i ], [ 0, %if.else36.i ]
  %max_dist.0.i = phi i64 [ %mul16.i, %if.then.i ], [ %mul27.i, %if.then19.i ], [ %mul35.i, %if.then31.i ], [ %mul40.i, %if.else36.i ]
looking for reduction
looking for reduction
looking for reduction
  %min_dist.1.i = phi i64 [ %add55.i, %if.then50.i ], [ %add69.i, %if.then64.i ], [ %min_dist.0.i, %if.then78.i ], [ %min_dist.0.i, %if.else84.i ]
  %mul59.pn.i = phi i64 [ %mul59.i, %if.then50.i ], [ %mul73.i, %if.then64.i ], [ %mul82.i, %if.then78.i ], [ %mul88.i, %if.else84.i ]
looking for reduction
looking for reduction
looking for reduction
  %min_dist.2.i = phi i64 [ %add105.i, %if.then100.i ], [ %add119.i, %if.then114.i ], [ %min_dist.1.i, %if.then128.i ], [ %min_dist.1.i, %if.else134.i ]
  %mul109.pn.i = phi i64 [ %mul109.i, %if.then100.i ], [ %mul123.i, %if.then114.i ], [ %mul132.i, %if.then128.i ], [ %mul138.i, %if.else134.i ]
looking for reduction
Attempting Group:
  store i64 %min_dist.2.i, i64* %arrayidx144.i, align 8, !tbaa !17
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.inc163.i ], [ 0, %for.cond149.i.preheader ]
  %ncolors.0.i = phi i32 [ %ncolors.1.i, %for.inc163.i ], [ 0, %for.cond149.i.preheader ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv158.i, i8* %arrayidx161.i, align 1, !tbaa !16
  %ncolors.1.i = phi i32 [ %inc159.i, %if.then157.i ], [ %ncolors.0.i, %for.body152.i ]
  %ncolors.0.i.lcssa = phi i32 [ %ncolors.0.i, %for.cond149.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %i.0.i = phi i32 [ 127, %find_nearby_colors.exit ], [ %dec.i, %for.body.i68 ]
  %bptr.0.i = phi i64* [ %arraydecay.i, %find_nearby_colors.exit ], [ %incdec.ptr.i, %for.body.i68 ]
looking for reduction
looking for reduction
Attempting Group:
  store i64 2147483647, i64* %bptr.0.i, align 8, !tbaa !17
  %indvars.iv.i69 = phi i64 [ 0, %for.cond1.preheader.i ], [ %indvars.iv.next.i81, %for.inc68.i ]
looking for reduction
  %bptr.1.i = phi i64* [ %arraydecay.i, %for.body3.i ], [ %bptr.2.i.lcssa, %for.end62.i ]
  %cptr.0.i = phi i8* [ %4, %for.body3.i ], [ %cptr.1.i.lcssa, %for.end62.i ]
  %dist0.0.i = phi i64 [ %add28.i, %for.body3.i ], [ %add63.i, %for.end62.i ]
  %xx0.0.i = phi i64 [ %add30.i, %for.body3.i ], [ %add64.i, %for.end62.i ]
  %ic0.0.i = phi i32 [ 3, %for.body3.i ], [ %dec66.i, %for.end62.i ]
looking for reduction
  %ic1.0.i = phi i32 [ %dec61.i, %for.end57.i ], [ 7, %for.cond40.i.preheader ]
  %bptr.2.i = phi i64* [ %bptr.3.i.lcssa, %for.end57.i ], [ %bptr.1.i, %for.cond40.i.preheader ]
  %cptr.1.i = phi i8* [ %cptr.2.i.lcssa, %for.end57.i ], [ %cptr.0.i, %for.cond40.i.preheader ]
  %dist1.0.i = phi i64 [ %add58.i, %for.end57.i ], [ %dist0.0.i, %for.cond40.i.preheader ]
  %xx1.0.i = phi i64 [ %add59.i, %for.end57.i ], [ %add32.i, %for.cond40.i.preheader ]
looking for reduction
  %ic2.0.i = phi i32 [ %dec56.i, %if.end.i ], [ 3, %for.cond44.i.preheader ]
  %bptr.3.i = phi i64* [ %incdec.ptr53.i, %if.end.i ], [ %bptr.2.i, %for.cond44.i.preheader ]
  %cptr.2.i = phi i8* [ %incdec.ptr54.i, %if.end.i ], [ %cptr.1.i, %for.cond44.i.preheader ]
  %dist2.0.i = phi i64 [ %add51.i, %if.end.i ], [ %dist1.0.i, %for.cond44.i.preheader ]
  %xx2.0.i = phi i64 [ %add52.i, %if.end.i ], [ %add34.i, %for.cond44.i.preheader ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %21, i8* %cptr.2.i, align 1, !tbaa !16
Attempting Group:
  store i64 %dist2.0.i, i64* %bptr.3.i, align 8, !tbaa !17
  %bptr.3.i.lcssa = phi i64* [ %bptr.3.i, %for.cond44.i ]
  %cptr.2.i.lcssa = phi i8* [ %cptr.2.i, %for.cond44.i ]
  %bptr.2.i.lcssa = phi i64* [ %bptr.2.i, %for.cond40.i ]
  %cptr.1.i.lcssa = phi i8* [ %cptr.1.i, %for.cond40.i ]
looking for reduction
looking for reduction
  %indvars.iv84 = phi i64 [ %indvars.iv.next85, %for.inc33 ], [ 0, %find_best_colors.exit ]
  %cptr.0 = phi i8* [ %cptr.1.lcssa, %for.inc33 ], [ %4, %find_best_colors.exit ]
looking for reduction
  %indvars.iv = phi i64 [ 0, %for.cond15.preheader ], [ %indvars.iv.next, %for.inc30 ]
  %cptr.1 = phi i8* [ %cptr.0, %for.cond15.preheader ], [ %cptr.2.lcssa, %for.inc30 ]
looking for reduction
  %ic2.0 = phi i32 [ 0, %for.body17 ], [ %inc, %for.body26 ]
  %cptr.2 = phi i8* [ %cptr.1, %for.body17 ], [ %incdec.ptr, %for.body26 ]
  %cachep.0 = phi i16* [ %arrayidx23, %for.body17 ], [ %incdec.ptr29, %for.body26 ]
looking for reduction
looking for reduction
  %add27 = add nuw nsw i16 %conv, 1
Attempting Group:
  store i16 %add27, i16* %cachep.0, align 2, !tbaa !27
  %cptr.2.lcssa = phi i8* [ %cptr.2, %for.cond24 ]
  %cptr.1.lcssa = phi i8* [ %cptr.1, %for.cond15 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 0/0
Nothing found in: fill_inverse_cmap
Optimizing: pass2_fs_dither
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.end ], [ 0, %entry ]
looking for reduction
looking for reduction
  %storemerge = phi i32 [ 1, %if.else ], [ 0, %if.then ]
  %inptr.0 = phi i8* [ %12, %if.else ], [ %add.ptr, %if.then ]
  %outptr.0 = phi i8* [ %13, %if.else ], [ %add.ptr12, %if.then ]
  %errorptr.0 = phi i16* [ %16, %if.else ], [ %add.ptr15, %if.then ]
  %dir.0 = phi i64 [ 1, %if.else ], [ -1, %if.then ]
  %dir3.0 = phi i32 [ 3, %if.else ], [ -3, %if.then ]
looking for reduction
Attempting Group:
  store i32 %storemerge, i32* %on_odd_row, align 8, !tbaa !18
  %inptr.1 = phi i8* [ %inptr.0, %if.end ], [ %add.ptr122, %if.end81 ]
  %outptr.1 = phi i8* [ %outptr.0, %if.end ], [ %add.ptr124, %if.end81 ]
  %errorptr.1 = phi i16* [ %errorptr.0, %if.end ], [ %arrayidx24, %if.end81 ]
  %col.0 = phi i32 [ %3, %if.end ], [ %dec, %if.end81 ]
  %bpreverr2.0 = phi i32 [ 0, %if.end ], [ %add119, %if.end81 ]
  %bpreverr1.0 = phi i32 [ 0, %if.end ], [ %add111, %if.end81 ]
  %bpreverr0.0 = phi i32 [ 0, %if.end ], [ %add103, %if.end81 ]
  %belowerr2.0 = phi i32 [ 0, %if.end ], [ %sub96, %if.end81 ]
  %belowerr1.0 = phi i32 [ 0, %if.end ], [ %sub92, %if.end81 ]
  %belowerr0.0 = phi i32 [ 0, %if.end ], [ %sub88, %if.end81 ]
  %cur2.0 = phi i32 [ 0, %if.end ], [ %add120, %if.end81 ]
  %cur1.0 = phi i32 [ 0, %if.end ], [ %add112, %if.end81 ]
  %cur0.0 = phi i32 [ 0, %if.end ], [ %add104, %if.end81 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %29 = lshr i32 %conv58, 3
looking for reduction
  %31 = lshr i32 %conv61, 2
looking for reduction
  %32 = lshr i32 %conv64, 3
Attempting Group:
  tail call fastcc void @fill_inverse_cmap(%struct.jpeg_decompress_struct* %cinfo, i32 %29, i32 %31, i32 %32) #5
  %34 = phi i16 [ %.pre, %if.then77 ], [ %33, %for.body21 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i16 %conv100, i16* %errorptr.1, align 2, !tbaa !20
  store i16 %conv108, i16* %arrayidx109, align 2, !tbaa !20
  store i16 %conv116, i16* %arrayidx117, align 2, !tbaa !20
Attempting Group:
  store i8 %conv84, i8* %outptr.1, align 1, !tbaa !22
Creating Node
  store i16 %conv100, i16* %errorptr.1, align 2, !tbaa !20
  store i16 %conv108, i16* %arrayidx109, align 2, !tbaa !20
  store i16 %conv116, i16* %arrayidx117, align 2, !tbaa !20
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %conv100 = trunc i32 %add99 to i16
  %conv108 = trunc i32 %add107 to i16
  %conv116 = trunc i32 %add115 to i16
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %add99 = add nsw i32 %add98, %bpreverr0.0
  %add107 = add nsw i32 %add106, %bpreverr1.0
  %add115 = add nsw i32 %add114, %bpreverr2.0
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %add98 = mul nsw i32 %sub88, 3
  %add106 = mul nsw i32 %sub92, 3
  %add114 = mul nsw i32 %sub96, 3
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %sub88 = sub nsw i32 %conv58, %conv87
  %sub92 = sub nsw i32 %conv61, %conv91
  %sub96 = sub nsw i32 %conv64, %conv95
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %conv58 = zext i8 %26 to i32
  %conv61 = zext i8 %27 to i32
  %conv64 = zext i8 %28 to i32
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %conv58 = zext i8 %26 to i32
Mismatching
Creating Node
  %conv87 = zext i8 %35 to i32
  %conv91 = zext i8 %36 to i32
  %conv95 = zext i8 %37 to i32
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %35 = load i8, i8* %arrayidx86, align 1, !tbaa !22
  %36 = load i8, i8* %arrayidx90, align 1, !tbaa !22
  %37 = load i8, i8* %arrayidx94, align 1, !tbaa !22
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %arrayidx86 = getelementptr inbounds i8, i8* %7, i64 %idxprom85
  %arrayidx90 = getelementptr inbounds i8, i8* %8, i64 %idxprom85
  %arrayidx94 = getelementptr inbounds i8, i8* %9, i64 %idxprom85
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %7 = load i8*, i8** %6, align 8, !tbaa !17
  %8 = load i8*, i8** %arrayidx4, align 8, !tbaa !17
  %9 = load i8*, i8** %arrayidx6, align 8, !tbaa !17
Match: 0
3 x 3
Final Match: 0
  %7 = load i8*, i8** %6, align 8, !tbaa !17
  %8 = load i8*, i8** %arrayidx4, align 8, !tbaa !17
  %9 = load i8*, i8** %arrayidx6, align 8, !tbaa !17
GEPSeq2
BinOP?
  %7 = load i8*, i8** %6, align 8, !tbaa !17
Mismatching
Creating Node
  %idxprom85 = sext i32 %sub83 to i64
  %idxprom85 = sext i32 %sub83 to i64
  %idxprom85 = sext i32 %sub83 to i64
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
i32 3
i32 3
i32 3
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
  %bpreverr0.0 = phi i32 [ 0, %if.end ], [ %add103, %if.end81 ]
  %bpreverr1.0 = phi i32 [ 0, %if.end ], [ %add111, %if.end81 ]
  %bpreverr2.0 = phi i32 [ 0, %if.end ], [ %add119, %if.end81 ]
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %bpreverr0.0 = phi i32 [ 0, %if.end ], [ %add103, %if.end81 ]
Mismatching
Creating Node
  %errorptr.1 = phi i16* [ %errorptr.0, %if.end ], [ %arrayidx24, %if.end81 ]
  %arrayidx109 = getelementptr inbounds i16, i16* %errorptr.1, i64 1
  %arrayidx117 = getelementptr inbounds i16, i16* %errorptr.1, i64 2
Match: 0
3 x 3
Final Match: 0
  %errorptr.1 = phi i16* [ %errorptr.0, %if.end ], [ %arrayidx24, %if.end81 ]
  %arrayidx109 = getelementptr inbounds i16, i16* %errorptr.1, i64 1
  %arrayidx117 = getelementptr inbounds i16, i16* %errorptr.1, i64 2
Ptr:   %errorptr.1 = phi i16* [ %errorptr.0, %if.end ], [ %arrayidx24, %if.end81 ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 1
i64 2
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
ScheduleNode: {
  %35 = load i8, i8* %arrayidx86, align 1, !tbaa !22
}
ScheduleNode: {
  store i16 %conv100, i16* %errorptr.1, align 2, !tbaa !20
}
ScheduleNode: {
  %36 = load i8, i8* %arrayidx90, align 1, !tbaa !22
}
ScheduleNode: {
  store i16 %conv108, i16* %arrayidx109, align 2, !tbaa !20
}
ScheduleNode: {
  %37 = load i8, i8* %arrayidx94, align 1, !tbaa !22
}
ScheduleNode: {
  store i16 %conv116, i16* %arrayidx117, align 2, !tbaa !20
}
ScheduleNode: {
  %35 = load i8, i8* %arrayidx86, align 1, !tbaa !22
}
Count: 1
Start:   %arrayidx86 = getelementptr inbounds i8, i8* %7, i64 %idxprom85
Non-memory:   %arrayidx86 = getelementptr inbounds i8, i8* %7, i64 %idxprom85
Processing:   %35 = load i8, i8* %arrayidx86, align 1, !tbaa !22
Count: 1
Found:   %35 = load i8, i8* %arrayidx86, align 1, !tbaa !22
ScheduleNode: {
  store i16 %conv100, i16* %errorptr.1, align 2, !tbaa !20
}
Non-memory:   %conv87 = zext i8 %35 to i32
Non-memory:   %sub88 = sub nsw i32 %conv58, %conv87
Non-memory:   %arrayidx90 = getelementptr inbounds i8, i8* %8, i64 %idxprom85
Processing:   %36 = load i8, i8* %arrayidx90, align 1, !tbaa !22
Count: 1
Not found:   %36 = load i8, i8* %arrayidx90, align 1, !tbaa !22
Read/Write memory
I:   %36 = load i8, i8* %arrayidx90, align 1, !tbaa !22
Last:   br label %for.cond19, !llvm.loop !23
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="trunc", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="mul", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="sub", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
6 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
10 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="3", style="filled" , fillcolor="#8ae18a", shape=box];
12 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
13 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="0..2, 1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
13->0 
2->1 
3->2 
12->2 
4->3 
11->3 
5->4 
6->4 
7->6 
8->7 
9->8 
10->8 
14->13 
15 [label="mul", style="filled" , fillcolor="#f2eb5c", shape=box];
4->15
16 [label="mul", style="filled" , fillcolor="#f2eb5c", shape=box];
4->16
17 [label="mul", style="filled" , fillcolor="#f2eb5c", shape=box];
4->17
}


if.end81:                                         ; preds = %if.then77, %for.body21
  %34 = phi i16 [ %.pre, %if.then77 ], [ %33, %for.body21 ]
  %conv82 = zext i16 %34 to i32
  %sub83 = add nsw i32 %conv82, -1
  %conv84 = trunc i32 %sub83 to i8
  store i8 %conv84, i8* %outptr.1, align 1, !tbaa !22
  %idxprom85 = sext i32 %sub83 to i64
  %arrayidx86 = getelementptr inbounds i8, i8* %7, i64 %idxprom85
  %35 = load i8, i8* %arrayidx86, align 1, !tbaa !22
  %conv87 = zext i8 %35 to i32
  %sub88 = sub nsw i32 %conv58, %conv87
  %arrayidx90 = getelementptr inbounds i8, i8* %8, i64 %idxprom85
  %36 = load i8, i8* %arrayidx90, align 1, !tbaa !22
  %conv91 = zext i8 %36 to i32
  %sub92 = sub nsw i32 %conv61, %conv91
  %arrayidx94 = getelementptr inbounds i8, i8* %9, i64 %idxprom85
  %37 = load i8, i8* %arrayidx94, align 1, !tbaa !22
  %conv95 = zext i8 %37 to i32
  %sub96 = sub nsw i32 %conv64, %conv95
  %add98 = mul nsw i32 %sub88, 3
  %add99 = add nsw i32 %add98, %bpreverr0.0
  %conv100 = trunc i32 %add99 to i16
  store i16 %conv100, i16* %errorptr.1, align 2, !tbaa !20
  %add102 = mul nsw i32 %sub88, 5
  %add103 = add nsw i32 %add102, %belowerr0.0
  %add104 = mul nsw i32 %sub88, 7
  %add106 = mul nsw i32 %sub92, 3
  %add107 = add nsw i32 %add106, %bpreverr1.0
  %conv108 = trunc i32 %add107 to i16
  %arrayidx109 = getelementptr inbounds i16, i16* %errorptr.1, i64 1
  store i16 %conv108, i16* %arrayidx109, align 2, !tbaa !20
  %add110 = mul nsw i32 %sub92, 5
  %add111 = add nsw i32 %add110, %belowerr1.0
  %add112 = mul nsw i32 %sub92, 7
  %add114 = mul nsw i32 %sub96, 3
  %add115 = add nsw i32 %add114, %bpreverr2.0
  %conv116 = trunc i32 %add115 to i16
  %arrayidx117 = getelementptr inbounds i16, i16* %errorptr.1, i64 2
  store i16 %conv116, i16* %arrayidx117, align 2, !tbaa !20
  %add118 = mul nsw i32 %sub96, 5
  %add119 = add nsw i32 %add118, %belowerr2.0
  %add120 = mul nsw i32 %sub96, 7
  %add.ptr122 = getelementptr inbounds i8, i8* %inptr.1, i64 %idxprom23
  %add.ptr124 = getelementptr inbounds i8, i8* %outptr.1, i64 %dir.0
  %dec = add i32 %col.0, -1
  br label %for.cond19, !llvm.loop !23

Trying AGAIN
Trying AGAIN
Creating Node
  store i16 %conv108, i16* %arrayidx109, align 2, !tbaa !20
  store i16 %conv116, i16* %arrayidx117, align 2, !tbaa !20
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv108 = trunc i32 %add107 to i16
  %conv116 = trunc i32 %add115 to i16
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %add107 = add nsw i32 %add106, %bpreverr1.0
  %add115 = add nsw i32 %add114, %bpreverr2.0
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %add106 = mul nsw i32 %sub92, 3
  %add114 = mul nsw i32 %sub96, 3
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %sub92 = sub nsw i32 %conv61, %conv91
  %sub96 = sub nsw i32 %conv64, %conv95
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv61 = zext i8 %27 to i32
  %conv64 = zext i8 %28 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %conv61 = zext i8 %27 to i32
Alt Seq
Creating Node
  %conv91 = zext i8 %36 to i32
  %conv95 = zext i8 %37 to i32
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %36 = load i8, i8* %arrayidx90, align 1, !tbaa !22
  %37 = load i8, i8* %arrayidx94, align 1, !tbaa !22
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx90 = getelementptr inbounds i8, i8* %8, i64 %idxprom85
  %arrayidx94 = getelementptr inbounds i8, i8* %9, i64 %idxprom85
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %8 = load i8*, i8** %arrayidx4, align 8, !tbaa !17
  %9 = load i8*, i8** %arrayidx6, align 8, !tbaa !17
Match: 0
2 x 2
Final Match: 0
  %8 = load i8*, i8** %arrayidx4, align 8, !tbaa !17
  %9 = load i8*, i8** %arrayidx6, align 8, !tbaa !17
GEPSeq2
BinOP?
  %8 = load i8*, i8** %arrayidx4, align 8, !tbaa !17
Alt Seq
Creating Node
  %idxprom85 = sext i32 %sub83 to i64
  %idxprom85 = sext i32 %sub83 to i64
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
i32 3
i32 3
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %bpreverr1.0 = phi i32 [ 0, %if.end ], [ %add111, %if.end81 ]
  %bpreverr2.0 = phi i32 [ 0, %if.end ], [ %add119, %if.end81 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %bpreverr1.0 = phi i32 [ 0, %if.end ], [ %add111, %if.end81 ]
Alt Seq
Creating Node
  %arrayidx109 = getelementptr inbounds i16, i16* %errorptr.1, i64 1
  %arrayidx117 = getelementptr inbounds i16, i16* %errorptr.1, i64 2
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %errorptr.1 = phi i16* [ %errorptr.0, %if.end ], [ %arrayidx24, %if.end81 ]
  %errorptr.1 = phi i16* [ %errorptr.0, %if.end ], [ %arrayidx24, %if.end81 ]
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
i64 1
i64 2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 1
Int Seq
ScheduleNode: {
  %36 = load i8, i8* %arrayidx90, align 1, !tbaa !22
}
ScheduleNode: {
  store i16 %conv108, i16* %arrayidx109, align 2, !tbaa !20
}
ScheduleNode: {
  %37 = load i8, i8* %arrayidx94, align 1, !tbaa !22
}
ScheduleNode: {
  store i16 %conv116, i16* %arrayidx117, align 2, !tbaa !20
}
ScheduleNode: {
  %36 = load i8, i8* %arrayidx90, align 1, !tbaa !22
}
Count: 1
Start:   %arrayidx90 = getelementptr inbounds i8, i8* %8, i64 %idxprom85
Non-memory:   %arrayidx90 = getelementptr inbounds i8, i8* %8, i64 %idxprom85
Processing:   %36 = load i8, i8* %arrayidx90, align 1, !tbaa !22
Count: 1
Found:   %36 = load i8, i8* %arrayidx90, align 1, !tbaa !22
ScheduleNode: {
  store i16 %conv108, i16* %arrayidx109, align 2, !tbaa !20
}
Non-memory:   %conv91 = zext i8 %36 to i32
Non-memory:   %sub92 = sub nsw i32 %conv61, %conv91
Non-memory:   %arrayidx94 = getelementptr inbounds i8, i8* %9, i64 %idxprom85
Processing:   %37 = load i8, i8* %arrayidx94, align 1, !tbaa !22
Count: 1
Not found:   %37 = load i8, i8* %arrayidx94, align 1, !tbaa !22
Read/Write memory
I:   %37 = load i8, i8* %arrayidx94, align 1, !tbaa !22
Last:   br label %for.cond19, !llvm.loop !23
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="trunc", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="mul", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="sub", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="alt: %conv61, %conv64", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="alt: %8, %9", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="3", style="filled" , fillcolor="#8ae18a", shape=box];
12 [label="alt: %bpreverr1.0, %bpreverr2.0", style="filled" , fillcolor="#8ae18a", shape=box];
13 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
15 [label="1..2, 1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
13->0 
2->1 
3->2 
12->2 
4->3 
11->3 
5->4 
6->4 
7->6 
8->7 
9->8 
10->8 
14->13 
15->13 
16 [label="mul", style="filled" , fillcolor="#f2eb5c", shape=box];
4->16
17 [label="mul", style="filled" , fillcolor="#f2eb5c", shape=box];
4->17
}


if.end81:                                         ; preds = %if.then77, %for.body21
  %34 = phi i16 [ %.pre, %if.then77 ], [ %33, %for.body21 ]
  %conv82 = zext i16 %34 to i32
  %sub83 = add nsw i32 %conv82, -1
  %conv84 = trunc i32 %sub83 to i8
  store i8 %conv84, i8* %outptr.1, align 1, !tbaa !22
  %idxprom85 = sext i32 %sub83 to i64
  %arrayidx86 = getelementptr inbounds i8, i8* %7, i64 %idxprom85
  %35 = load i8, i8* %arrayidx86, align 1, !tbaa !22
  %conv87 = zext i8 %35 to i32
  %sub88 = sub nsw i32 %conv58, %conv87
  %arrayidx90 = getelementptr inbounds i8, i8* %8, i64 %idxprom85
  %36 = load i8, i8* %arrayidx90, align 1, !tbaa !22
  %conv91 = zext i8 %36 to i32
  %sub92 = sub nsw i32 %conv61, %conv91
  %arrayidx94 = getelementptr inbounds i8, i8* %9, i64 %idxprom85
  %37 = load i8, i8* %arrayidx94, align 1, !tbaa !22
  %conv95 = zext i8 %37 to i32
  %sub96 = sub nsw i32 %conv64, %conv95
  %add98 = mul nsw i32 %sub88, 3
  %add99 = add nsw i32 %add98, %bpreverr0.0
  %conv100 = trunc i32 %add99 to i16
  store i16 %conv100, i16* %errorptr.1, align 2, !tbaa !20
  %add102 = mul nsw i32 %sub88, 5
  %add103 = add nsw i32 %add102, %belowerr0.0
  %add104 = mul nsw i32 %sub88, 7
  %add106 = mul nsw i32 %sub92, 3
  %add107 = add nsw i32 %add106, %bpreverr1.0
  %conv108 = trunc i32 %add107 to i16
  %arrayidx109 = getelementptr inbounds i16, i16* %errorptr.1, i64 1
  store i16 %conv108, i16* %arrayidx109, align 2, !tbaa !20
  %add110 = mul nsw i32 %sub92, 5
  %add111 = add nsw i32 %add110, %belowerr1.0
  %add112 = mul nsw i32 %sub92, 7
  %add114 = mul nsw i32 %sub96, 3
  %add115 = add nsw i32 %add114, %bpreverr2.0
  %conv116 = trunc i32 %add115 to i16
  %arrayidx117 = getelementptr inbounds i16, i16* %errorptr.1, i64 2
  store i16 %conv116, i16* %arrayidx117, align 2, !tbaa !20
  %add118 = mul nsw i32 %sub96, 5
  %add119 = add nsw i32 %add118, %belowerr2.0
  %add120 = mul nsw i32 %sub96, 7
  %add.ptr122 = getelementptr inbounds i8, i8* %inptr.1, i64 %idxprom23
  %add.ptr124 = getelementptr inbounds i8, i8* %outptr.1, i64 %dir.0
  %dec = add i32 %col.0, -1
  br label %for.cond19, !llvm.loop !23

  %errorptr.1.lcssa = phi i16* [ %errorptr.1, %for.cond19 ]
  %bpreverr2.0.lcssa = phi i32 [ %bpreverr2.0, %for.cond19 ]
  %bpreverr1.0.lcssa = phi i32 [ %bpreverr1.0, %for.cond19 ]
  %bpreverr0.0.lcssa = phi i32 [ %bpreverr0.0, %for.cond19 ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i16 %conv127, i16* %errorptr.1.lcssa, align 2, !tbaa !20
  store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
  store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
Creating Node
  store i16 %conv127, i16* %errorptr.1.lcssa, align 2, !tbaa !20
  store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
  store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %conv127 = trunc i32 %bpreverr0.0.lcssa to i16
  %conv129 = trunc i32 %bpreverr1.0.lcssa to i16
  %conv131 = trunc i32 %bpreverr2.0.lcssa to i16
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %bpreverr0.0.lcssa = phi i32 [ %bpreverr0.0, %for.cond19 ]
  %bpreverr1.0.lcssa = phi i32 [ %bpreverr1.0, %for.cond19 ]
  %bpreverr2.0.lcssa = phi i32 [ %bpreverr2.0, %for.cond19 ]
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %bpreverr0.0.lcssa = phi i32 [ %bpreverr0.0, %for.cond19 ]
Mismatching
Creating Node
  %errorptr.1.lcssa = phi i16* [ %errorptr.1, %for.cond19 ]
  %arrayidx130 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 1
  %arrayidx132 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 2
Match: 0
3 x 3
Final Match: 0
  %errorptr.1.lcssa = phi i16* [ %errorptr.1, %for.cond19 ]
  %arrayidx130 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 1
  %arrayidx132 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 2
Ptr:   %errorptr.1.lcssa = phi i16* [ %errorptr.1, %for.cond19 ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 1
i64 2
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
ScheduleNode: {
  store i16 %conv127, i16* %errorptr.1.lcssa, align 2, !tbaa !20
}
ScheduleNode: {
  store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
}
ScheduleNode: {
  store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
}
ScheduleNode: {
  store i16 %conv127, i16* %errorptr.1.lcssa, align 2, !tbaa !20
}
Count: 1
Start:   %conv127 = trunc i32 %bpreverr0.0.lcssa to i16
Non-memory:   %conv127 = trunc i32 %bpreverr0.0.lcssa to i16
Processing:   store i16 %conv127, i16* %errorptr.1.lcssa, align 2, !tbaa !20
Count: 1
Found:   store i16 %conv127, i16* %errorptr.1.lcssa, align 2, !tbaa !20
ScheduleNode: {
  store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
}
Non-memory:   %conv129 = trunc i32 %bpreverr1.0.lcssa to i16
Non-memory:   %arrayidx130 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 1
Processing:   store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
Count: 1
Found:   store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
ScheduleNode: {
  store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
}
Non-memory:   %conv131 = trunc i32 %bpreverr2.0.lcssa to i16
Non-memory:   %arrayidx132 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 2
Processing:   store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
Count: 1
Found:   store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
I:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
Last:   br label %for.cond, !llvm.loop !25
Schedulable: 1
Loop Rolling: pass2_fs_dither
Generating tree
Generating MATCH
Match: 
  store i16 %conv127, i16* %errorptr.1.lcssa, align 2, !tbaa !20
  store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
  store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
Generating MATCH
Match: 
  %conv127 = trunc i32 %bpreverr0.0.lcssa to i16
  %conv129 = trunc i32 %bpreverr1.0.lcssa to i16
  %conv131 = trunc i32 %bpreverr2.0.lcssa to i16
Generating Mismatch
Mismatched Values:
inst:   %bpreverr0.0.lcssa = phi i32 [ %bpreverr0.0, %for.cond19 ]
inst:   %bpreverr1.0.lcssa = phi i32 [ %bpreverr1.0, %for.cond19 ]
inst:   %bpreverr2.0.lcssa = phi i32 [ %bpreverr2.0, %for.cond19 ]
Non constants
Array Type: 3:i32
Created array:   %38 = alloca i32, i8 3, align 4
Gen:   %44 = load i32, i32* %43, align 4
Operands done!
Generated:   %45 = trunc i32 %44 to i16
Gen:   %45 = trunc i32 %44 to i16
Generating GEPSEQ
Generating INTSEQ
Gen:   %46 = zext i8 %42 to i64
Closing GEPSEQ
Gen:   %47 = getelementptr i16, i16* %errorptr.1.lcssa, i64 %46
Operands done!
Generated:   store i16 %45, i16* %47, align 1
Gen:   store i16 %45, i16* %47, align 1
Graph code generated!
Root:
  store i16 %conv127, i16* %errorptr.1.lcssa, align 2, !tbaa !20
  store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
  store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
Root size: 3
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="trunc", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0..2, 1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
3->0 
2->1 
4->3 
}

Gains: 9 - 46 = -37; Width: 3; Unprofitable; pass2_fs_dither
Trying AGAIN
Trying AGAIN
Creating Node
  store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
  store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv129 = trunc i32 %bpreverr1.0.lcssa to i16
  %conv131 = trunc i32 %bpreverr2.0.lcssa to i16
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %bpreverr1.0.lcssa = phi i32 [ %bpreverr1.0, %for.cond19 ]
  %bpreverr2.0.lcssa = phi i32 [ %bpreverr2.0, %for.cond19 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %bpreverr1.0.lcssa = phi i32 [ %bpreverr1.0, %for.cond19 ]
Alt Seq
Creating Node
  %arrayidx130 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 1
  %arrayidx132 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 2
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %errorptr.1.lcssa = phi i16* [ %errorptr.1, %for.cond19 ]
  %errorptr.1.lcssa = phi i16* [ %errorptr.1, %for.cond19 ]
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
i64 1
i64 2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 1
Int Seq
ScheduleNode: {
  store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
}
ScheduleNode: {
  store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
}
ScheduleNode: {
  store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
}
Count: 1
Start:   %conv129 = trunc i32 %bpreverr1.0.lcssa to i16
Non-memory:   %conv129 = trunc i32 %bpreverr1.0.lcssa to i16
Non-memory:   %arrayidx130 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 1
Processing:   store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
Count: 1
Found:   store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
ScheduleNode: {
  store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
}
Non-memory:   %conv131 = trunc i32 %bpreverr2.0.lcssa to i16
Non-memory:   %arrayidx132 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 2
Processing:   store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
Count: 1
Found:   store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
I:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
Last:   br label %for.cond, !llvm.loop !25
Schedulable: 1
Loop Rolling: pass2_fs_dither
Generating tree
Generating MATCH
Match: 
  store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
  store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
Generating MATCH
Match: 
  %conv129 = trunc i32 %bpreverr1.0.lcssa to i16
  %conv131 = trunc i32 %bpreverr2.0.lcssa to i16
Generating ALTSEQ
Values:
  %bpreverr1.0.lcssa = phi i32 [ %bpreverr1.0, %for.cond19 ]
  %bpreverr2.0.lcssa = phi i32 [ %bpreverr2.0, %for.cond19 ]
Generated Version 4:
  %39 = icmp eq i8 %38, 0
  %40 = select i1 %39, i32 %bpreverr1.0.lcssa, i32 %bpreverr2.0.lcssa
Operands done!
Generated:   %41 = trunc i32 %40 to i16
Gen:   %41 = trunc i32 %40 to i16
Generating MATCH
Match: 
  %arrayidx130 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 1
  %arrayidx132 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 2
Generating IDENTICAL
Generating INTSEQ
Gen:   %43 = add i64 %42, 1
Operands done!
Generated:   %44 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 %43
Gen:   %44 = getelementptr inbounds i16, i16* %errorptr.1.lcssa, i64 %43
Operands done!
Generated:   store i16 %41, i16* %44, align 1
Gen:   store i16 %41, i16* %44, align 1
Graph code generated!
Root:
  store i16 %conv129, i16* %arrayidx130, align 2, !tbaa !20
  store i16 %conv131, i16* %arrayidx132, align 2, !tbaa !20
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="trunc", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %bpreverr1.0.lcssa, %bpreverr2.0.lcssa", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="1..2, 1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
3->0 
2->1 
4->3 
5->3 
}

Gains: 8 - 11 = -3; Width: 2; Unprofitable; pass2_fs_dither
looking for reduction
Done Loop Roller: 0/2
Optimizing: pass2_no_dither
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc26 ], [ 0, %entry ]
looking for reduction
  %outptr.0 = phi i8* [ %6, %for.body ], [ %incdec.ptr25, %if.end ]
  %col.0 = phi i32 [ %3, %for.body ], [ %dec, %if.end ]
  %inptr.0 = phi i8* [ %5, %for.body ], [ %incdec.ptr11, %if.end ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @fill_inverse_cmap(%struct.jpeg_decompress_struct* %cinfo, i32 %17, i32 %16, i32 %15) #5
  %18 = phi i16 [ %.pre, %if.then ], [ %14, %for.body7 ]
looking for reduction
  %sub = add i8 %conv23, -1
Attempting Group:
  store i8 %sub, i8* %outptr.0, align 1, !tbaa !15
looking for reduction
Done Loop Roller: 0/0
Nothing found in: pass2_no_dither
Optimizing: finish_pass2
looking for reduction
Done Loop Roller: 0/0
Nothing found in: finish_pass2
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jcomapi.c -o src/jcomapi.o   -mllvm -reroll-loops=3
Optimizing: jpeg_abort
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %cond, i32* %global_state, align 4, !tbaa !12
Done Loop Roller: 0/0
Nothing found in: jpeg_abort
Optimizing: jpeg_destroy
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store %struct.jpeg_memory_mgr* null, %struct.jpeg_memory_mgr** %mem, align 8, !tbaa !2
Done Loop Roller: 0/0
Nothing found in: jpeg_destroy
Optimizing: jpeg_alloc_quant_table
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %3, align 4, !tbaa !11
Done Loop Roller: 0/0
Nothing found in: jpeg_alloc_quant_table
Optimizing: jpeg_alloc_huff_table
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %3, align 4, !tbaa !11
Done Loop Roller: 0/0
Nothing found in: jpeg_alloc_huff_table
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jdmainct.c -o src/jdmainct.o   -mllvm -reroll-loops=3
Optimizing: alloc_funny_pointers
looking for reduction
looking for reduction
looking for reduction
  %mul1 = shl nsw i64 %conv, 3
looking for reduction
looking for reduction
Attempting Group:
  store i8* %call, i8** %8, align 8, !tbaa !16
  %11 = phi i32 [ %.pre, %for.body ], [ %9, %entry ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %incdec.ptr, %for.body ], [ %10, %entry ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul16 = shl nsw i64 %conv15, 3
looking for reduction
looking for reduction
Attempting Group:
  store i8** %add.ptr26, i8*** %arrayidx30, align 8, !tbaa !16
Attempting Group:
  store i8** %add.ptr19, i8*** %arrayidx22, align 8, !tbaa !16
looking for reduction
Done Loop Roller: 0/0
Nothing found in: alloc_funny_pointers
Optimizing: jinit_d_main_controller
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, i32)* @start_pass_main, void (%struct.jpeg_decompress_struct*, i32)** %start_pass, align 8, !tbaa !14
Attempting Group:
  store i8* %call, i8** %3, align 8, !tbaa !13
looking for reduction
looking for reduction
Attempting Group:
  store i32 4, i32* %msg_code, align 8, !tbaa !18
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 46, i32* %msg_code6, align 8, !tbaa !18
  %11 = phi i32 [ %.pre, %if.then4 ], [ %8, %if.then3 ]
looking for reduction
looking for reduction
looking for reduction
  %mul1.i = shl nsw i64 %conv.i, 3
looking for reduction
looking for reduction
Attempting Group:
  store i8* %call.i, i8** %18, align 8, !tbaa !26
  %21 = phi i32 [ %.pre.i, %for.body.i ], [ %19, %if.end9 ]
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body.i ], [ 0, %if.end9 ]
  %compptr.0.i = phi %struct.jpeg_component_info* [ %incdec.ptr.i, %for.body.i ], [ %20, %if.end9 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul16.i = shl nsw i64 %conv15.i, 3
looking for reduction
looking for reduction
Attempting Group:
  store i8** %add.ptr26.i, i8*** %arrayidx30.i, align 8, !tbaa !26
Attempting Group:
  store i8** %add.ptr19.i, i8*** %arrayidx22.i, align 8, !tbaa !26
  %ngroups.0 = phi i32 [ %add, %alloc_funny_pointers.exit ], [ %32, %if.else ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %if.end12 ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %incdec.ptr, %for.body ], [ %33, %if.end12 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul17 = mul i32 %42, %38
looking for reduction
  %mul18 = mul nsw i32 %div, %ngroups.0
looking for reduction
Attempting Group:
  store i8** %call19, i8*** %arrayidx, align 8, !tbaa !26
looking for reduction
Done Loop Roller: 0/0
Nothing found in: jinit_d_main_controller
Optimizing: make_funny_pointers
  %indvars.iv117 = phi i64 [ %indvars.iv.next118, %for.inc53 ], [ 0, %entry ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %incdec.ptr, %for.inc53 ], [ %3, %entry ]
looking for reduction
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body12 ], [ 0, %for.body ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %18, i8** %arrayidx18, align 8, !tbaa !16
Attempting Group:
  store i8* %18, i8** %arrayidx16, align 8, !tbaa !16
  %indvars.iv107 = phi i64 [ 0, %for.cond19.preheader ], [ %indvars.iv.next108, %for.body22 ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
  store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
Creating Node
  store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
  store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %22 = load i8*, i8** %arrayidx26, align 8, !tbaa !16
  %24 = load i8*, i8** %arrayidx35, align 8, !tbaa !16
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx26 = getelementptr inbounds i8*, i8** %12, i64 %21
  %arrayidx35 = getelementptr inbounds i8*, i8** %12, i64 %23
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %12 = load i8**, i8*** %arrayidx8, align 8, !tbaa !16
  %12 = load i8**, i8*** %arrayidx8, align 8, !tbaa !16
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %21 = add nsw i64 %indvars.iv107, %15
  %23 = add nsw i64 %indvars.iv107, %14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %indvars.iv107 = phi i64 [ 0, %for.cond19.preheader ], [ %indvars.iv.next108, %for.body22 ]
  %indvars.iv107 = phi i64 [ 0, %for.cond19.preheader ], [ %indvars.iv.next108, %for.body22 ]
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %15 = sext i32 %mul23 to i64
  %14 = sext i32 %mul27 to i64
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %15 = sext i32 %mul23 to i64
Alt Seq
Creating Node
  %arrayidx30 = getelementptr inbounds i8*, i8** %11, i64 %23
  %arrayidx39 = getelementptr inbounds i8*, i8** %11, i64 %21
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %11 = load i8**, i8*** %arrayidx6, align 8, !tbaa !16
  %11 = load i8**, i8*** %arrayidx6, align 8, !tbaa !16
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %23 = add nsw i64 %indvars.iv107, %14
  %21 = add nsw i64 %indvars.iv107, %15
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %14 = sext i32 %mul27 to i64
  %15 = sext i32 %mul23 to i64
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %14 = sext i32 %mul27 to i64
Alt Seq
ScheduleNode: {
  %22 = load i8*, i8** %arrayidx26, align 8, !tbaa !16
}
ScheduleNode: {
  store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
}
ScheduleNode: {
  %24 = load i8*, i8** %arrayidx35, align 8, !tbaa !16
}
ScheduleNode: {
  store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
}
ScheduleNode: {
  %22 = load i8*, i8** %arrayidx26, align 8, !tbaa !16
}
Count: 1
Start:   %21 = add nsw i64 %indvars.iv107, %15
Non-memory:   %21 = add nsw i64 %indvars.iv107, %15
Non-memory:   %arrayidx26 = getelementptr inbounds i8*, i8** %12, i64 %21
Processing:   %22 = load i8*, i8** %arrayidx26, align 8, !tbaa !16
Count: 1
Found:   %22 = load i8*, i8** %arrayidx26, align 8, !tbaa !16
ScheduleNode: {
  store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
}
Non-memory:   %23 = add nsw i64 %indvars.iv107, %14
Non-memory:   %arrayidx30 = getelementptr inbounds i8*, i8** %11, i64 %23
Processing:   store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
Count: 1
Found:   store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
ScheduleNode: {
  %24 = load i8*, i8** %arrayidx35, align 8, !tbaa !16
}
Non-memory:   %arrayidx35 = getelementptr inbounds i8*, i8** %12, i64 %23
Processing:   %24 = load i8*, i8** %arrayidx35, align 8, !tbaa !16
Count: 1
Found:   %24 = load i8*, i8** %arrayidx35, align 8, !tbaa !16
ScheduleNode: {
  store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
}
Non-memory:   %arrayidx39 = getelementptr inbounds i8*, i8** %11, i64 %21
Processing:   store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
Count: 1
Found:   store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
I:   %indvars.iv.next108 = add nuw nsw i64 %indvars.iv107, 1
Last:   br label %for.cond19, !llvm.loop !19
Schedulable: 1
Loop Rolling: make_funny_pointers
Generating tree
Generating MATCH
Match: 
  store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
  store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
Generating MATCH
Match: 
  %22 = load i8*, i8** %arrayidx26, align 8, !tbaa !16
  %24 = load i8*, i8** %arrayidx35, align 8, !tbaa !16
Generating MATCH
Match: 
  %arrayidx26 = getelementptr inbounds i8*, i8** %12, i64 %21
  %arrayidx35 = getelementptr inbounds i8*, i8** %12, i64 %23
Generating IDENTICAL
Generating MATCH
Match: 
  %21 = add nsw i64 %indvars.iv107, %15
  %23 = add nsw i64 %indvars.iv107, %14
Generating IDENTICAL
Generating ALTSEQ
Values:
  %15 = sext i32 %mul23 to i64
  %14 = sext i32 %mul27 to i64
Generated Version 4:
  %28 = icmp eq i8 %27, 0
  %29 = select i1 %28, i64 %15, i64 %14
Operands done!
Generated:   %30 = add nsw i64 %indvars.iv107, %29
Gen:   %30 = add nsw i64 %indvars.iv107, %29
Operands done!
Generated:   %31 = getelementptr inbounds i8*, i8** %12, i64 %30
Gen:   %31 = getelementptr inbounds i8*, i8** %12, i64 %30
Operands done!
Generated:   %32 = load i8*, i8** %31, align 1
Gen:   %32 = load i8*, i8** %31, align 1
Generating MATCH
Match: 
  %arrayidx30 = getelementptr inbounds i8*, i8** %11, i64 %23
  %arrayidx39 = getelementptr inbounds i8*, i8** %11, i64 %21
Generating IDENTICAL
Generating MATCH
Match: 
  %23 = add nsw i64 %indvars.iv107, %14
  %21 = add nsw i64 %indvars.iv107, %15
Generating IDENTICAL
Generating ALTSEQ
Values:
  %14 = sext i32 %mul27 to i64
  %15 = sext i32 %mul23 to i64
Generated Version 4:
  %33 = select i1 %28, i64 %14, i64 %15
Operands done!
Generated:   %34 = add nsw i64 %indvars.iv107, %33
Gen:   %34 = add nsw i64 %indvars.iv107, %33
Operands done!
Generated:   %35 = getelementptr inbounds i8*, i8** %11, i64 %34
Gen:   %35 = getelementptr inbounds i8*, i8** %11, i64 %34
Operands done!
Generated:   store i8* %32, i8** %35, align 1
Gen:   store i8* %32, i8** %35, align 1
Graph code generated!
Root:
  store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
  store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="alt: %15, %14", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="alt: %14, %15", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
7->0 
2->1 
3->2 
4->2 
5->4 
6->4 
8->7 
9->7 
5->9 
10->9 
}

Gains: 14 - 12 = 2; Width: 2; Unprofitable; make_funny_pointers
Trying AGAIN
Creating Node
  store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
  store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %22 = load i8*, i8** %arrayidx26, align 8, !tbaa !16
  %24 = load i8*, i8** %arrayidx35, align 8, !tbaa !16
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx26 = getelementptr inbounds i8*, i8** %12, i64 %21
  %arrayidx35 = getelementptr inbounds i8*, i8** %12, i64 %23
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %12 = load i8**, i8*** %arrayidx8, align 8, !tbaa !16
  %12 = load i8**, i8*** %arrayidx8, align 8, !tbaa !16
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %21 = add nsw i64 %indvars.iv107, %15
  %23 = add nsw i64 %indvars.iv107, %14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %indvars.iv107 = phi i64 [ 0, %for.cond19.preheader ], [ %indvars.iv.next108, %for.body22 ]
  %indvars.iv107 = phi i64 [ 0, %for.cond19.preheader ], [ %indvars.iv.next108, %for.body22 ]
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %15 = sext i32 %mul23 to i64
  %14 = sext i32 %mul27 to i64
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %15 = sext i32 %mul23 to i64
Alt Seq
Creating Node
  %arrayidx30 = getelementptr inbounds i8*, i8** %11, i64 %23
  %arrayidx39 = getelementptr inbounds i8*, i8** %11, i64 %21
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %11 = load i8**, i8*** %arrayidx6, align 8, !tbaa !16
  %11 = load i8**, i8*** %arrayidx6, align 8, !tbaa !16
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %23 = add nsw i64 %indvars.iv107, %14
  %21 = add nsw i64 %indvars.iv107, %15
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %14 = sext i32 %mul27 to i64
  %15 = sext i32 %mul23 to i64
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %14 = sext i32 %mul27 to i64
Alt Seq
ScheduleNode: {
  %22 = load i8*, i8** %arrayidx26, align 8, !tbaa !16
}
ScheduleNode: {
  store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
}
ScheduleNode: {
  %24 = load i8*, i8** %arrayidx35, align 8, !tbaa !16
}
ScheduleNode: {
  store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
}
ScheduleNode: {
  %22 = load i8*, i8** %arrayidx26, align 8, !tbaa !16
}
Count: 1
Start:   %21 = add nsw i64 %indvars.iv107, %15
Non-memory:   %21 = add nsw i64 %indvars.iv107, %15
Non-memory:   %arrayidx26 = getelementptr inbounds i8*, i8** %12, i64 %21
Processing:   %22 = load i8*, i8** %arrayidx26, align 8, !tbaa !16
Count: 1
Found:   %22 = load i8*, i8** %arrayidx26, align 8, !tbaa !16
ScheduleNode: {
  store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
}
Non-memory:   %23 = add nsw i64 %indvars.iv107, %14
Non-memory:   %arrayidx30 = getelementptr inbounds i8*, i8** %11, i64 %23
Processing:   store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
Count: 1
Found:   store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
ScheduleNode: {
  %24 = load i8*, i8** %arrayidx35, align 8, !tbaa !16
}
Non-memory:   %arrayidx35 = getelementptr inbounds i8*, i8** %12, i64 %23
Processing:   %24 = load i8*, i8** %arrayidx35, align 8, !tbaa !16
Count: 1
Found:   %24 = load i8*, i8** %arrayidx35, align 8, !tbaa !16
ScheduleNode: {
  store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
}
Non-memory:   %arrayidx39 = getelementptr inbounds i8*, i8** %11, i64 %21
Processing:   store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
Count: 1
Found:   store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
I:   %indvars.iv.next108 = add nuw nsw i64 %indvars.iv107, 1
Last:   br label %for.cond19, !llvm.loop !19
Schedulable: 1
Loop Rolling: make_funny_pointers
Generating tree
Generating MATCH
Match: 
  store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
  store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
Generating MATCH
Match: 
  %22 = load i8*, i8** %arrayidx26, align 8, !tbaa !16
  %24 = load i8*, i8** %arrayidx35, align 8, !tbaa !16
Generating MATCH
Match: 
  %arrayidx26 = getelementptr inbounds i8*, i8** %12, i64 %21
  %arrayidx35 = getelementptr inbounds i8*, i8** %12, i64 %23
Generating IDENTICAL
Generating MATCH
Match: 
  %21 = add nsw i64 %indvars.iv107, %15
  %23 = add nsw i64 %indvars.iv107, %14
Generating IDENTICAL
Generating ALTSEQ
Values:
  %15 = sext i32 %mul23 to i64
  %14 = sext i32 %mul27 to i64
Generated Version 4:
  %28 = icmp eq i8 %27, 0
  %29 = select i1 %28, i64 %15, i64 %14
Operands done!
Generated:   %30 = add nsw i64 %indvars.iv107, %29
Gen:   %30 = add nsw i64 %indvars.iv107, %29
Operands done!
Generated:   %31 = getelementptr inbounds i8*, i8** %12, i64 %30
Gen:   %31 = getelementptr inbounds i8*, i8** %12, i64 %30
Operands done!
Generated:   %32 = load i8*, i8** %31, align 1
Gen:   %32 = load i8*, i8** %31, align 1
Generating MATCH
Match: 
  %arrayidx30 = getelementptr inbounds i8*, i8** %11, i64 %23
  %arrayidx39 = getelementptr inbounds i8*, i8** %11, i64 %21
Generating IDENTICAL
Generating MATCH
Match: 
  %23 = add nsw i64 %indvars.iv107, %14
  %21 = add nsw i64 %indvars.iv107, %15
Generating IDENTICAL
Generating ALTSEQ
Values:
  %14 = sext i32 %mul27 to i64
  %15 = sext i32 %mul23 to i64
Generated Version 4:
  %33 = select i1 %28, i64 %14, i64 %15
Operands done!
Generated:   %34 = add nsw i64 %indvars.iv107, %33
Gen:   %34 = add nsw i64 %indvars.iv107, %33
Operands done!
Generated:   %35 = getelementptr inbounds i8*, i8** %11, i64 %34
Gen:   %35 = getelementptr inbounds i8*, i8** %11, i64 %34
Operands done!
Generated:   store i8* %32, i8** %35, align 1
Gen:   store i8* %32, i8** %35, align 1
Graph code generated!
Root:
  store i8* %22, i8** %arrayidx30, align 8, !tbaa !16
  store i8* %24, i8** %arrayidx39, align 8, !tbaa !16
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="alt: %15, %14", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="alt: %14, %15", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
7->0 
2->1 
3->2 
4->2 
5->4 
6->4 
8->7 
9->7 
5->9 
10->9 
}

Gains: 14 - 12 = 2; Width: 2; Unprofitable; make_funny_pointers
  %indvars.iv111 = phi i64 [ 0, %for.cond43.preheader ], [ %indvars.iv.next112, %for.body45 ]
looking for reduction
looking for reduction
Attempting Group:
  store i8* %25, i8** %arrayidx49, align 8, !tbaa !16
looking for reduction
Done Loop Roller: 0/2
Optimizing: start_pass_main
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, i8**, i32*, i32)* @process_data_context_main, void (%struct.jpeg_decompress_struct*, i8**, i32*, i32)** %process_data, align 8, !tbaa !13
  %indvars.iv117.i = phi i64 [ %indvars.iv.next118.i, %for.inc53.i ], [ 0, %if.then ]
  %compptr.0.i = phi %struct.jpeg_component_info* [ %incdec.ptr.i, %for.inc53.i ], [ %5, %if.then ]
looking for reduction
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body12.i ], [ 0, %for.body.i ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %21, i8** %arrayidx18.i, align 8, !tbaa !22
Attempting Group:
  store i8* %21, i8** %arrayidx16.i, align 8, !tbaa !22
  %indvars.iv107.i = phi i64 [ 0, %for.cond19.preheader.i ], [ %indvars.iv.next108.i, %for.body22.i ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
  store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
Creating Node
  store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
  store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %25 = load i8*, i8** %arrayidx26.i, align 8, !tbaa !22
  %27 = load i8*, i8** %arrayidx35.i, align 8, !tbaa !22
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx26.i = getelementptr inbounds i8*, i8** %14, i64 %24
  %arrayidx35.i = getelementptr inbounds i8*, i8** %14, i64 %26
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %14 = load i8**, i8*** %arrayidx8.i, align 8, !tbaa !22
  %14 = load i8**, i8*** %arrayidx8.i, align 8, !tbaa !22
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %24 = add nsw i64 %indvars.iv107.i, %18
  %26 = add nsw i64 %indvars.iv107.i, %17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %indvars.iv107.i = phi i64 [ 0, %for.cond19.preheader.i ], [ %indvars.iv.next108.i, %for.body22.i ]
  %indvars.iv107.i = phi i64 [ 0, %for.cond19.preheader.i ], [ %indvars.iv.next108.i, %for.body22.i ]
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %18 = sext i32 %mul23.i to i64
  %17 = sext i32 %mul27.i to i64
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %18 = sext i32 %mul23.i to i64
Alt Seq
Creating Node
  %arrayidx30.i = getelementptr inbounds i8*, i8** %13, i64 %26
  %arrayidx39.i = getelementptr inbounds i8*, i8** %13, i64 %24
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %13 = load i8**, i8*** %arrayidx6.i, align 8, !tbaa !22
  %13 = load i8**, i8*** %arrayidx6.i, align 8, !tbaa !22
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %26 = add nsw i64 %indvars.iv107.i, %17
  %24 = add nsw i64 %indvars.iv107.i, %18
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %17 = sext i32 %mul27.i to i64
  %18 = sext i32 %mul23.i to i64
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %17 = sext i32 %mul27.i to i64
Alt Seq
ScheduleNode: {
  %25 = load i8*, i8** %arrayidx26.i, align 8, !tbaa !22
}
ScheduleNode: {
  store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
}
ScheduleNode: {
  %27 = load i8*, i8** %arrayidx35.i, align 8, !tbaa !22
}
ScheduleNode: {
  store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
}
ScheduleNode: {
  %25 = load i8*, i8** %arrayidx26.i, align 8, !tbaa !22
}
Count: 1
Start:   %24 = add nsw i64 %indvars.iv107.i, %18
Non-memory:   %24 = add nsw i64 %indvars.iv107.i, %18
Non-memory:   %arrayidx26.i = getelementptr inbounds i8*, i8** %14, i64 %24
Processing:   %25 = load i8*, i8** %arrayidx26.i, align 8, !tbaa !22
Count: 1
Found:   %25 = load i8*, i8** %arrayidx26.i, align 8, !tbaa !22
ScheduleNode: {
  store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
}
Non-memory:   %26 = add nsw i64 %indvars.iv107.i, %17
Non-memory:   %arrayidx30.i = getelementptr inbounds i8*, i8** %13, i64 %26
Processing:   store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
Count: 1
Found:   store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
ScheduleNode: {
  %27 = load i8*, i8** %arrayidx35.i, align 8, !tbaa !22
}
Non-memory:   %arrayidx35.i = getelementptr inbounds i8*, i8** %14, i64 %26
Processing:   %27 = load i8*, i8** %arrayidx35.i, align 8, !tbaa !22
Count: 1
Found:   %27 = load i8*, i8** %arrayidx35.i, align 8, !tbaa !22
ScheduleNode: {
  store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
}
Non-memory:   %arrayidx39.i = getelementptr inbounds i8*, i8** %13, i64 %24
Processing:   store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
Count: 1
Found:   store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
I:   %indvars.iv.next108.i = add nuw nsw i64 %indvars.iv107.i, 1
Last:   br label %for.cond19.i, !llvm.loop !25
Schedulable: 1
Loop Rolling: start_pass_main
Generating tree
Generating MATCH
Match: 
  store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
  store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
Generating MATCH
Match: 
  %25 = load i8*, i8** %arrayidx26.i, align 8, !tbaa !22
  %27 = load i8*, i8** %arrayidx35.i, align 8, !tbaa !22
Generating MATCH
Match: 
  %arrayidx26.i = getelementptr inbounds i8*, i8** %14, i64 %24
  %arrayidx35.i = getelementptr inbounds i8*, i8** %14, i64 %26
Generating IDENTICAL
Generating MATCH
Match: 
  %24 = add nsw i64 %indvars.iv107.i, %18
  %26 = add nsw i64 %indvars.iv107.i, %17
Generating IDENTICAL
Generating ALTSEQ
Values:
  %18 = sext i32 %mul23.i to i64
  %17 = sext i32 %mul27.i to i64
Generated Version 4:
  %34 = icmp eq i8 %33, 0
  %35 = select i1 %34, i64 %18, i64 %17
Operands done!
Generated:   %36 = add nsw i64 %indvars.iv107.i, %35
Gen:   %36 = add nsw i64 %indvars.iv107.i, %35
Operands done!
Generated:   %37 = getelementptr inbounds i8*, i8** %14, i64 %36
Gen:   %37 = getelementptr inbounds i8*, i8** %14, i64 %36
Operands done!
Generated:   %38 = load i8*, i8** %37, align 1
Gen:   %38 = load i8*, i8** %37, align 1
Generating MATCH
Match: 
  %arrayidx30.i = getelementptr inbounds i8*, i8** %13, i64 %26
  %arrayidx39.i = getelementptr inbounds i8*, i8** %13, i64 %24
Generating IDENTICAL
Generating MATCH
Match: 
  %26 = add nsw i64 %indvars.iv107.i, %17
  %24 = add nsw i64 %indvars.iv107.i, %18
Generating IDENTICAL
Generating ALTSEQ
Values:
  %17 = sext i32 %mul27.i to i64
  %18 = sext i32 %mul23.i to i64
Generated Version 4:
  %39 = select i1 %34, i64 %17, i64 %18
Operands done!
Generated:   %40 = add nsw i64 %indvars.iv107.i, %39
Gen:   %40 = add nsw i64 %indvars.iv107.i, %39
Operands done!
Generated:   %41 = getelementptr inbounds i8*, i8** %13, i64 %40
Gen:   %41 = getelementptr inbounds i8*, i8** %13, i64 %40
Operands done!
Generated:   store i8* %38, i8** %41, align 1
Gen:   store i8* %38, i8** %41, align 1
Graph code generated!
Root:
  store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
  store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="alt: %18, %17", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="alt: %17, %18", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
7->0 
2->1 
3->2 
4->2 
5->4 
6->4 
8->7 
9->7 
5->9 
10->9 
}

Gains: 14 - 12 = 2; Width: 2; Unprofitable; start_pass_main
Trying AGAIN
Creating Node
  store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
  store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %25 = load i8*, i8** %arrayidx26.i, align 8, !tbaa !22
  %27 = load i8*, i8** %arrayidx35.i, align 8, !tbaa !22
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx26.i = getelementptr inbounds i8*, i8** %14, i64 %24
  %arrayidx35.i = getelementptr inbounds i8*, i8** %14, i64 %26
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %14 = load i8**, i8*** %arrayidx8.i, align 8, !tbaa !22
  %14 = load i8**, i8*** %arrayidx8.i, align 8, !tbaa !22
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %24 = add nsw i64 %indvars.iv107.i, %18
  %26 = add nsw i64 %indvars.iv107.i, %17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %indvars.iv107.i = phi i64 [ 0, %for.cond19.preheader.i ], [ %indvars.iv.next108.i, %for.body22.i ]
  %indvars.iv107.i = phi i64 [ 0, %for.cond19.preheader.i ], [ %indvars.iv.next108.i, %for.body22.i ]
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %18 = sext i32 %mul23.i to i64
  %17 = sext i32 %mul27.i to i64
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %18 = sext i32 %mul23.i to i64
Alt Seq
Creating Node
  %arrayidx30.i = getelementptr inbounds i8*, i8** %13, i64 %26
  %arrayidx39.i = getelementptr inbounds i8*, i8** %13, i64 %24
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %13 = load i8**, i8*** %arrayidx6.i, align 8, !tbaa !22
  %13 = load i8**, i8*** %arrayidx6.i, align 8, !tbaa !22
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %26 = add nsw i64 %indvars.iv107.i, %17
  %24 = add nsw i64 %indvars.iv107.i, %18
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %17 = sext i32 %mul27.i to i64
  %18 = sext i32 %mul23.i to i64
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %17 = sext i32 %mul27.i to i64
Alt Seq
ScheduleNode: {
  %25 = load i8*, i8** %arrayidx26.i, align 8, !tbaa !22
}
ScheduleNode: {
  store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
}
ScheduleNode: {
  %27 = load i8*, i8** %arrayidx35.i, align 8, !tbaa !22
}
ScheduleNode: {
  store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
}
ScheduleNode: {
  %25 = load i8*, i8** %arrayidx26.i, align 8, !tbaa !22
}
Count: 1
Start:   %24 = add nsw i64 %indvars.iv107.i, %18
Non-memory:   %24 = add nsw i64 %indvars.iv107.i, %18
Non-memory:   %arrayidx26.i = getelementptr inbounds i8*, i8** %14, i64 %24
Processing:   %25 = load i8*, i8** %arrayidx26.i, align 8, !tbaa !22
Count: 1
Found:   %25 = load i8*, i8** %arrayidx26.i, align 8, !tbaa !22
ScheduleNode: {
  store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
}
Non-memory:   %26 = add nsw i64 %indvars.iv107.i, %17
Non-memory:   %arrayidx30.i = getelementptr inbounds i8*, i8** %13, i64 %26
Processing:   store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
Count: 1
Found:   store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
ScheduleNode: {
  %27 = load i8*, i8** %arrayidx35.i, align 8, !tbaa !22
}
Non-memory:   %arrayidx35.i = getelementptr inbounds i8*, i8** %14, i64 %26
Processing:   %27 = load i8*, i8** %arrayidx35.i, align 8, !tbaa !22
Count: 1
Found:   %27 = load i8*, i8** %arrayidx35.i, align 8, !tbaa !22
ScheduleNode: {
  store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
}
Non-memory:   %arrayidx39.i = getelementptr inbounds i8*, i8** %13, i64 %24
Processing:   store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
Count: 1
Found:   store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
I:   %indvars.iv.next108.i = add nuw nsw i64 %indvars.iv107.i, 1
Last:   br label %for.cond19.i, !llvm.loop !25
Schedulable: 1
Loop Rolling: start_pass_main
Generating tree
Generating MATCH
Match: 
  store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
  store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
Generating MATCH
Match: 
  %25 = load i8*, i8** %arrayidx26.i, align 8, !tbaa !22
  %27 = load i8*, i8** %arrayidx35.i, align 8, !tbaa !22
Generating MATCH
Match: 
  %arrayidx26.i = getelementptr inbounds i8*, i8** %14, i64 %24
  %arrayidx35.i = getelementptr inbounds i8*, i8** %14, i64 %26
Generating IDENTICAL
Generating MATCH
Match: 
  %24 = add nsw i64 %indvars.iv107.i, %18
  %26 = add nsw i64 %indvars.iv107.i, %17
Generating IDENTICAL
Generating ALTSEQ
Values:
  %18 = sext i32 %mul23.i to i64
  %17 = sext i32 %mul27.i to i64
Generated Version 4:
  %34 = icmp eq i8 %33, 0
  %35 = select i1 %34, i64 %18, i64 %17
Operands done!
Generated:   %36 = add nsw i64 %indvars.iv107.i, %35
Gen:   %36 = add nsw i64 %indvars.iv107.i, %35
Operands done!
Generated:   %37 = getelementptr inbounds i8*, i8** %14, i64 %36
Gen:   %37 = getelementptr inbounds i8*, i8** %14, i64 %36
Operands done!
Generated:   %38 = load i8*, i8** %37, align 1
Gen:   %38 = load i8*, i8** %37, align 1
Generating MATCH
Match: 
  %arrayidx30.i = getelementptr inbounds i8*, i8** %13, i64 %26
  %arrayidx39.i = getelementptr inbounds i8*, i8** %13, i64 %24
Generating IDENTICAL
Generating MATCH
Match: 
  %26 = add nsw i64 %indvars.iv107.i, %17
  %24 = add nsw i64 %indvars.iv107.i, %18
Generating IDENTICAL
Generating ALTSEQ
Values:
  %17 = sext i32 %mul27.i to i64
  %18 = sext i32 %mul23.i to i64
Generated Version 4:
  %39 = select i1 %34, i64 %17, i64 %18
Operands done!
Generated:   %40 = add nsw i64 %indvars.iv107.i, %39
Gen:   %40 = add nsw i64 %indvars.iv107.i, %39
Operands done!
Generated:   %41 = getelementptr inbounds i8*, i8** %13, i64 %40
Gen:   %41 = getelementptr inbounds i8*, i8** %13, i64 %40
Operands done!
Generated:   store i8* %38, i8** %41, align 1
Gen:   store i8* %38, i8** %41, align 1
Graph code generated!
Root:
  store i8* %25, i8** %arrayidx30.i, align 8, !tbaa !22
  store i8* %27, i8** %arrayidx39.i, align 8, !tbaa !22
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="alt: %18, %17", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="alt: %17, %18", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
7->0 
2->1 
3->2 
4->2 
5->4 
6->4 
8->7 
9->7 
5->9 
10->9 
}

Gains: 14 - 12 = 2; Width: 2; Unprofitable; start_pass_main
  %indvars.iv111.i = phi i64 [ 0, %for.cond43.preheader.i ], [ %indvars.iv.next112.i, %for.body45.i ]
looking for reduction
looking for reduction
Attempting Group:
  store i8* %28, i8** %arrayidx49.i, align 8, !tbaa !22
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %whichptr, align 8, !tbaa !28
  store i32 0, i32* %context_state, align 4, !tbaa !29
  store i32 0, i32* %iMCU_row_ctr, align 4, !tbaa !30
Creating Node
  store i32 0, i32* %whichptr, align 8, !tbaa !28
  store i32 0, i32* %context_state, align 4, !tbaa !29
  store i32 0, i32* %iMCU_row_ctr, align 4, !tbaa !30
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
i32 0
i32 0
i32 0
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
  %whichptr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 5
  %context_state = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 6
  %iMCU_row_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 8
Match: 0
3 x 3
Final Match: 0
  %whichptr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 5
  %context_state = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 6
  %iMCU_row_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 8
GEPSeq2
%struct.my_main_controller = type { %struct.jpeg_d_main_controller, [10 x i8**], i32, i32, [2 x i8***], i32, i32, i32, i32 }
BinOP?
  %whichptr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 5
Mismatching
ScheduleNode: {
  store i32 0, i32* %whichptr, align 8, !tbaa !28
}
ScheduleNode: {
  store i32 0, i32* %context_state, align 4, !tbaa !29
}
ScheduleNode: {
  store i32 0, i32* %iMCU_row_ctr, align 4, !tbaa !30
}
ScheduleNode: {
  store i32 0, i32* %whichptr, align 8, !tbaa !28
}
Count: 1
Start:   store i32 0, i32* %whichptr, align 8, !tbaa !28
Processing:   store i32 0, i32* %whichptr, align 8, !tbaa !28
Count: 1
Found:   store i32 0, i32* %whichptr, align 8, !tbaa !28
ScheduleNode: {
  store i32 0, i32* %context_state, align 4, !tbaa !29
}
Non-memory:   %context_state = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 6
Processing:   store i32 0, i32* %context_state, align 4, !tbaa !29
Count: 1
Found:   store i32 0, i32* %context_state, align 4, !tbaa !29
ScheduleNode: {
  store i32 0, i32* %iMCU_row_ctr, align 4, !tbaa !30
}
Non-memory:   %iMCU_row_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 8
Processing:   store i32 0, i32* %iMCU_row_ctr, align 4, !tbaa !30
Count: 1
Found:   store i32 0, i32* %iMCU_row_ctr, align 4, !tbaa !30
I:   br label %if.end
Last:   br label %if.end
Schedulable: 1
Loop Rolling: start_pass_main
Generating tree
Generating MATCH
Match: 
  store i32 0, i32* %whichptr, align 8, !tbaa !28
  store i32 0, i32* %context_state, align 4, !tbaa !29
  store i32 0, i32* %iMCU_row_ctr, align 4, !tbaa !30
Generating IDENTICAL
Generating Mismatch
Mismatched Values:
inst:   %whichptr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 5
inst:   %context_state = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 6
inst:   %iMCU_row_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 8
Non constants
Array Type: 3:i32*
Created array:   %33 = alloca i32*, i8 3, align 8
Gen:   %39 = load i32*, i32** %38, align 8
Operands done!
Generated:   store i32 0, i32* %39, align 1
Gen:   store i32 0, i32* %39, align 1
Graph code generated!
Root:
  store i32 0, i32* %whichptr, align 8, !tbaa !28
  store i32 0, i32* %context_state, align 4, !tbaa !29
  store i32 0, i32* %iMCU_row_ctr, align 4, !tbaa !30
Root size: 3
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}

Gains: 6 - 43 = -37; Width: 3; Unprofitable; start_pass_main
Trying AGAIN
Trying AGAIN
Trying AGAIN
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, i8**, i32*, i32)* @process_data_simple_main, void (%struct.jpeg_decompress_struct*, i8**, i32*, i32)** %process_data2, align 8, !tbaa !13
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %buffer_full, align 8, !tbaa !31
  store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !32
Creating Node
  store i32 0, i32* %buffer_full, align 8, !tbaa !31
  store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !32
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 0
i32 0
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %buffer_full = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 2
  %rowgroup_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 3
Match: 0
2 x 2
Final Match: 0
  %buffer_full = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 2
  %rowgroup_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 3
GEPSeq2
%struct.my_main_controller = type { %struct.jpeg_d_main_controller, [10 x i8**], i32, i32, [2 x i8***], i32, i32, i32, i32 }
BinOP?
  %buffer_full = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 2
Alt Seq
ScheduleNode: {
  store i32 0, i32* %buffer_full, align 8, !tbaa !31
}
ScheduleNode: {
  store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !32
}
ScheduleNode: {
  store i32 0, i32* %buffer_full, align 8, !tbaa !31
}
Count: 1
Start:   store i32 0, i32* %buffer_full, align 8, !tbaa !31
Processing:   store i32 0, i32* %buffer_full, align 8, !tbaa !31
Count: 1
Found:   store i32 0, i32* %buffer_full, align 8, !tbaa !31
ScheduleNode: {
  store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !32
}
Non-memory:   %rowgroup_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 3
Processing:   store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !32
Count: 1
Found:   store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !32
I:   br label %sw.epilog
Last:   br label %sw.epilog
Schedulable: 1
Loop Rolling: start_pass_main
Generating tree
Generating MATCH
Match: 
  store i32 0, i32* %buffer_full, align 8, !tbaa !31
  store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !32
Generating IDENTICAL
Generating ALTSEQ
Values:
  %buffer_full = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 2
  %rowgroup_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 3
Generated Version 4:
  %34 = icmp eq i8 %33, 0
  %35 = select i1 %34, i32* %buffer_full, i32* %rowgroup_ctr
Operands done!
Generated:   store i32 0, i32* %35, align 1
Gen:   store i32 0, i32* %35, align 1
Graph code generated!
Root:
  store i32 0, i32* %buffer_full, align 8, !tbaa !31
  store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !32
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %buffer_full, %rowgroup_ctr", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 5 = -1; Width: 2; Unprofitable; start_pass_main
Trying AGAIN
Trying AGAIN
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, i8**, i32*, i32)* @process_data_crank_post, void (%struct.jpeg_decompress_struct*, i8**, i32*, i32)** %process_data5, align 8, !tbaa !13
looking for reduction
looking for reduction
Attempting Group:
  store i32 4, i32* %msg_code, align 8, !tbaa !34
looking for reduction
Done Loop Roller: 0/4
Optimizing: set_bottom_pointers
  %indvars.iv50 = phi i64 [ %indvars.iv.next51, %for.inc18 ], [ 0, %entry ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %incdec.ptr, %for.inc18 ], [ %2, %entry ]
looking for reduction
looking for reduction
looking for reduction
  %add = add nsw i32 %div4, 1
Attempting Group:
  store i32 %add, i32* %rowgroups_avail, align 8, !tbaa !17
  %sub12.pre-phi = phi i32 [ %.pre, %for.body.if.end5_crit_edge ], [ %sub, %if.then3 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body11 ], [ 0, %if.end5 ]
looking for reduction
looking for reduction
Attempting Group:
  store i8* %15, i8** %arrayidx17, align 8, !tbaa !21
looking for reduction
Done Loop Roller: 0/0
Nothing found in: set_bottom_pointers
Optimizing: set_wraparound_pointers
  %indvars.iv86 = phi i64 [ %indvars.iv.next87, %for.inc38 ], [ 0, %entry ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %incdec.ptr, %for.inc38 ], [ %3, %entry ]
looking for reduction
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body9 ], [ 0, %for.body ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %19, i8** %arrayidx23, align 8, !tbaa !16
  store i8* %22, i8** %arrayidx37, align 8, !tbaa !16
Attempting Group:
  store i8* %17, i8** %arrayidx15, align 8, !tbaa !16
  store i8* %20, i8** %arrayidx30, align 8, !tbaa !16
Group:
  store i8* %19, i8** %arrayidx23, align 8, !tbaa !16
  store i8* %22, i8** %arrayidx37, align 8, !tbaa !16
Creating Node
  store i8* %17, i8** %arrayidx15, align 8, !tbaa !16
  store i8* %20, i8** %arrayidx30, align 8, !tbaa !16
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %17 = load i8*, i8** %arrayidx13, align 8, !tbaa !16
  %20 = load i8*, i8** %arrayidx25, align 8, !tbaa !16
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx13 = getelementptr inbounds i8*, i8** %9, i64 %16
  %arrayidx25 = getelementptr inbounds i8*, i8** %9, i64 %indvars.iv
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %9 = load i8**, i8*** %arrayidx2, align 8, !tbaa !16
  %9 = load i8**, i8*** %arrayidx2, align 8, !tbaa !16
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %16 = add nsw i64 %indvars.iv, %14
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body9 ], [ 0, %for.body ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %16 = add nsw i64 %indvars.iv, %14
BinOp Seq
Creating Node
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body9 ], [ 0, %for.body ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body9 ], [ 0, %for.body ]
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %14 = sext i32 %mul10 to i64
i64 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %14 = sext i32 %mul10 to i64
Alt Seq
Creating Node
  %arrayidx15 = getelementptr inbounds i8*, i8** %9, i64 %18
  %arrayidx30 = getelementptr inbounds i8*, i8** %9, i64 %21
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %18 = sub nsw i64 %indvars.iv, %13
  %21 = add nsw i64 %indvars.iv, %12
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %18 = sub nsw i64 %indvars.iv, %13
BinOp Seq
Creating Node
  %18 = sub nsw i64 %indvars.iv, %13
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body9 ], [ 0, %for.body ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %18 = sub nsw i64 %indvars.iv, %13
BinOp Seq
Creating Node
  %13 = sext i32 %div to i64
i64 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %13 = sext i32 %div to i64
Alt Seq
Creating Node
i64 0
  %12 = sext i32 %mul27 to i64
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 0
Alt Seq
Creating Node
  store i8* %19, i8** %arrayidx23, align 8, !tbaa !16
  store i8* %22, i8** %arrayidx37, align 8, !tbaa !16
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %19 = load i8*, i8** %arrayidx20, align 8, !tbaa !16
  %22 = load i8*, i8** %arrayidx32, align 8, !tbaa !16
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx20 = getelementptr inbounds i8*, i8** %11, i64 %16
  %arrayidx32 = getelementptr inbounds i8*, i8** %11, i64 %indvars.iv
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %11 = load i8**, i8*** %arrayidx6, align 8, !tbaa !16
  %11 = load i8**, i8*** %arrayidx6, align 8, !tbaa !16
Match: 0
1 x 2
Final Match: 0
All the Same
Creating Node
  %arrayidx23 = getelementptr inbounds i8*, i8** %11, i64 %18
  %arrayidx37 = getelementptr inbounds i8*, i8** %11, i64 %21
Match: 1
2 x 2
Final Match: 1
Matching
Empty scheduling entries
Loop Rolling: set_wraparound_pointers
Generating tree
Generating MULTI
Generating MATCH
Match: 
  store i8* %17, i8** %arrayidx15, align 8, !tbaa !16
  store i8* %20, i8** %arrayidx30, align 8, !tbaa !16
Generating MATCH
Match: 
  %17 = load i8*, i8** %arrayidx13, align 8, !tbaa !16
  %20 = load i8*, i8** %arrayidx25, align 8, !tbaa !16
Generating MATCH
Match: 
  %arrayidx13 = getelementptr inbounds i8*, i8** %9, i64 %16
  %arrayidx25 = getelementptr inbounds i8*, i8** %9, i64 %indvars.iv
Generating IDENTICAL
Generating BINOP
Generating IDENTICAL
Generating ALTSEQ
Values:
  %14 = sext i32 %mul10 to i64
i64 0
Generated Version 4:
  %24 = icmp eq i8 %23, 0
  %25 = select i1 %24, i64 %14, i64 0
Closing BINOP
Gen:   %26 = add nsw i64 %indvars.iv, %25
Operands done!
Generated:   %27 = getelementptr inbounds i8*, i8** %9, i64 %26
Gen:   %27 = getelementptr inbounds i8*, i8** %9, i64 %26
Operands done!
Generated:   %28 = load i8*, i8** %27, align 1
Gen:   %28 = load i8*, i8** %27, align 1
Generating MATCH
Match: 
  %arrayidx15 = getelementptr inbounds i8*, i8** %9, i64 %18
  %arrayidx30 = getelementptr inbounds i8*, i8** %9, i64 %21
Generating IDENTICAL
Generating BINOP
Generating BINOP
Generating IDENTICAL
Generating ALTSEQ
Values:
  %13 = sext i32 %div to i64
i64 0
Generated Version 4:
  %29 = select i1 %24, i64 %13, i64 0
Closing BINOP
Gen:   %30 = sub nsw i64 %indvars.iv, %29
Generating ALTSEQ
Values:
i64 0
  %12 = sext i32 %mul27 to i64
Generated Version 4:
  %31 = select i1 %24, i64 0, i64 %12
Closing BINOP
Gen:   %32 = add nsw i64 %30, %31
Operands done!
Generated:   %33 = getelementptr inbounds i8*, i8** %9, i64 %32
Gen:   %33 = getelementptr inbounds i8*, i8** %9, i64 %32
Operands done!
Generated:   store i8* %28, i8** %33, align 1
Gen:   store i8* %28, i8** %33, align 1
Generating MATCH
Match: 
  store i8* %19, i8** %arrayidx23, align 8, !tbaa !16
  store i8* %22, i8** %arrayidx37, align 8, !tbaa !16
Generating MATCH
Match: 
  %19 = load i8*, i8** %arrayidx20, align 8, !tbaa !16
  %22 = load i8*, i8** %arrayidx32, align 8, !tbaa !16
Generating MATCH
Match: 
  %arrayidx20 = getelementptr inbounds i8*, i8** %11, i64 %16
  %arrayidx32 = getelementptr inbounds i8*, i8** %11, i64 %indvars.iv
Generating IDENTICAL
Operands done!
Generated:   %34 = getelementptr inbounds i8*, i8** %11, i64 %26
Gen:   %34 = getelementptr inbounds i8*, i8** %11, i64 %26
Operands done!
Generated:   %35 = load i8*, i8** %34, align 1
Gen:   %35 = load i8*, i8** %34, align 1
Generating MATCH
Match: 
  %arrayidx23 = getelementptr inbounds i8*, i8** %11, i64 %18
  %arrayidx37 = getelementptr inbounds i8*, i8** %11, i64 %21
Generating IDENTICAL
Operands done!
Generated:   %36 = getelementptr inbounds i8*, i8** %11, i64 %32
Gen:   %36 = getelementptr inbounds i8*, i8** %11, i64 %32
Operands done!
Generated:   store i8* %35, i8** %36, align 1
Gen:   store i8* %35, i8** %36, align 1
Graph code generated!
Root:
Root size: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="alt: %14, 0", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="alt: %13, 0", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="alt: 0, %12", style="filled" , fillcolor="#8ae18a", shape=box];
12 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
13 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
15 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
16 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
7->0 
2->1 
3->2 
4->2 
5->4 
6->4 
3->7 
8->7 
9->8 
11->8 
5->9 
10->9 
13->12 
16->12 
14->13 
15->14 
4->14 
15->16 
8->16 
}

Gains: 27 - 21 = 6; Width: 0; Profitable; set_wraparound_pointers

for.body9:                                        ; preds = %for.cond7
  %16 = add nsw i64 %indvars.iv, %14
  %arrayidx13 = getelementptr inbounds i8*, i8** %9, i64 %16
  %17 = load i8*, i8** %arrayidx13, align 8, !tbaa !16
  %18 = sub nsw i64 %indvars.iv, %13
  %arrayidx15 = getelementptr inbounds i8*, i8** %9, i64 %18
  %arrayidx20 = getelementptr inbounds i8*, i8** %11, i64 %16
  %19 = load i8*, i8** %arrayidx20, align 8, !tbaa !16
  %arrayidx23 = getelementptr inbounds i8*, i8** %11, i64 %18
  %arrayidx25 = getelementptr inbounds i8*, i8** %9, i64 %indvars.iv
  %20 = load i8*, i8** %arrayidx25, align 8, !tbaa !16
  %21 = add nsw i64 %indvars.iv, %12
  %arrayidx30 = getelementptr inbounds i8*, i8** %9, i64 %21
  %arrayidx32 = getelementptr inbounds i8*, i8** %11, i64 %indvars.iv
  %22 = load i8*, i8** %arrayidx32, align 8, !tbaa !16
  %arrayidx37 = getelementptr inbounds i8*, i8** %11, i64 %21
  br label %rolled.pre


rolled.pre:                                       ; preds = %for.body9
  br label %rolled.loop


rolled.loop:                                      ; preds = %rolled.pre, %rolled.loop
  %23 = phi i8 [ 0, %rolled.pre ], [ %37, %rolled.loop ]
  %24 = icmp eq i8 %23, 0
  %25 = select i1 %24, i64 %14, i64 0
  %26 = add nsw i64 %indvars.iv, %25
  %27 = getelementptr inbounds i8*, i8** %9, i64 %26
  %28 = load i8*, i8** %27, align 1
  %29 = select i1 %24, i64 %13, i64 0
  %30 = sub nsw i64 %indvars.iv, %29
  %31 = select i1 %24, i64 0, i64 %12
  %32 = add nsw i64 %30, %31
  %33 = getelementptr inbounds i8*, i8** %9, i64 %32
  store i8* %28, i8** %33, align 1
  %34 = getelementptr inbounds i8*, i8** %11, i64 %26
  %35 = load i8*, i8** %34, align 1
  %36 = getelementptr inbounds i8*, i8** %11, i64 %32
  store i8* %35, i8** %36, align 1
  %37 = add i8 %23, 1
  %38 = icmp ne i8 %37, 2
  br i1 %38, label %rolled.loop, label %rolled.exit


rolled.exit:                                      ; preds = %rolled.loop
  store i8* %17, i8** %arrayidx15, align 8, !tbaa !16
  store i8* %19, i8** %arrayidx23, align 8, !tbaa !16
  store i8* %20, i8** %arrayidx30, align 8, !tbaa !16
  store i8* %22, i8** %arrayidx37, align 8, !tbaa !16
  %39 = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond7, !llvm.loop !19

Done!
looking for reduction
Done Loop Roller: 1/1
Optimizing: process_data_context_main
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %inc = add i32 %7, 1
Attempting Group:
  store i32 1, i32* %buffer_full, align 8, !tbaa !10
  store i32 %inc, i32* %iMCU_row_ctr, align 4, !tbaa !18
Creating Node
  store i32 1, i32* %buffer_full, align 8, !tbaa !10
  store i32 %inc, i32* %iMCU_row_ctr, align 4, !tbaa !18
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 1
  %inc = add i32 %7, 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
BinOp Seq
Creating Node
i32 1
  %7 = load i32, i32* %iMCU_row_ctr, align 4, !tbaa !18
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Alt Seq
Creating Node
i32 0
i32 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Int Seq
Creating Node
  %buffer_full = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 2
  %iMCU_row_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 8
Match: 0
2 x 2
Final Match: 0
  %buffer_full = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 2
  %iMCU_row_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 8
GEPSeq2
%struct.my_main_controller = type { %struct.jpeg_d_main_controller, [10 x i8**], i32, i32, [2 x i8***], i32, i32, i32, i32 }
BinOP?
  %buffer_full = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 2
Alt Seq
ScheduleNode: {
  store i32 1, i32* %buffer_full, align 8, !tbaa !10
}
ScheduleNode: {
  store i32 %inc, i32* %iMCU_row_ctr, align 4, !tbaa !18
}
ScheduleNode: {
  store i32 1, i32* %buffer_full, align 8, !tbaa !10
}
Count: 1
Start:   store i32 1, i32* %buffer_full, align 8, !tbaa !10
Processing:   store i32 1, i32* %buffer_full, align 8, !tbaa !10
Count: 1
Found:   store i32 1, i32* %buffer_full, align 8, !tbaa !10
ScheduleNode: {
  store i32 %inc, i32* %iMCU_row_ctr, align 4, !tbaa !18
}
Non-memory:   %iMCU_row_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 8
Processing:   %7 = load i32, i32* %iMCU_row_ctr, align 4, !tbaa !18
Count: 1
Not found:   %7 = load i32, i32* %iMCU_row_ctr, align 4, !tbaa !18
Read/Write memory
I:   %7 = load i32, i32* %iMCU_row_ctr, align 4, !tbaa !18
Last:   br label %if.end4
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: 1, %7", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %buffer_full, %iMCU_row_ctr", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
}


if.end:                                           ; preds = %if.then
  store i32 1, i32* %buffer_full, align 8, !tbaa !10
  %iMCU_row_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 8
  %7 = load i32, i32* %iMCU_row_ctr, align 4, !tbaa !18
  %inc = add i32 %7, 1
  store i32 %inc, i32* %iMCU_row_ctr, align 4, !tbaa !18
  br label %if.end4

Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %context_state, align 4, !tbaa !19
looking for reduction
looking for reduction
  %sub = add nsw i32 %17, -1
looking for reduction
Attempting Group:
  store i32 0, i32* %rowgroup_ctr18, align 4, !tbaa !24
  store i32 %sub, i32* %rowgroups_avail19, align 8, !tbaa !23
Creating Node
  store i32 0, i32* %rowgroup_ctr18, align 4, !tbaa !24
  store i32 %sub, i32* %rowgroups_avail19, align 8, !tbaa !23
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 0
  %sub = add nsw i32 %17, -1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
BinOp Seq
Creating Node
i32 0
  %17 = load i32, i32* %min_DCT_scaled_size, align 4, !tbaa !26
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
i32 0
i32 -1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Int Seq
Creating Node
  %rowgroup_ctr18 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 3
  %rowgroups_avail19 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 7
Match: 0
2 x 2
Final Match: 0
  %rowgroup_ctr18 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 3
  %rowgroups_avail19 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 7
GEPSeq2
%struct.my_main_controller = type { %struct.jpeg_d_main_controller, [10 x i8**], i32, i32, [2 x i8***], i32, i32, i32, i32 }
BinOP?
  %rowgroup_ctr18 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 3
Alt Seq
ScheduleNode: {
  store i32 0, i32* %rowgroup_ctr18, align 4, !tbaa !24
}
ScheduleNode: {
  store i32 %sub, i32* %rowgroups_avail19, align 8, !tbaa !23
}
ScheduleNode: {
  store i32 0, i32* %rowgroup_ctr18, align 4, !tbaa !24
}
Count: 1
Start:   store i32 0, i32* %rowgroup_ctr18, align 4, !tbaa !24
Processing:   store i32 0, i32* %rowgroup_ctr18, align 4, !tbaa !24
Count: 1
Found:   store i32 0, i32* %rowgroup_ctr18, align 4, !tbaa !24
ScheduleNode: {
  store i32 %sub, i32* %rowgroups_avail19, align 8, !tbaa !23
}
Non-memory:   %min_DCT_scaled_size = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 59
Processing:   %17 = load i32, i32* %min_DCT_scaled_size, align 4, !tbaa !26
Count: 1
Not found:   %17 = load i32, i32* %min_DCT_scaled_size, align 4, !tbaa !26
Read/Write memory
I:   %17 = load i32, i32* %min_DCT_scaled_size, align 4, !tbaa !26
Last:   br i1 %cmp21, label %if.then22, label %if.end23
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: 0, %17", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="0..-1, -1", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %rowgroup_ctr18, %rowgroups_avail19", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
}


sw.bb17:                                          ; preds = %if.end12, %if.end4
  %rowgroup_ctr18 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 3
  store i32 0, i32* %rowgroup_ctr18, align 4, !tbaa !24
  %min_DCT_scaled_size = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 59
  %17 = load i32, i32* %min_DCT_scaled_size, align 4, !tbaa !26
  %sub = add nsw i32 %17, -1
  %rowgroups_avail19 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 7
  store i32 %sub, i32* %rowgroups_avail19, align 8, !tbaa !23
  %iMCU_row_ctr20 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 8
  %18 = load i32, i32* %iMCU_row_ctr20, align 4, !tbaa !18
  %total_iMCU_rows = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 60
  %19 = load i32, i32* %total_iMCU_rows, align 8, !tbaa !27
  %cmp21 = icmp eq i32 %18, %19
  br i1 %cmp21, label %if.then22, label %if.end23

Trying AGAIN
Trying AGAIN
  %indvars.iv50.i = phi i64 [ %indvars.iv.next51.i, %for.inc18.i ], [ 0, %if.then22 ]
  %compptr.0.i = phi %struct.jpeg_component_info* [ %incdec.ptr.i, %for.inc18.i ], [ %21, %if.then22 ]
looking for reduction
looking for reduction
looking for reduction
  %add.i = add nsw i32 %div4.i, 1
Attempting Group:
  store i32 %add.i, i32* %rowgroups_avail.i, align 8, !tbaa !23
  %sub12.pre-phi.i = phi i32 [ %.pre.i, %for.body.if.end5_crit_edge.i ], [ %sub.i, %if.then3.i ]
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body11.i ], [ 0, %if.end5.i ]
looking for reduction
looking for reduction
Attempting Group:
  store i8* %33, i8** %arrayidx17.i, align 8, !tbaa !17
looking for reduction
Attempting Group:
  store i32 1, i32* %context_state, align 4, !tbaa !19
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %indvars.iv86.i = phi i64 [ %indvars.iv.next87.i, %for.inc38.i ], [ 0, %if.then41 ]
  %compptr.0.i103 = phi %struct.jpeg_component_info* [ %incdec.ptr.i114, %for.inc38.i ], [ %45, %if.then41 ]
looking for reduction
  %indvars.iv.i112 = phi i64 [ %73, %rolled.exit.i ], [ 0, %for.body.i111 ]
looking for reduction
  %58 = phi i8 [ %72, %rolled.loop.i ], [ 0, %rolled.loop.i.preheader ]
  %72 = add nuw nsw i8 %58, 1
looking for reduction
  %72 = add nuw nsw i8 %58, 1
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %70, i8** %71, align 1
Attempting Group:
  store i8* %63, i8** %68, align 1
looking for reduction
  %xor = xor i32 %74, 1
looking for reduction
looking for reduction
  %add = add nsw i32 %75, 1
looking for reduction
  %add48 = add nsw i32 %75, 2
looking for reduction
Attempting Group:
  store i32 %xor, i32* %whichptr29, align 8, !tbaa !16
  store i32 0, i32* %buffer_full, align 8, !tbaa !10
  store i32 %add, i32* %rowgroup_ctr32, align 4, !tbaa !24
  store i32 %add48, i32* %rowgroups_avail33, align 8, !tbaa !23
  store i32 2, i32* %context_state, align 4, !tbaa !19
Creating Node
  store i32 %xor, i32* %whichptr29, align 8, !tbaa !16
  store i32 0, i32* %buffer_full, align 8, !tbaa !10
  store i32 %add, i32* %rowgroup_ctr32, align 4, !tbaa !24
  store i32 %add48, i32* %rowgroups_avail33, align 8, !tbaa !23
  store i32 2, i32* %context_state, align 4, !tbaa !19
Match: 1
5 x 5
Final Match: 1
Matching
Creating Node
  %xor = xor i32 %74, 1
i32 0
  %add = add nsw i32 %75, 1
  %add48 = add nsw i32 %75, 2
i32 2
Match: 0
5 x 5
Final Match: 0
GEPSeq2
BinOP?
  %xor = xor i32 %74, 1
BinOp Seq
Creating Node
  %xor = xor i32 %74, 1
i32 0
  %75 = load i32, i32* %min_DCT_scaled_size45, align 4, !tbaa !26
  %75 = load i32, i32* %min_DCT_scaled_size45, align 4, !tbaa !26
i32 2
Match: 0
4 x 5
Final Match: 0
GEPSeq2
BinOP?
  %xor = xor i32 %74, 1
BinOp Seq
Creating Node
  %74 = load i32, i32* %whichptr29, align 8, !tbaa !16
i32 0
  %75 = load i32, i32* %min_DCT_scaled_size45, align 4, !tbaa !26
  %75 = load i32, i32* %min_DCT_scaled_size45, align 4, !tbaa !26
i32 2
Match: 0
4 x 5
Final Match: 0
GEPSeq2
BinOP?
  %74 = load i32, i32* %whichptr29, align 8, !tbaa !16
Mismatching
Creating Node
i32 1
i32 0
i32 0
i32 0
i32 0
Match: 0
2 x 5
Final Match: 0
GEPSeq2
BinOP?
i32 1
Mismatching
Creating Node
i32 0
i32 0
i32 1
i32 2
i32 0
Match: 0
3 x 5
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %whichptr29 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 5
  %buffer_full = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 2
  %rowgroup_ctr32 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 3
  %rowgroups_avail33 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 7
  %context_state = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 6
Match: 0
5 x 5
Final Match: 0
  %whichptr29 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 5
  %buffer_full = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 2
  %rowgroup_ctr32 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 3
  %rowgroups_avail33 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 7
  %context_state = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 6
GEPSeq2
%struct.my_main_controller = type { %struct.jpeg_d_main_controller, [10 x i8**], i32, i32, [2 x i8***], i32, i32, i32, i32 }
BinOP?
  %whichptr29 = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 5
Mismatching
ScheduleNode: {
  store i32 %xor, i32* %whichptr29, align 8, !tbaa !16
}
ScheduleNode: {
  store i32 0, i32* %buffer_full, align 8, !tbaa !10
}
ScheduleNode: {
  store i32 %add, i32* %rowgroup_ctr32, align 4, !tbaa !24
}
ScheduleNode: {
  store i32 %add48, i32* %rowgroups_avail33, align 8, !tbaa !23
}
ScheduleNode: {
  store i32 2, i32* %context_state, align 4, !tbaa !19
}
ScheduleNode: {
  store i32 %xor, i32* %whichptr29, align 8, !tbaa !16
}
Count: 1
Start:   %xor = xor i32 %74, 1
Non-memory:   %xor = xor i32 %74, 1
Processing:   store i32 %xor, i32* %whichptr29, align 8, !tbaa !16
Count: 1
Found:   store i32 %xor, i32* %whichptr29, align 8, !tbaa !16
ScheduleNode: {
  store i32 0, i32* %buffer_full, align 8, !tbaa !10
}
Processing:   store i32 0, i32* %buffer_full, align 8, !tbaa !10
Count: 1
Found:   store i32 0, i32* %buffer_full, align 8, !tbaa !10
ScheduleNode: {
  store i32 %add, i32* %rowgroup_ctr32, align 4, !tbaa !24
}
Non-memory:   %min_DCT_scaled_size45 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 59
Processing:   %75 = load i32, i32* %min_DCT_scaled_size45, align 4, !tbaa !26
Count: 1
Not found:   %75 = load i32, i32* %min_DCT_scaled_size45, align 4, !tbaa !26
Read/Write memory
I:   %75 = load i32, i32* %min_DCT_scaled_size45, align 4, !tbaa !26
Last:   br label %cleanup
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="xor seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
4 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
5 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
6 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
6->0 
2->1 
5->1 
3->2 
4->2 
}


if.end42:                                         ; preds = %if.end42.loopexit, %if.end38
  %74 = load i32, i32* %whichptr29, align 8, !tbaa !16
  %xor = xor i32 %74, 1
  store i32 %xor, i32* %whichptr29, align 8, !tbaa !16
  store i32 0, i32* %buffer_full, align 8, !tbaa !10
  %min_DCT_scaled_size45 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 59
  %75 = load i32, i32* %min_DCT_scaled_size45, align 4, !tbaa !26
  %add = add nsw i32 %75, 1
  store i32 %add, i32* %rowgroup_ctr32, align 4, !tbaa !24
  %add48 = add nsw i32 %75, 2
  store i32 %add48, i32* %rowgroups_avail33, align 8, !tbaa !23
  store i32 2, i32* %context_state, align 4, !tbaa !19
  br label %cleanup

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
looking for reduction
Done Loop Roller: 0/0
Nothing found in: process_data_context_main
Optimizing: process_data_simple_main
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %buffer_full, align 8, !tbaa !10
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %buffer_full, align 8, !tbaa !10
  store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !20
Creating Node
  store i32 0, i32* %buffer_full, align 8, !tbaa !10
  store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !20
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 0
i32 0
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %buffer_full = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 2
  %rowgroup_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 3
Match: 0
2 x 2
Final Match: 0
  %buffer_full = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 2
  %rowgroup_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 3
GEPSeq2
%struct.my_main_controller = type { %struct.jpeg_d_main_controller, [10 x i8**], i32, i32, [2 x i8***], i32, i32, i32, i32 }
BinOP?
  %buffer_full = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 2
Alt Seq
ScheduleNode: {
  store i32 0, i32* %buffer_full, align 8, !tbaa !10
}
ScheduleNode: {
  store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !20
}
ScheduleNode: {
  store i32 0, i32* %buffer_full, align 8, !tbaa !10
}
Count: 1
Start:   store i32 0, i32* %buffer_full, align 8, !tbaa !10
Processing:   store i32 0, i32* %buffer_full, align 8, !tbaa !10
Count: 1
Found:   store i32 0, i32* %buffer_full, align 8, !tbaa !10
ScheduleNode: {
  store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !20
}
Processing:   store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !20
Count: 1
Found:   store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !20
I:   br label %cleanup
Last:   br label %cleanup
Schedulable: 1
Loop Rolling: process_data_simple_main
Generating tree
Generating MATCH
Match: 
  store i32 0, i32* %buffer_full, align 8, !tbaa !10
  store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !20
Generating IDENTICAL
Generating ALTSEQ
Values:
  %buffer_full = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 2
  %rowgroup_ctr = getelementptr inbounds %struct.my_main_controller, %struct.my_main_controller* %1, i64 0, i32 3
Generated Version 4:
  %10 = icmp eq i8 %9, 0
  %11 = select i1 %10, i32* %buffer_full, i32* %rowgroup_ctr
Operands done!
Generated:   store i32 0, i32* %11, align 1
Gen:   store i32 0, i32* %11, align 1
Graph code generated!
Root:
  store i32 0, i32* %buffer_full, align 8, !tbaa !10
  store i32 0, i32* %rowgroup_ctr, align 4, !tbaa !20
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %buffer_full, %rowgroup_ctr", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 5 = -1; Width: 2; Unprofitable; process_data_simple_main
Trying AGAIN
Trying AGAIN
looking for reduction
Done Loop Roller: 0/1
Optimizing: process_data_crank_post
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 0/0
Nothing found in: process_data_crank_post
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jdapistd.c -o src/jdapistd.o   -mllvm -reroll-loops=3
Optimizing: output_pass_setup
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %output_scanline, align 8, !tbaa !13
  store i32 204, i32* %global_state, align 4, !tbaa !2
Creating Node
  store i32 0, i32* %output_scanline, align 8, !tbaa !13
  store i32 204, i32* %global_state, align 4, !tbaa !2
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 0
i32 204
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Int Seq
Creating Node
  %output_scanline = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 33
  %global_state = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 4
Match: 0
2 x 2
Final Match: 0
  %output_scanline = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 33
  %global_state = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 4
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %output_scanline = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 33
Alt Seq
ScheduleNode: {
  store i32 0, i32* %output_scanline, align 8, !tbaa !13
}
ScheduleNode: {
  store i32 204, i32* %global_state, align 4, !tbaa !2
}
ScheduleNode: {
  store i32 0, i32* %output_scanline, align 8, !tbaa !13
}
Count: 1
Start:   store i32 0, i32* %output_scanline, align 8, !tbaa !13
Processing:   store i32 0, i32* %output_scanline, align 8, !tbaa !13
Count: 1
Found:   store i32 0, i32* %output_scanline, align 8, !tbaa !13
ScheduleNode: {
  store i32 204, i32* %global_state, align 4, !tbaa !2
}
Processing:   store i32 204, i32* %global_state, align 4, !tbaa !2
Count: 1
Found:   store i32 204, i32* %global_state, align 4, !tbaa !2
I:   br label %if.end
Last:   br label %if.end
Schedulable: 1
Loop Rolling: output_pass_setup
Generating tree
Generating MATCH
Match: 
  store i32 0, i32* %output_scanline, align 8, !tbaa !13
  store i32 204, i32* %global_state, align 4, !tbaa !2
Generating INTSEQ
Gen:   %23 = add i32 %22, 0
Generating ALTSEQ
Values:
  %output_scanline = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 33
  %global_state = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 4
Generated Version 4:
  %24 = icmp eq i8 %20, 0
  %25 = select i1 %24, i32* %output_scanline, i32* %global_state
Operands done!
Generated:   store i32 %23, i32* %25, align 1
Gen:   store i32 %23, i32* %25, align 1
Graph code generated!
Root:
  store i32 0, i32* %output_scanline, align 8, !tbaa !13
  store i32 204, i32* %global_state, align 4, !tbaa !2
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="0..204, 204", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %output_scanline, %global_state", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; output_pass_setup
Trying AGAIN
Trying AGAIN
looking for reduction
  %6 = phi i32 [ %.pre, %while.cond3.preheader ], [ %14, %if.end16 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !17
  store i64 %conv12, i64* %pass_limit, align 8, !tbaa !20
Creating Node
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !17
  store i64 %conv12, i64* %pass_limit, align 8, !tbaa !20
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv = zext i32 %6 to i64
  %conv12 = zext i32 %7 to i64
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %6 = phi i32 [ %.pre, %while.cond3.preheader ], [ %14, %if.end16 ]
  %7 = load i32, i32* %output_height, align 4, !tbaa !15
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %6 = phi i32 [ %.pre, %while.cond3.preheader ], [ %14, %if.end16 ]
Alt Seq
Creating Node
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %8, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %8, i64 0, i32 2
Match: 0
2 x 2
Final Match: 0
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %8, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %8, i64 0, i32 2
GEPSeq2
%struct.jpeg_progress_mgr = type { {}*, i64, i64, i32, i32 }
BinOP?
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %8, i64 0, i32 1
Alt Seq
ScheduleNode: {
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !17
}
ScheduleNode: {
  store i64 %conv12, i64* %pass_limit, align 8, !tbaa !20
}
ScheduleNode: {
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !17
}
Count: 1
Start:   %conv = zext i32 %6 to i64
Non-memory:   %conv = zext i32 %6 to i64
Non-memory:   %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %8, i64 0, i32 1
Processing:   store i64 %conv, i64* %pass_counter, align 8, !tbaa !17
Count: 1
Found:   store i64 %conv, i64* %pass_counter, align 8, !tbaa !17
ScheduleNode: {
  store i64 %conv12, i64* %pass_limit, align 8, !tbaa !20
}
Non-memory:   %conv12 = zext i32 %7 to i64
Non-memory:   %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %8, i64 0, i32 2
Processing:   store i64 %conv12, i64* %pass_limit, align 8, !tbaa !20
Count: 1
Found:   store i64 %conv12, i64* %pass_limit, align 8, !tbaa !20
I:   %10 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %9, align 8, !tbaa !21
Last:   br label %if.end16
Schedulable: 1
Loop Rolling: output_pass_setup
Generating tree
Generating MATCH
Match: 
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !17
  store i64 %conv12, i64* %pass_limit, align 8, !tbaa !20
Generating MATCH
Match: 
  %conv = zext i32 %6 to i64
  %conv12 = zext i32 %7 to i64
Generating ALTSEQ
Values:
  %6 = phi i32 [ %.pre, %while.cond3.preheader ], [ %14, %if.end16 ]
  %7 = load i32, i32* %output_height, align 4, !tbaa !15
Generated Version 4:
  %21 = icmp eq i8 %20, 0
  %22 = select i1 %21, i32 %6, i32 %7
Operands done!
Generated:   %23 = zext i32 %22 to i64
Gen:   %23 = zext i32 %22 to i64
Generating ALTSEQ
Values:
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %8, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %8, i64 0, i32 2
Generated Version 4:
  %24 = select i1 %21, i64* %pass_counter, i64* %pass_limit
Operands done!
Generated:   store i64 %23, i64* %24, align 1
Gen:   store i64 %23, i64* %24, align 1
Graph code generated!
Root:
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !17
  store i64 %conv12, i64* %pass_limit, align 8, !tbaa !20
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %6, %7", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %pass_counter, %pass_limit", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
3->0 
2->1 
}

Gains: 6 - 7 = -1; Width: 2; Unprofitable; output_pass_setup
Trying AGAIN
Trying AGAIN
  %11 = phi i32 [ %.pre61, %if.then8 ], [ %6, %while.body6 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %output_scanline4, align 8, !tbaa !13
looking for reduction
Attempting Group:
  store i32 %cond, i32* %global_state, align 4, !tbaa !2
  %retval.3 = phi i32 [ 1, %while.end28 ], [ 0, %return.loopexit ]
looking for reduction
Done Loop Roller: 0/2
Optimizing: jpeg_start_decompress
looking for reduction
looking for reduction
Attempting Group:
  tail call void @jinit_master_decompress(%struct.jpeg_decompress_struct* nonnull %cinfo) #3
looking for reduction
Attempting Group:
  store i32 207, i32* %global_state, align 4, !tbaa !2
looking for reduction
Attempting Group:
  store i32 203, i32* %global_state, align 4, !tbaa !2
looking for reduction
  %6 = phi %struct.jpeg_progress_mgr* [ %.pre, %for.cond.preheader ], [ %10, %cleanup ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %or.cond = and i1 %12, %cmp24.not
looking for reduction
  %inc = add nsw i64 %13, 1
looking for reduction
Attempting Group:
  store i64 %inc, i64* %pass_counter, align 8, !tbaa !19
looking for reduction
  %add = add nsw i64 %14, %conv
Attempting Group:
  store i64 %add, i64* %pass_limit, align 8, !tbaa !20
looking for reduction
Attempting Group:
  store i32 %16, i32* %output_scan_number, align 4, !tbaa !23
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 18, i32* %msg_code, align 8, !tbaa !25
  store i32 %0, i32* %arrayidx, align 4, !tbaa !27
Creating Node
  store i32 18, i32* %msg_code, align 8, !tbaa !25
  store i32 %0, i32* %arrayidx, align 4, !tbaa !27
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 18
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !27
}
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !25
}
Count: 1
Start:   store i32 18, i32* %msg_code, align 8, !tbaa !25
Processing:   store i32 18, i32* %msg_code, align 8, !tbaa !25
Count: 1
Found:   store i32 18, i32* %msg_code, align 8, !tbaa !25
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !27
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %0, i32* %arrayidx, align 4, !tbaa !27
Count: 1
Found:   store i32 %0, i32* %arrayidx, align 4, !tbaa !27
I:   %18 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !24
Last:   br label %if.end45
Schedulable: 1
Loop Rolling: jpeg_start_decompress
Generating tree
Generating MATCH
Match: 
  store i32 18, i32* %msg_code, align 8, !tbaa !25
  store i32 %0, i32* %arrayidx, align 4, !tbaa !27
Generating ALTSEQ
Values:
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Generated Version 4:
  %22 = icmp eq i8 %21, 0
  %23 = select i1 %22, i32 18, i32 %0
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %24 = select i1 %22, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %23, i32* %24, align 1
Gen:   store i32 %23, i32* %24, align 1
Graph code generated!
Root:
  store i32 18, i32* %msg_code, align 8, !tbaa !25
  store i32 %0, i32* %arrayidx, align 4, !tbaa !27
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 18, %0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jpeg_start_decompress
Trying AGAIN
Trying AGAIN
looking for reduction
Attempting Group:
  %call46 = tail call fastcc i32 @output_pass_setup(%struct.jpeg_decompress_struct* nonnull %cinfo) #4
  %retval.2 = phi i32 [ 1, %if.then1 ], [ %call46, %if.end45 ], [ 0, %return.loopexit ]
looking for reduction
Done Loop Roller: 0/1
Optimizing: jpeg_read_scanlines
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %1, i32* %arrayidx, align 4, !tbaa !14
Creating Node
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %1, i32* %arrayidx, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 18
  %1 = load i32, i32* %global_state, align 4, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 18
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %1, i32* %arrayidx, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
Count: 1
Start:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Processing:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Count: 1
Found:   store i32 18, i32* %msg_code, align 8, !tbaa !11
ScheduleNode: {
  store i32 %1, i32* %arrayidx, align 4, !tbaa !14
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %1, i32* %arrayidx, align 4, !tbaa !14
Count: 1
Found:   store i32 %1, i32* %arrayidx, align 4, !tbaa !14
I:   %3 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !10
Last:   br label %if.end
Schedulable: 1
Loop Rolling: jpeg_read_scanlines
Generating tree
Generating MATCH
Match: 
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %1, i32* %arrayidx, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 18
  %1 = load i32, i32* %global_state, align 4, !tbaa !2
Generated Version 4:
  %20 = icmp eq i8 %19, 0
  %21 = select i1 %20, i32 18, i32 %1
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %22 = select i1 %20, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %21, i32* %22, align 1
Gen:   store i32 %21, i32* %22, align 1
Graph code generated!
Root:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %1, i32* %arrayidx, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 18, %1", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jpeg_read_scanlines
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 119, i32* %msg_code7, align 8, !tbaa !11
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Creating Node
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv = zext i32 %6 to i64
  %conv15 = zext i32 %7 to i64
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %6 = load i32, i32* %output_scanline, align 8, !tbaa !16
  %7 = load i32, i32* %output_height, align 4, !tbaa !17
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %6 = load i32, i32* %output_scanline, align 8, !tbaa !16
Alt Seq
Creating Node
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 2
Match: 0
2 x 2
Final Match: 0
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 2
GEPSeq2
%struct.jpeg_progress_mgr = type { {}*, i64, i64, i32, i32 }
BinOP?
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 1
Alt Seq
ScheduleNode: {
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
}
ScheduleNode: {
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
}
ScheduleNode: {
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
}
Count: 1
Start:   %conv = zext i32 %6 to i64
Non-memory:   %conv = zext i32 %6 to i64
Non-memory:   %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 1
Processing:   store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
Count: 1
Found:   store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
ScheduleNode: {
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
}
Non-memory:   %conv15 = zext i32 %7 to i64
Non-memory:   %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 2
Processing:   store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Count: 1
Found:   store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
I:   %13 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %12, align 8, !tbaa !23
Last:   br label %if.end19
Schedulable: 1
Loop Rolling: jpeg_read_scanlines
Generating tree
Generating MATCH
Match: 
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Generating MATCH
Match: 
  %conv = zext i32 %6 to i64
  %conv15 = zext i32 %7 to i64
Generating ALTSEQ
Values:
  %6 = load i32, i32* %output_scanline, align 8, !tbaa !16
  %7 = load i32, i32* %output_height, align 4, !tbaa !17
Generated Version 4:
  %20 = icmp eq i8 %19, 0
  %21 = select i1 %20, i32 %6, i32 %7
Operands done!
Generated:   %22 = zext i32 %21 to i64
Gen:   %22 = zext i32 %21 to i64
Generating ALTSEQ
Values:
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 2
Generated Version 4:
  %23 = select i1 %20, i64* %pass_counter, i64* %pass_limit
Operands done!
Generated:   store i64 %22, i64* %23, align 1
Gen:   store i64 %22, i64* %23, align 1
Graph code generated!
Root:
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %6, %7", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %pass_counter, %pass_limit", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
3->0 
2->1 
}

Gains: 6 - 7 = -1; Width: 2; Unprofitable; jpeg_read_scanlines
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add = add i32 %18, %17
Attempting Group:
  store i32 %add, i32* %output_scanline, align 8, !tbaa !16
Attempting Group:
  store i32 0, i32* %row_ctr, align 4, !tbaa !24
  %retval.0 = phi i32 [ 0, %if.then5 ], [ %17, %if.end19 ]
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 0/2
Optimizing: jpeg_read_raw_data
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Creating Node
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 18
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
Count: 1
Start:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Processing:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Count: 1
Found:   store i32 18, i32* %msg_code, align 8, !tbaa !11
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Count: 1
Found:   store i32 %0, i32* %arrayidx, align 4, !tbaa !14
I:   %2 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !10
Last:   br label %if.end
Schedulable: 1
Loop Rolling: jpeg_read_raw_data
Generating tree
Generating MATCH
Match: 
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Generated Version 4:
  %23 = icmp eq i8 %22, 0
  %24 = select i1 %23, i32 18, i32 %0
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %25 = select i1 %23, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %24, i32* %25, align 1
Gen:   store i32 %24, i32* %25, align 1
Graph code generated!
Root:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 18, %0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jpeg_read_raw_data
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 119, i32* %msg_code7, align 8, !tbaa !11
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Creating Node
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv = zext i32 %5 to i64
  %conv15 = zext i32 %6 to i64
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %5 = load i32, i32* %output_scanline, align 8, !tbaa !16
  %6 = load i32, i32* %output_height, align 4, !tbaa !17
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %5 = load i32, i32* %output_scanline, align 8, !tbaa !16
Alt Seq
Creating Node
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 2
Match: 0
2 x 2
Final Match: 0
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 2
GEPSeq2
%struct.jpeg_progress_mgr = type { {}*, i64, i64, i32, i32 }
BinOP?
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 1
Alt Seq
ScheduleNode: {
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
}
ScheduleNode: {
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
}
ScheduleNode: {
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
}
Count: 1
Start:   %conv = zext i32 %5 to i64
Non-memory:   %conv = zext i32 %5 to i64
Non-memory:   %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 1
Processing:   store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
Count: 1
Found:   store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
ScheduleNode: {
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
}
Non-memory:   %conv15 = zext i32 %6 to i64
Non-memory:   %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 2
Processing:   store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Count: 1
Found:   store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
I:   %12 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %11, align 8, !tbaa !23
Last:   br label %if.end19
Schedulable: 1
Loop Rolling: jpeg_read_raw_data
Generating tree
Generating MATCH
Match: 
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Generating MATCH
Match: 
  %conv = zext i32 %5 to i64
  %conv15 = zext i32 %6 to i64
Generating ALTSEQ
Values:
  %5 = load i32, i32* %output_scanline, align 8, !tbaa !16
  %6 = load i32, i32* %output_height, align 4, !tbaa !17
Generated Version 4:
  %23 = icmp eq i8 %22, 0
  %24 = select i1 %23, i32 %5, i32 %6
Operands done!
Generated:   %25 = zext i32 %24 to i64
Gen:   %25 = zext i32 %24 to i64
Generating ALTSEQ
Values:
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 2
Generated Version 4:
  %26 = select i1 %23, i64* %pass_counter, i64* %pass_limit
Operands done!
Generated:   store i64 %25, i64* %26, align 1
Gen:   store i64 %25, i64* %26, align 1
Graph code generated!
Root:
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %5, %6", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %pass_counter, %pass_limit", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
3->0 
2->1 
}

Gains: 6 - 7 = -1; Width: 2; Unprofitable; jpeg_read_raw_data
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 21, i32* %msg_code24, align 8, !tbaa !11
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add = add i32 %21, %mul
Attempting Group:
  store i32 %add, i32* %output_scanline, align 8, !tbaa !16
  %retval.0 = phi i32 [ 0, %if.then5 ], [ %mul, %if.end29 ], [ 0, %if.end27 ]
looking for reduction
Done Loop Roller: 0/2
Optimizing: jpeg_start_output
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Creating Node
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 18
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
Count: 1
Start:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Processing:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Count: 1
Found:   store i32 18, i32* %msg_code, align 8, !tbaa !11
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Count: 1
Found:   store i32 %0, i32* %arrayidx, align 4, !tbaa !14
I:   %2 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !10
Last:   br label %if.end
Schedulable: 1
Loop Rolling: jpeg_start_output
Generating tree
Generating MATCH
Match: 
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Generated Version 4:
  %10 = icmp eq i8 %9, 0
  %11 = select i1 %10, i32 18, i32 %0
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %12 = select i1 %10, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %11, i32* %12, align 1
Gen:   store i32 %11, i32* %12, align 1
Graph code generated!
Root:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 18, %0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jpeg_start_output
Trying AGAIN
Trying AGAIN
looking for reduction
  %scan_number.addr.1 = phi i32 [ %spec.select, %if.end ], [ %spec.select28, %land.lhs.true9 ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %scan_number.addr.1, i32* %output_scan_number, align 4, !tbaa !20
Attempting Group:
  %call = tail call fastcc i32 @output_pass_setup(%struct.jpeg_decompress_struct* nonnull %cinfo) #4
Done Loop Roller: 0/1
Optimizing: jpeg_finish_output
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 208, i32* %global_state, align 4, !tbaa !2
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 18, i32* %msg_code, align 8, !tbaa !15
  store i32 %0, i32* %arrayidx, align 4, !tbaa !18
Creating Node
  store i32 18, i32* %msg_code, align 8, !tbaa !15
  store i32 %0, i32* %arrayidx, align 4, !tbaa !18
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 18
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %4, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %4, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %4, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %4, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %4, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !15
}
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !18
}
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !15
}
Count: 1
Start:   store i32 18, i32* %msg_code, align 8, !tbaa !15
Processing:   store i32 18, i32* %msg_code, align 8, !tbaa !15
Count: 1
Found:   store i32 18, i32* %msg_code, align 8, !tbaa !15
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !18
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %4, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %0, i32* %arrayidx, align 4, !tbaa !18
Count: 1
Found:   store i32 %0, i32* %arrayidx, align 4, !tbaa !18
I:   %5 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !14
Last:   br label %if.end10
Schedulable: 1
Loop Rolling: jpeg_finish_output
Generating tree
Generating MATCH
Match: 
  store i32 18, i32* %msg_code, align 8, !tbaa !15
  store i32 %0, i32* %arrayidx, align 4, !tbaa !18
Generating ALTSEQ
Values:
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Generated Version 4:
  %14 = icmp eq i8 %13, 0
  %15 = select i1 %14, i32 18, i32 %0
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %4, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %4, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %16 = select i1 %14, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %15, i32* %16, align 1
Gen:   store i32 %15, i32* %16, align 1
Graph code generated!
Root:
  store i32 18, i32* %msg_code, align 8, !tbaa !15
  store i32 %0, i32* %arrayidx, align 4, !tbaa !18
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 18, %0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jpeg_finish_output
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 207, i32* %global_state, align 4, !tbaa !2
  %retval.0 = phi i32 [ 1, %while.end ], [ 0, %return.loopexit ]
looking for reduction
Done Loop Roller: 0/1
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jdhuff.c -o src/jdhuff.o   -mllvm -reroll-loops=3
src/jdhuff.c:379:13: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
        ~~~~^
src/jdhuff.c:379:28: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
                       ~~~~^
src/jdhuff.c:379:43: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
                                      ~~~~^
src/jdhuff.c:379:58: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
                                                     ~~~~^
src/jdhuff.c:380:10: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
     ~~~~^
src/jdhuff.c:380:25: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
                    ~~~~^
src/jdhuff.c:380:40: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
                                   ~~~~^
src/jdhuff.c:380:55: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
                                                  ~~~~^
src/jdhuff.c:381:10: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
     ~~~~^
src/jdhuff.c:381:25: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
                    ~~~~^
src/jdhuff.c:381:41: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
                                    ~~~~^
src/jdhuff.c:381:57: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
                                                    ~~~~^
src/jdhuff.c:382:10: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };
     ~~~~^
src/jdhuff.c:382:26: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };
                     ~~~~^
src/jdhuff.c:382:42: warning: shifting a negative signed value is undefined [-Wshift-negative-value]
    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };
                                     ~~~~^
Optimizing: jpeg_make_d_derived_tbl
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %call, i8** %6, align 8, !tbaa !2
  %8 = phi %struct.d_derived_tbl* [ %7, %if.then ], [ %2, %entry ]
looking for reduction
Attempting Group:
  store %struct.JHUFF_TBL* %htbl, %struct.JHUFF_TBL** %pub, align 8, !tbaa !14
  %indvars.iv179 = phi i64 [ %indvars.iv.next180, %for.inc10 ], [ 1, %if.end ]
  %p.0 = phi i32 [ %11, %for.inc10 ], [ 0, %if.end ]
  %l.0 = phi i32 [ %inc11, %for.inc10 ], [ 1, %if.end ]
looking for reduction
  %indvars.iv176 = phi i64 [ %10, %for.cond2.preheader ], [ %indvars.iv.next177, %for.body5 ]
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv6, i8* %arrayidx8, align 1, !tbaa !16
  %p.0.lcssa = phi i32 [ %p.0, %for.cond ]
looking for reduction
Attempting Group:
  store i8 0, i8* %arrayidx14, align 1, !tbaa !16
  %13 = phi i8 [ %12, %for.end12 ], [ %.pre, %while.end ]
  %p.2 = phi i64 [ 0, %for.end12 ], [ %indvars.iv174.lcssa, %while.end ]
  %si.0 = phi i32 [ %conv16, %for.end12 ], [ %inc30, %while.end ]
  %code.0 = phi i32 [ 0, %for.end12 ], [ %shl, %while.end ]
looking for reduction
  %14 = phi i8 [ %13, %while.cond19.preheader ], [ %.pre182, %while.body25 ]
  %indvars.iv174 = phi i64 [ %idxprom17, %while.cond19.preheader ], [ %indvars.iv.next175, %while.body25 ]
  %code.1 = phi i32 [ %code.0, %while.cond19.preheader ], [ %inc29, %while.body25 ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 %code.1, i32* %arrayidx28, align 4, !tbaa !20
  %indvars.iv174.lcssa = phi i64 [ %indvars.iv174, %while.cond19 ]
  %code.1.lcssa = phi i32 [ %code.1, %while.cond19 ]
  %indvars.iv171 = phi i64 [ %indvars.iv.next172, %for.inc61 ], [ 1, %for.cond32.preheader ]
  %p.4 = phi i32 [ %p.5, %for.inc61 ], [ 0, %for.cond32.preheader ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %p.4, i32* %arrayidx42, align 4, !tbaa !20
  %conv54.sink = phi i64 [ %conv54, %if.then40 ], [ -1, %for.body35 ]
  %p.5 = phi i32 [ %add, %if.then40 ], [ %p.4, %for.body35 ]
looking for reduction
Attempting Group:
  store i64 %conv54.sink, i64* %19, align 8
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i64 1048575, i64* %arrayidx65, align 8, !tbaa !23
Attempting Group:
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 8 dereferenceable(1024) %20, i8 0, i64 1024, i1 false)
  %indvars.iv168 = phi i64 [ %indvars.iv.next169, %for.inc102 ], [ 1, %for.end63 ]
  %p.6 = phi i64 [ %indvars.iv166.lcssa, %for.inc102 ], [ 0, %for.end63 ]
looking for reduction
  %indvars.iv166 = phi i64 [ %23, %for.cond70.preheader ], [ %indvars.iv.next167, %for.inc98 ]
  %i.1 = phi i32 [ 1, %for.cond70.preheader ], [ %inc99, %for.inc98 ]
looking for reduction
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body87 ], [ %27, %for.body77 ]
  %ctr.0 = phi i32 [ %dec, %for.body87 ], [ %shl83, %for.body77 ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %24, i32* %arrayidx90, align 4, !tbaa !20
  %indvars.iv166.lcssa = phi i64 [ %indvars.iv166, %for.cond70 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 0/0
Nothing found in: jpeg_make_d_derived_tbl
Optimizing: jpeg_fill_bit_buffer
  %get_buffer.addr.0 = phi i64 [ %get_buffer, %entry ], [ %or, %if.end59 ]
  %bits_left.addr.0 = phi i32 [ %bits_left, %entry ], [ %add, %if.end59 ]
  %next_input_byte.0 = phi i8* [ %0, %entry ], [ %next_input_byte.5, %if.end59 ]
  %bytes_in_buffer.0 = phi i64 [ %1, %entry ], [ %bytes_in_buffer.5, %if.end59 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %next_input_byte.1 = phi i8* [ %8, %if.end8 ], [ %next_input_byte.0, %if.end ]
  %bytes_in_buffer.1 = phi i64 [ %9, %if.end8 ], [ %bytes_in_buffer.0, %if.end ]
looking for reduction
  %next_input_byte.2 = phi i8* [ %incdec.ptr38, %if.end36 ], [ %incdec.ptr, %do.body.preheader ]
  %bytes_in_buffer.2 = phi i64 [ %dec37, %if.end36 ], [ %dec, %do.body.preheader ]
looking for reduction
looking for reduction
looking for reduction
  %next_input_byte.3 = phi i8* [ %16, %if.end29 ], [ %next_input_byte.2, %do.body ]
  %bytes_in_buffer.3 = phi i64 [ %17, %if.end29 ], [ %bytes_in_buffer.2, %do.body ]
  %dec37.lcssa = phi i64 [ %dec37, %if.end36 ]
  %incdec.ptr38.lcssa = phi i8* [ %incdec.ptr38, %if.end36 ]
  %.lcssa = phi i8 [ %18, %if.end36 ]
looking for reduction
Attempting Group:
  store i32 %conv39, i32* %unread_marker, align 8, !tbaa !10
  %next_input_byte.4 = phi i8* [ %next_input_byte.0, %while.body ], [ %incdec.ptr38.lcssa, %if.else ]
  %bytes_in_buffer.4 = phi i64 [ %bytes_in_buffer.0, %while.body ], [ %dec37.lcssa, %if.else ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %25, align 4, !tbaa !22
Attempting Group:
  store i32 113, i32* %msg_code, align 8, !tbaa !24
  %dec37.lcssa131 = phi i64 [ %dec37, %if.end36 ]
  %incdec.ptr38.lcssa130 = phi i8* [ %incdec.ptr38, %if.end36 ]
  %next_input_byte.5 = phi i8* [ %incdec.ptr, %if.end15 ], [ %next_input_byte.4, %if.then51 ], [ %next_input_byte.4, %if.end49 ], [ %incdec.ptr38.lcssa130, %if.end59.loopexit ]
  %bytes_in_buffer.5 = phi i64 [ %dec, %if.end15 ], [ %bytes_in_buffer.4, %if.then51 ], [ %bytes_in_buffer.4, %if.end49 ], [ %dec37.lcssa131, %if.end59.loopexit ]
  %c.0 = phi i64 [ %conv, %if.end15 ], [ 0, %if.then51 ], [ 0, %if.end49 ], [ 255, %if.end59.loopexit ]
  %get_buffer.addr.0.lcssa = phi i64 [ %get_buffer.addr.0, %no_more_data ], [ %get_buffer.addr.0, %while.cond ]
  %bits_left.addr.0.lcssa = phi i32 [ %bits_left.addr.0, %no_more_data ], [ %bits_left.addr.0, %while.cond ]
  %next_input_byte.6 = phi i8* [ %next_input_byte.4, %no_more_data ], [ %next_input_byte.0, %while.cond ]
  %bytes_in_buffer.6 = phi i64 [ %bytes_in_buffer.4, %no_more_data ], [ %bytes_in_buffer.0, %while.cond ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %next_input_byte.6, i8** %next_input_byte1, align 8, !tbaa !2
  %retval.0 = phi i32 [ 1, %while.end ], [ 0, %cleanup.loopexit ], [ 0, %cleanup.loopexit128 ]
looking for reduction
Done Loop Roller: 0/0
Nothing found in: jpeg_fill_bit_buffer
Optimizing: jpeg_huff_decode
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  %call = tail call i32 @jpeg_fill_bit_buffer(%struct.bitread_working_state* %state, i64 %get_buffer, i32 %bits_left, i32 %min_bits) #3
  %bits_left.addr.0 = phi i32 [ %1, %if.end ], [ %bits_left, %entry ]
  %get_buffer.addr.0 = phi i64 [ %0, %if.end ], [ %get_buffer, %entry ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end19 ], [ %2, %if.end4 ]
  %bits_left.addr.1 = phi i32 [ %sub20, %if.end19 ], [ %sub, %if.end4 ]
  %get_buffer.addr.1 = phi i64 [ %get_buffer.addr.2, %if.end19 ], [ %get_buffer.addr.0, %if.end4 ]
  %code.0 = phi i64 [ %or, %if.end19 ], [ %conv6, %if.end4 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  %call13 = tail call i32 @jpeg_fill_bit_buffer(%struct.bitread_working_state* %state, i64 %get_buffer.addr.1, i32 %bits_left.addr.1, i32 1) #3
  %bits_left.addr.2 = phi i32 [ %5, %if.end16 ], [ %bits_left.addr.1, %while.body ]
  %get_buffer.addr.2 = phi i64 [ %4, %if.end16 ], [ %get_buffer.addr.1, %while.body ]
  %indvars.iv.lcssa = phi i64 [ %indvars.iv, %while.cond ]
  %bits_left.addr.1.lcssa = phi i32 [ %bits_left.addr.1, %while.cond ]
  %get_buffer.addr.1.lcssa = phi i64 [ %get_buffer.addr.1, %while.cond ]
  %code.0.lcssa = phi i64 [ %code.0, %while.cond ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i64 %get_buffer.addr.1.lcssa, i64* %get_buffer17, align 8, !tbaa !2
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 114, i32* %msg_code, align 8, !tbaa !18
  %retval.0 = phi i32 [ 0, %if.then30 ], [ %conv43, %if.end34 ], [ -1, %if.then ], [ -1, %cleanup.loopexit ]
looking for reduction
Done Loop Roller: 0/0
Nothing found in: jpeg_huff_decode
Optimizing: jinit_huff_decoder
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*)* @start_pass_huff_decoder, void (%struct.jpeg_decompress_struct*)** %start_pass, align 8, !tbaa !14
Attempting Group:
  store i8* %call, i8** %3, align 8, !tbaa !13
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
Creating Node
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
%struct.d_derived_tbl* null
%struct.d_derived_tbl* null
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %arrayidx = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %5, i64 0, i64 %indvars.iv
  %arrayidx4 = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %6, i64 0, i64 %indvars.iv
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %5 = bitcast i8* %ac_derived_tbls to [4 x %struct.d_derived_tbl*]*
  %6 = bitcast i8* %dc_derived_tbls to [4 x %struct.d_derived_tbl*]*
Match: 0
2 x 2
Final Match: 0
  %5 = bitcast i8* %ac_derived_tbls to [4 x %struct.d_derived_tbl*]*
  %6 = bitcast i8* %dc_derived_tbls to [4 x %struct.d_derived_tbl*]*
GEPSeq2
BinOP?
  %5 = bitcast i8* %ac_derived_tbls to [4 x %struct.d_derived_tbl*]*
Alt Seq
Creating Node
i64 0
i64 0
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
Match: 0
1 x 2
Final Match: 0
All the Same
ScheduleNode: {
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
}
ScheduleNode: {
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
}
ScheduleNode: {
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
}
Count: 1
Start:   %arrayidx = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %5, i64 0, i64 %indvars.iv
Non-memory:   %arrayidx = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %5, i64 0, i64 %indvars.iv
Processing:   store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
Count: 1
Found:   store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
ScheduleNode: {
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
}
Non-memory:   %arrayidx4 = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %6, i64 0, i64 %indvars.iv
Processing:   store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
Count: 1
Found:   store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
I:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
Last:   br label %for.cond, !llvm.loop !21
Schedulable: 1
Loop Rolling: jinit_huff_decoder
Generating tree
Generating MATCH
Match: 
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
Generating IDENTICAL
Generating MATCH
Match: 
  %arrayidx = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %5, i64 0, i64 %indvars.iv
  %arrayidx4 = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %6, i64 0, i64 %indvars.iv
Generating ALTSEQ
Values:
  %5 = bitcast i8* %ac_derived_tbls to [4 x %struct.d_derived_tbl*]*
  %6 = bitcast i8* %dc_derived_tbls to [4 x %struct.d_derived_tbl*]*
Generated Version 4:
  %8 = icmp eq i8 %7, 0
  %9 = select i1 %8, [4 x %struct.d_derived_tbl*]* %5, [4 x %struct.d_derived_tbl*]* %6
Generating IDENTICAL
Generating IDENTICAL
Operands done!
Generated:   %10 = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %9, i64 0, i64 %indvars.iv
Gen:   %10 = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %9, i64 0, i64 %indvars.iv
Operands done!
Generated:   store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %10, align 1
Gen:   store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %10, align 1
Graph code generated!
Root:
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="null", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %5, %6", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->2 
4->2 
5->2 
}

Gains: 6 - 6 = 0; Width: 2; Unprofitable; jinit_huff_decoder
Trying AGAIN
Creating Node
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
%struct.d_derived_tbl* null
%struct.d_derived_tbl* null
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %arrayidx = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %5, i64 0, i64 %indvars.iv
  %arrayidx4 = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %6, i64 0, i64 %indvars.iv
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %5 = bitcast i8* %ac_derived_tbls to [4 x %struct.d_derived_tbl*]*
  %6 = bitcast i8* %dc_derived_tbls to [4 x %struct.d_derived_tbl*]*
Match: 0
2 x 2
Final Match: 0
  %5 = bitcast i8* %ac_derived_tbls to [4 x %struct.d_derived_tbl*]*
  %6 = bitcast i8* %dc_derived_tbls to [4 x %struct.d_derived_tbl*]*
GEPSeq2
BinOP?
  %5 = bitcast i8* %ac_derived_tbls to [4 x %struct.d_derived_tbl*]*
Alt Seq
Creating Node
i64 0
i64 0
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
Match: 0
1 x 2
Final Match: 0
All the Same
ScheduleNode: {
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
}
ScheduleNode: {
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
}
ScheduleNode: {
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
}
Count: 1
Start:   %arrayidx = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %5, i64 0, i64 %indvars.iv
Non-memory:   %arrayidx = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %5, i64 0, i64 %indvars.iv
Processing:   store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
Count: 1
Found:   store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
ScheduleNode: {
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
}
Non-memory:   %arrayidx4 = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %6, i64 0, i64 %indvars.iv
Processing:   store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
Count: 1
Found:   store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
I:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
Last:   br label %for.cond, !llvm.loop !21
Schedulable: 1
Loop Rolling: jinit_huff_decoder
Generating tree
Generating MATCH
Match: 
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
Generating IDENTICAL
Generating MATCH
Match: 
  %arrayidx = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %5, i64 0, i64 %indvars.iv
  %arrayidx4 = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %6, i64 0, i64 %indvars.iv
Generating ALTSEQ
Values:
  %5 = bitcast i8* %ac_derived_tbls to [4 x %struct.d_derived_tbl*]*
  %6 = bitcast i8* %dc_derived_tbls to [4 x %struct.d_derived_tbl*]*
Generated Version 4:
  %8 = icmp eq i8 %7, 0
  %9 = select i1 %8, [4 x %struct.d_derived_tbl*]* %5, [4 x %struct.d_derived_tbl*]* %6
Generating IDENTICAL
Generating IDENTICAL
Operands done!
Generated:   %10 = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %9, i64 0, i64 %indvars.iv
Gen:   %10 = getelementptr inbounds [4 x %struct.d_derived_tbl*], [4 x %struct.d_derived_tbl*]* %9, i64 0, i64 %indvars.iv
Operands done!
Generated:   store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %10, align 1
Gen:   store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %10, align 1
Graph code generated!
Root:
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx, align 8, !tbaa !20
  store %struct.d_derived_tbl* null, %struct.d_derived_tbl** %arrayidx4, align 8, !tbaa !20
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="null", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %5, %6", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="phi", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->2 
4->2 
5->2 
}

Gains: 6 - 6 = 0; Width: 2; Unprofitable; jinit_huff_decoder
looking for reduction
Done Loop Roller: 0/2
Optimizing: start_pass_huff_decoder
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 118, i32* %msg_code, align 8, !tbaa !15
  %.pre-phi = phi %struct.jpeg_common_struct* [ %.pre, %lor.lhs.false5.if.end_crit_edge ], [ %8, %if.then ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end39 ], [ 0, %if.end ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 49, i32* %msg_code18, align 8, !tbaa !15
  store i32 %12, i32* %arrayidx20, align 4, !tbaa !24
Creating Node
  store i32 49, i32* %msg_code18, align 8, !tbaa !15
  store i32 %12, i32* %arrayidx20, align 4, !tbaa !24
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 49
  %12 = load i32, i32* %dc_tbl_no, align 4, !tbaa !21
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 49
Alt Seq
Creating Node
  %msg_code18 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 5
  %arrayidx20 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code18 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 5
  %arrayidx20 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code18 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 49, i32* %msg_code18, align 8, !tbaa !15
}
ScheduleNode: {
  store i32 %12, i32* %arrayidx20, align 4, !tbaa !24
}
ScheduleNode: {
  store i32 49, i32* %msg_code18, align 8, !tbaa !15
}
Count: 1
Start:   store i32 49, i32* %msg_code18, align 8, !tbaa !15
Processing:   store i32 49, i32* %msg_code18, align 8, !tbaa !15
Count: 1
Found:   store i32 49, i32* %msg_code18, align 8, !tbaa !15
ScheduleNode: {
  store i32 %12, i32* %arrayidx20, align 4, !tbaa !24
}
Non-memory:   %arrayidx20 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %12, i32* %arrayidx20, align 4, !tbaa !24
Count: 1
Found:   store i32 %12, i32* %arrayidx20, align 4, !tbaa !24
I:   %17 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err17, align 8, !tbaa !14
Last:   br label %if.end22
Schedulable: 1
Loop Rolling: start_pass_huff_decoder
Generating tree
Generating MATCH
Match: 
  store i32 49, i32* %msg_code18, align 8, !tbaa !15
  store i32 %12, i32* %arrayidx20, align 4, !tbaa !24
Generating ALTSEQ
Values:
i32 49
  %12 = load i32, i32* %dc_tbl_no, align 4, !tbaa !21
Generated Version 4:
  %29 = icmp eq i8 %28, 0
  %30 = select i1 %29, i32 49, i32 %12
Generating ALTSEQ
Values:
  %msg_code18 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 5
  %arrayidx20 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %31 = select i1 %29, i32* %msg_code18, i32* %arrayidx20
Operands done!
Generated:   store i32 %30, i32* %31, align 1
Gen:   store i32 %30, i32* %31, align 1
Graph code generated!
Root:
  store i32 49, i32* %msg_code18, align 8, !tbaa !15
  store i32 %12, i32* %arrayidx20, align 4, !tbaa !24
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 49, %12", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code18, %arrayidx20", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; start_pass_huff_decoder
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 49, i32* %msg_code32, align 8, !tbaa !15
  store i32 %13, i32* %arrayidx36, align 4, !tbaa !24
Creating Node
  store i32 49, i32* %msg_code32, align 8, !tbaa !15
  store i32 %13, i32* %arrayidx36, align 4, !tbaa !24
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 49
  %13 = load i32, i32* %ac_tbl_no, align 8, !tbaa !23
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 49
Alt Seq
Creating Node
  %msg_code32 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %21, i64 0, i32 5
  %arrayidx36 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %21, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code32 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %21, i64 0, i32 5
  %arrayidx36 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %21, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code32 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %21, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 49, i32* %msg_code32, align 8, !tbaa !15
}
ScheduleNode: {
  store i32 %13, i32* %arrayidx36, align 4, !tbaa !24
}
ScheduleNode: {
  store i32 49, i32* %msg_code32, align 8, !tbaa !15
}
Count: 1
Start:   store i32 49, i32* %msg_code32, align 8, !tbaa !15
Processing:   store i32 49, i32* %msg_code32, align 8, !tbaa !15
Count: 1
Found:   store i32 49, i32* %msg_code32, align 8, !tbaa !15
ScheduleNode: {
  store i32 %13, i32* %arrayidx36, align 4, !tbaa !24
}
Non-memory:   %arrayidx36 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %21, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %13, i32* %arrayidx36, align 4, !tbaa !24
Count: 1
Found:   store i32 %13, i32* %arrayidx36, align 4, !tbaa !24
I:   %22 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err17, align 8, !tbaa !14
Last:   br label %if.end39
Schedulable: 1
Loop Rolling: start_pass_huff_decoder
Generating tree
Generating MATCH
Match: 
  store i32 49, i32* %msg_code32, align 8, !tbaa !15
  store i32 %13, i32* %arrayidx36, align 4, !tbaa !24
Generating ALTSEQ
Values:
i32 49
  %13 = load i32, i32* %ac_tbl_no, align 8, !tbaa !23
Generated Version 4:
  %29 = icmp eq i8 %28, 0
  %30 = select i1 %29, i32 49, i32 %13
Generating ALTSEQ
Values:
  %msg_code32 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %21, i64 0, i32 5
  %arrayidx36 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %21, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %31 = select i1 %29, i32* %msg_code32, i32* %arrayidx36
Operands done!
Generated:   store i32 %30, i32* %31, align 1
Gen:   store i32 %30, i32* %31, align 1
Graph code generated!
Root:
  store i32 49, i32* %msg_code32, align 8, !tbaa !15
  store i32 %13, i32* %arrayidx36, align 4, !tbaa !24
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 49, %13", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code32, %arrayidx36", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; start_pass_huff_decoder
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %arrayidx51, align 4, !tbaa !26
Attempting Group:
  tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %24, %struct.d_derived_tbl** nonnull %arrayidx44) #4
  tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %25, %struct.d_derived_tbl** nonnull %arrayidx49) #4
Creating Node
  tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %24, %struct.d_derived_tbl** nonnull %arrayidx44) #4
  tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %25, %struct.d_derived_tbl** nonnull %arrayidx49) #4
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
%struct.jpeg_decompress_struct* %cinfo
%struct.jpeg_decompress_struct* %cinfo
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %24 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %arrayidx42, align 8, !tbaa !20
  %25 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %arrayidx47, align 8, !tbaa !20
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx42 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 40, i64 %idxprom41
  %arrayidx47 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 41, i64 %idxprom46
Match: 0
2 x 2
Final Match: 0
  %arrayidx42 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 40, i64 %idxprom41
  %arrayidx47 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 41, i64 %idxprom46
GEPSeq2
BinOP?
  %arrayidx42 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 40, i64 %idxprom41
Alt Seq
Creating Node
  %arrayidx44 = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 4, i64 %idxprom41
  %arrayidx49 = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 5, i64 %idxprom46
Match: 0
2 x 2
Final Match: 0
  %arrayidx44 = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 4, i64 %idxprom41
  %arrayidx49 = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 5, i64 %idxprom46
GEPSeq2
BinOP?
  %arrayidx44 = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 4, i64 %idxprom41
Alt Seq
Creating Node
Function: jpeg_make_d_derived_tbl
Function: jpeg_make_d_derived_tbl
Match: 1
1 x 2
Final Match: 1
All the Same
ScheduleNode: {
  %24 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %arrayidx42, align 8, !tbaa !20
}
ScheduleNode: {
  tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %24, %struct.d_derived_tbl** nonnull %arrayidx44) #4
}
ScheduleNode: {
  %25 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %arrayidx47, align 8, !tbaa !20
}
ScheduleNode: {
  tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %25, %struct.d_derived_tbl** nonnull %arrayidx49) #4
}
ScheduleNode: {
  %24 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %arrayidx42, align 8, !tbaa !20
}
Count: 1
Start:   %24 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %arrayidx42, align 8, !tbaa !20
Processing:   %24 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %arrayidx42, align 8, !tbaa !20
Count: 1
Found:   %24 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %arrayidx42, align 8, !tbaa !20
ScheduleNode: {
  tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %24, %struct.d_derived_tbl** nonnull %arrayidx44) #4
}
Non-memory:   %arrayidx44 = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 4, i64 %idxprom41
Processing:   tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %24, %struct.d_derived_tbl** nonnull %arrayidx44) #4
Count: 1
Found:   tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %24, %struct.d_derived_tbl** nonnull %arrayidx44) #4
ScheduleNode: {
  %25 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %arrayidx47, align 8, !tbaa !20
}
Non-memory:   %idxprom46 = sext i32 %13 to i64
Non-memory:   %arrayidx47 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 41, i64 %idxprom46
Processing:   %25 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %arrayidx47, align 8, !tbaa !20
Count: 1
Found:   %25 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %arrayidx47, align 8, !tbaa !20
ScheduleNode: {
  tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %25, %struct.d_derived_tbl** nonnull %arrayidx49) #4
}
Non-memory:   %arrayidx49 = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 5, i64 %idxprom46
Processing:   tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %25, %struct.d_derived_tbl** nonnull %arrayidx49) #4
Count: 1
Found:   tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %25, %struct.d_derived_tbl** nonnull %arrayidx49) #4
I:   %arrayidx51 = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 2, i32 0, i64 %indvars.iv
Last:   br label %for.cond, !llvm.loop !27
Schedulable: 1
Loop Rolling: start_pass_huff_decoder
Generating tree
Generating MATCH
Match: 
  tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %24, %struct.d_derived_tbl** nonnull %arrayidx44) #4
  tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %25, %struct.d_derived_tbl** nonnull %arrayidx49) #4
Generating IDENTICAL
Generating MATCH
Match: 
  %24 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %arrayidx42, align 8, !tbaa !20
  %25 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %arrayidx47, align 8, !tbaa !20
Generating ALTSEQ
Values:
  %arrayidx42 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 40, i64 %idxprom41
  %arrayidx47 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 41, i64 %idxprom46
Generated Version 4:
  %29 = icmp eq i8 %28, 0
  %30 = select i1 %29, %struct.JHUFF_TBL** %arrayidx42, %struct.JHUFF_TBL** %arrayidx47
Operands done!
Generated:   %31 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %30, align 1
Gen:   %31 = load %struct.JHUFF_TBL*, %struct.JHUFF_TBL** %30, align 1
Generating ALTSEQ
Values:
  %arrayidx44 = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 4, i64 %idxprom41
  %arrayidx49 = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 5, i64 %idxprom46
Generated Version 4:
  %32 = select i1 %29, %struct.d_derived_tbl** %arrayidx44, %struct.d_derived_tbl** %arrayidx49
Generating IDENTICAL
Operands done!
Generated:   tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %31, %struct.d_derived_tbl** nonnull %32) #4
Gen:   tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %31, %struct.d_derived_tbl** nonnull %32) #4
Graph code generated!
Root:
  tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %24, %struct.d_derived_tbl** nonnull %arrayidx44) #4
  tail call void @jpeg_make_d_derived_tbl(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %25, %struct.d_derived_tbl** nonnull %arrayidx49) #4
Root size: 2
digraph VTree {
0 [label="call: jpeg_make_d_derived_tbl", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="arg", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %arrayidx42, %arrayidx47", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %arrayidx44, %arrayidx49", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="func: jpeg_make_d_derived_tbl", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
4->0 
5->0 
3->2 
}

Gains: 12 - 10 = 2; Width: 2; Unprofitable; start_pass_huff_decoder
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %27, i32* %restarts_to_go, align 8, !tbaa !30
Attempting Group:
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 dereferenceable(16) %26, i8 0, i64 16, i1 false)
Done Loop Roller: 0/3
Optimizing: process_restart
looking for reduction
  %add = add i32 %4, %div
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %bits_left, align 8, !tbaa !10
Attempting Group:
  store i32 %add, i32* %discarded_bytes, align 4, !tbaa !17
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.body ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %arrayidx, align 4, !tbaa !21
looking for reduction
looking for reduction
Attempting Group:
  store i32 %8, i32* %restarts_to_go, align 8, !tbaa !25
  store i32 0, i32* %printed_eod, align 4, !tbaa !26
Creating Node
  store i32 %8, i32* %restarts_to_go, align 8, !tbaa !25
  store i32 0, i32* %printed_eod, align 4, !tbaa !26
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %8 = load i32, i32* %restart_interval, align 8, !tbaa !24
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %8 = load i32, i32* %restart_interval, align 8, !tbaa !24
Alt Seq
Creating Node
  %restarts_to_go = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 3
  %printed_eod = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 1, i32 2
Match: 0
2 x 2
Final Match: 0
  %restarts_to_go = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 3
  %printed_eod = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 1, i32 2
GEPSeq2
BinOP?
  %restarts_to_go = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 3
Alt Seq
ScheduleNode: {
  store i32 %8, i32* %restarts_to_go, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 0, i32* %printed_eod, align 4, !tbaa !26
}
ScheduleNode: {
  store i32 %8, i32* %restarts_to_go, align 8, !tbaa !25
}
Count: 1
Start:   store i32 %8, i32* %restarts_to_go, align 8, !tbaa !25
Processing:   store i32 %8, i32* %restarts_to_go, align 8, !tbaa !25
Count: 1
Found:   store i32 %8, i32* %restarts_to_go, align 8, !tbaa !25
ScheduleNode: {
  store i32 0, i32* %printed_eod, align 4, !tbaa !26
}
Non-memory:   %printed_eod = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 1, i32 2
Processing:   store i32 0, i32* %printed_eod, align 4, !tbaa !26
Count: 1
Found:   store i32 0, i32* %printed_eod, align 4, !tbaa !26
I:   br label %cleanup
Last:   br label %cleanup
Schedulable: 1
Loop Rolling: process_restart
Generating tree
Generating MATCH
Match: 
  store i32 %8, i32* %restarts_to_go, align 8, !tbaa !25
  store i32 0, i32* %printed_eod, align 4, !tbaa !26
Generating ALTSEQ
Values:
  %8 = load i32, i32* %restart_interval, align 8, !tbaa !24
i32 0
Generated Version 4:
  %10 = icmp eq i8 %9, 0
  %11 = select i1 %10, i32 %8, i32 0
Generating ALTSEQ
Values:
  %restarts_to_go = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 3
  %printed_eod = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 1, i32 2
Generated Version 4:
  %12 = select i1 %10, i32* %restarts_to_go, i32* %printed_eod
Operands done!
Generated:   store i32 %11, i32* %12, align 1
Gen:   store i32 %11, i32* %12, align 1
Graph code generated!
Root:
  store i32 %8, i32* %restarts_to_go, align 8, !tbaa !25
  store i32 0, i32* %printed_eod, align 4, !tbaa !26
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: %8, 0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %restarts_to_go, %printed_eod", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; process_restart
Trying AGAIN
Trying AGAIN
  %retval.0 = phi i32 [ 1, %for.end ], [ 0, %entry ]
looking for reduction
Done Loop Roller: 0/1
Optimizing: decode_mcu
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add.i = add i32 %8, %div.i
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %bits_left.i, align 8, !tbaa !17
Attempting Group:
  store i32 %add.i, i32* %discarded_bytes.i, align 4, !tbaa !19
  %indvars.iv.i = phi i64 [ 0, %for.cond.preheader.i ], [ %indvars.iv.next.i, %for.body.i ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %arrayidx.i, align 4, !tbaa !23
looking for reduction
looking for reduction
Attempting Group:
  store i32 %12, i32* %restarts_to_go, align 8, !tbaa !11
  store i32 0, i32* %printed_eod.i, align 4, !tbaa !26
Creating Node
  store i32 %12, i32* %restarts_to_go, align 8, !tbaa !11
  store i32 0, i32* %printed_eod.i, align 4, !tbaa !26
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %12 = load i32, i32* %restart_interval, align 8, !tbaa !10
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %12 = load i32, i32* %restart_interval, align 8, !tbaa !10
Alt Seq
Creating Node
  %restarts_to_go = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 3
  %printed_eod.i = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 1, i32 2
Match: 0
2 x 2
Final Match: 0
  %restarts_to_go = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 3
  %printed_eod.i = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 1, i32 2
GEPSeq2
BinOP?
  %restarts_to_go = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 3
Alt Seq
ScheduleNode: {
  store i32 %12, i32* %restarts_to_go, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 0, i32* %printed_eod.i, align 4, !tbaa !26
}
ScheduleNode: {
  store i32 %12, i32* %restarts_to_go, align 8, !tbaa !11
}
Count: 1
Start:   store i32 %12, i32* %restarts_to_go, align 8, !tbaa !11
Processing:   store i32 %12, i32* %restarts_to_go, align 8, !tbaa !11
Count: 1
Found:   store i32 %12, i32* %restarts_to_go, align 8, !tbaa !11
ScheduleNode: {
  store i32 0, i32* %printed_eod.i, align 4, !tbaa !26
}
Non-memory:   %printed_eod.i = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 1, i32 2
Processing:   store i32 0, i32* %printed_eod.i, align 4, !tbaa !26
Count: 1
Found:   store i32 0, i32* %printed_eod.i, align 4, !tbaa !26
I:   br label %if.end6
Last:   br label %if.end6
Schedulable: 1
Loop Rolling: decode_mcu
Generating tree
Generating MATCH
Match: 
  store i32 %12, i32* %restarts_to_go, align 8, !tbaa !11
  store i32 0, i32* %printed_eod.i, align 4, !tbaa !26
Generating ALTSEQ
Values:
  %12 = load i32, i32* %restart_interval, align 8, !tbaa !10
i32 0
Generated Version 4:
  %67 = icmp eq i8 %66, 0
  %68 = select i1 %67, i32 %12, i32 0
Generating ALTSEQ
Values:
  %restarts_to_go = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 3
  %printed_eod.i = getelementptr inbounds %struct.huff_entropy_decoder, %struct.huff_entropy_decoder* %1, i64 0, i32 1, i32 2
Generated Version 4:
  %69 = select i1 %67, i32* %restarts_to_go, i32* %printed_eod.i
Operands done!
Generated:   store i32 %68, i32* %69, align 1
Gen:   store i32 %68, i32* %69, align 1
Graph code generated!
Root:
  store i32 %12, i32* %restarts_to_go, align 8, !tbaa !11
  store i32 0, i32* %printed_eod.i, align 4, !tbaa !26
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: %12, 0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %restarts_to_go, %printed_eod.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; decode_mcu
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store %struct.jpeg_decompress_struct* %cinfo, %struct.jpeg_decompress_struct** %cinfo7, align 8, !tbaa !27
Attempting Group:
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 4 dereferenceable(16) %3, i8* nonnull align 8 dereferenceable(16) %19, i64 16, i1 false), !tbaa.struct !39
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc265 ], [ 0, %if.end6 ]
  %bits_left.0 = phi i32 [ %bits_left.21, %for.inc265 ], [ %18, %if.end6 ]
  %get_buffer.0 = phi i64 [ %get_buffer.21, %for.inc265 ], [ %17, %if.end6 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  %call27 = call i32 @jpeg_fill_bit_buffer(%struct.bitread_working_state* nonnull %br_state, i64 %get_buffer.0, i32 %bits_left.0, i32 0) #5
looking for reduction
  %bits_left.1 = phi i32 [ %30, %if.end30 ], [ %bits_left.0, %for.body ]
  %get_buffer.1 = phi i64 [ %29, %if.end30 ], [ %get_buffer.0, %for.body ]
looking for reduction
  %bits_left.2 = phi i32 [ %30, %if.end30 ], [ %bits_left.1, %if.end36 ]
  %get_buffer.2 = phi i64 [ %29, %if.end30 ], [ %get_buffer.1, %if.end36 ]
  %nb.0 = phi i32 [ 1, %if.end30 ], [ 9, %if.end36 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  %call46 = call i32 @jpeg_huff_decode(%struct.bitread_working_state* nonnull %br_state, i64 %get_buffer.2, i32 %bits_left.2, %struct.d_derived_tbl* %26, i32 %nb.0) #5
  %bits_left.4.ph = phi i32 [ %sub42, %if.then41 ], [ %34, %if.end50 ]
  %get_buffer.4.ph = phi i64 [ %get_buffer.1, %if.then41 ], [ %33, %if.end50 ]
  %s.2.ph = phi i32 [ %conv45, %if.then41 ], [ %call46, %if.end50 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  %call60 = call i32 @jpeg_fill_bit_buffer(%struct.bitread_working_state* nonnull %br_state, i64 %get_buffer.4.ph, i32 %bits_left.4.ph, i32 %s.2.ph) #5
  %bits_left.5 = phi i32 [ %36, %if.end63 ], [ %bits_left.4.ph, %if.then56 ]
  %get_buffer.5 = phi i64 [ %35, %if.end63 ], [ %get_buffer.4.ph, %if.then56 ]
looking for reduction
  %bits_left.6 = phi i32 [ %bits_left.4.ph, %cleanup.cont ], [ %sub67, %if.end66 ], [ %sub67, %cond.true ]
  %get_buffer.6 = phi i64 [ %get_buffer.4.ph, %cleanup.cont ], [ %get_buffer.5, %if.end66 ], [ %get_buffer.5, %cond.true ]
  %s.3 = phi i32 [ 0, %cleanup.cont ], [ %and72, %if.end66 ], [ %add, %cond.true ]
looking for reduction
looking for reduction
  %add85 = add nsw i32 %40, %s.3
looking for reduction
looking for reduction
Attempting Group:
  store i16 %conv89, i16* %arrayidx90, align 2, !tbaa !49
Attempting Group:
  store i32 %add85, i32* %arrayidx84, align 4, !tbaa !23
  %bits_left.7 = phi i32 [ %bits_left.13, %for.inc ], [ %bits_left.6, %for.cond94.preheader ]
  %get_buffer.7 = phi i64 [ %get_buffer.13, %for.inc ], [ %get_buffer.6, %for.cond94.preheader ]
  %k.0 = phi i32 [ %inc, %for.inc ], [ 1, %for.cond94.preheader ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  %call103 = call i32 @jpeg_fill_bit_buffer(%struct.bitread_working_state* nonnull %br_state, i64 %get_buffer.7, i32 %bits_left.7, i32 0) #5
looking for reduction
  %bits_left.8 = phi i32 [ %43, %if.end106 ], [ %bits_left.7, %for.body97 ]
  %get_buffer.8 = phi i64 [ %42, %if.end106 ], [ %get_buffer.7, %for.body97 ]
looking for reduction
  %bits_left.9 = phi i32 [ %43, %if.end106 ], [ %bits_left.8, %if.end113 ]
  %get_buffer.9 = phi i64 [ %42, %if.end106 ], [ %get_buffer.8, %if.end113 ]
  %nb98.0 = phi i32 [ 1, %if.end106 ], [ 9, %if.end113 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  %call131 = call i32 @jpeg_huff_decode(%struct.bitread_working_state* nonnull %br_state, i64 %get_buffer.9, i32 %bits_left.9, %struct.d_derived_tbl* %28, i32 %nb98.0) #5
  %bits_left.11.ph = phi i32 [ %sub125, %if.then124 ], [ %47, %if.end135 ]
  %get_buffer.11.ph = phi i64 [ %get_buffer.8, %if.then124 ], [ %46, %if.end135 ]
  %s.6.ph = phi i32 [ %conv129, %if.then124 ], [ %call131, %if.end135 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %and144 = and i32 %s.6.ph, 15
looking for reduction
Attempting Group:
  %call151 = call i32 @jpeg_fill_bit_buffer(%struct.bitread_working_state* nonnull %br_state, i64 %get_buffer.11.ph, i32 %bits_left.11.ph, i32 %and144) #5
  %bits_left.12 = phi i32 [ %49, %if.end154 ], [ %bits_left.11.ph, %if.then146 ]
  %get_buffer.12 = phi i64 [ %48, %if.end154 ], [ %get_buffer.11.ph, %if.then146 ]
looking for reduction
  %cond175 = phi i32 [ %add172, %cond.true169 ], [ %and164, %if.end157 ]
looking for reduction
Attempting Group:
  store i16 %conv176, i16* %arrayidx180, align 2, !tbaa !49
looking for reduction
  %bits_left.13 = phi i32 [ %sub158, %cond.end174 ], [ %bits_left.11.ph, %if.end185 ]
  %get_buffer.13 = phi i64 [ %get_buffer.12, %cond.end174 ], [ %get_buffer.11.ph, %if.end185 ]
  %k.1 = phi i32 [ %add147, %cond.end174 ], [ %add186, %if.end185 ]
  %bits_left.14 = phi i32 [ %bits_left.6, %skip_ACs ], [ %bits_left.20, %for.inc261 ]
  %get_buffer.14 = phi i64 [ %get_buffer.6, %skip_ACs ], [ %get_buffer.20, %for.inc261 ]
  %k.2 = phi i32 [ 1, %skip_ACs ], [ %inc262, %for.inc261 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  %call198 = call i32 @jpeg_fill_bit_buffer(%struct.bitread_working_state* nonnull %br_state, i64 %get_buffer.14, i32 %bits_left.14, i32 0) #5
looking for reduction
  %bits_left.15 = phi i32 [ %54, %if.end201 ], [ %bits_left.14, %for.body192 ]
  %get_buffer.15 = phi i64 [ %53, %if.end201 ], [ %get_buffer.14, %for.body192 ]
looking for reduction
  %bits_left.16 = phi i32 [ %54, %if.end201 ], [ %bits_left.15, %if.end208 ]
  %get_buffer.16 = phi i64 [ %53, %if.end201 ], [ %get_buffer.15, %if.end208 ]
  %nb193.0 = phi i32 [ 1, %if.end201 ], [ 9, %if.end208 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  %call226 = call i32 @jpeg_huff_decode(%struct.bitread_working_state* nonnull %br_state, i64 %get_buffer.16, i32 %bits_left.16, %struct.d_derived_tbl* %28, i32 %nb193.0) #5
  %bits_left.18.ph = phi i32 [ %sub220, %if.then219 ], [ %58, %if.end230 ]
  %get_buffer.18.ph = phi i64 [ %get_buffer.15, %if.then219 ], [ %57, %if.end230 ]
  %s.11.ph = phi i32 [ %conv224, %if.then219 ], [ %call226, %if.end230 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %and239 = and i32 %s.11.ph, 15
looking for reduction
Attempting Group:
  %call246 = call i32 @jpeg_fill_bit_buffer(%struct.bitread_working_state* nonnull %br_state, i64 %get_buffer.18.ph, i32 %bits_left.18.ph, i32 %and239) #5
  %bits_left.19 = phi i32 [ %60, %if.end249 ], [ %bits_left.18.ph, %if.then241 ]
  %get_buffer.19 = phi i64 [ %59, %if.end249 ], [ %get_buffer.18.ph, %if.then241 ]
looking for reduction
  %bits_left.20 = phi i32 [ %sub253, %if.end252 ], [ %bits_left.18.ph, %if.else254 ]
  %get_buffer.20 = phi i64 [ %get_buffer.19, %if.end252 ], [ %get_buffer.18.ph, %if.else254 ]
  %bits_left.21.ph = phi i32 [ %bits_left.18.ph, %if.else254 ], [ %bits_left.14, %for.cond189 ]
  %get_buffer.21.ph = phi i64 [ %get_buffer.18.ph, %if.else254 ], [ %get_buffer.14, %for.cond189 ]
  %bits_left.21.ph514 = phi i32 [ %bits_left.11.ph, %if.else181 ], [ %bits_left.7, %for.cond94 ]
  %get_buffer.21.ph515 = phi i64 [ %get_buffer.11.ph, %if.else181 ], [ %get_buffer.7, %for.cond94 ]
  %bits_left.21 = phi i32 [ %bits_left.21.ph, %for.inc265.loopexit ], [ %bits_left.21.ph514, %for.inc265.loopexit513 ]
  %get_buffer.21 = phi i64 [ %get_buffer.21.ph, %for.inc265.loopexit ], [ %get_buffer.21.ph515, %for.inc265.loopexit513 ]
  %bits_left.0.lcssa = phi i32 [ %bits_left.0, %for.cond ]
  %get_buffer.0.lcssa = phi i64 [ %get_buffer.0, %for.cond ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %dec = add i32 %65, -1
Attempting Group:
  store i64 %get_buffer.0.lcssa, i64* %get_buffer12, align 8, !tbaa !37
Attempting Group:
  store i8* %61, i8** %next_input_byte270, align 8, !tbaa !30
Attempting Group:
  store i32 %64, i32* %unread_marker, align 4, !tbaa !35
Attempting Group:
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 dereferenceable(16) %19, i8* nonnull align 4 dereferenceable(16) %3, i64 16, i1 false), !tbaa.struct !39
  %retval.7 = phi i32 [ 1, %for.end267 ], [ 0, %if.then2 ], [ 0, %cleanup282.loopexit ], [ 0, %cleanup282.loopexit516 ], [ 0, %cleanup282.loopexit517 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 0/1
15 warnings generated.
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jcmaster.c -o src/jcmaster.o   -mllvm -reroll-loops=3
Optimizing: initial_setup
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 31, i32* %msg_code, align 8, !tbaa !14
  %7 = phi i32 [ %.pre, %if.then ], [ %0, %lor.lhs.false4 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 40, i32* %msg_code17, align 8, !tbaa !14
  store i32 65500, i32* %arrayidx, align 4, !tbaa !18
Creating Node
  store i32 40, i32* %msg_code17, align 8, !tbaa !14
  store i32 65500, i32* %arrayidx, align 4, !tbaa !18
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 40
i32 65500
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 40
Int Seq
Creating Node
  %msg_code17 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %9, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %9, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code17 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %9, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %9, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code17 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %9, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 40, i32* %msg_code17, align 8, !tbaa !14
}
ScheduleNode: {
  store i32 65500, i32* %arrayidx, align 4, !tbaa !18
}
ScheduleNode: {
  store i32 40, i32* %msg_code17, align 8, !tbaa !14
}
Count: 1
Start:   store i32 40, i32* %msg_code17, align 8, !tbaa !14
Processing:   store i32 40, i32* %msg_code17, align 8, !tbaa !14
Count: 1
Found:   store i32 40, i32* %msg_code17, align 8, !tbaa !14
ScheduleNode: {
  store i32 65500, i32* %arrayidx, align 4, !tbaa !18
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %9, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 65500, i32* %arrayidx, align 4, !tbaa !18
Count: 1
Found:   store i32 65500, i32* %arrayidx, align 4, !tbaa !18
I:   %10 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err16, align 8, !tbaa !13
Last:   br label %if.end21
Schedulable: 1
Loop Rolling: initial_setup
Generating tree
Generating MATCH
Match: 
  store i32 40, i32* %msg_code17, align 8, !tbaa !14
  store i32 65500, i32* %arrayidx, align 4, !tbaa !18
Generating INTSEQ
Gen:   %63 = add i32 %62, 40
Generating ALTSEQ
Values:
  %msg_code17 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %9, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %9, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %64 = icmp eq i8 %60, 0
  %65 = select i1 %64, i32* %msg_code17, i32* %arrayidx
Operands done!
Generated:   store i32 %63, i32* %65, align 1
Gen:   store i32 %63, i32* %65, align 1
Graph code generated!
Root:
  store i32 40, i32* %msg_code17, align 8, !tbaa !14
  store i32 65500, i32* %arrayidx, align 4, !tbaa !18
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="40..65500, 65460", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code17, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; initial_setup
Trying AGAIN
Trying AGAIN
  %13 = phi i32 [ %.pre253, %if.then15 ], [ %8, %lor.lhs.false10 ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 69, i32* %msg_code32, align 8, !tbaa !14
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 13, i32* %msg_code40, align 8, !tbaa !14
  store i32 %19, i32* %arrayidx45, align 4, !tbaa !18
Creating Node
  store i32 13, i32* %msg_code40, align 8, !tbaa !14
  store i32 %19, i32* %arrayidx45, align 4, !tbaa !18
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 13
  %19 = load i32, i32* %data_precision, align 8, !tbaa !19
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 13
Alt Seq
Creating Node
  %msg_code40 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 5
  %arrayidx45 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code40 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 5
  %arrayidx45 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code40 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 13, i32* %msg_code40, align 8, !tbaa !14
}
ScheduleNode: {
  store i32 %19, i32* %arrayidx45, align 4, !tbaa !18
}
ScheduleNode: {
  store i32 13, i32* %msg_code40, align 8, !tbaa !14
}
Count: 1
Start:   store i32 13, i32* %msg_code40, align 8, !tbaa !14
Processing:   store i32 13, i32* %msg_code40, align 8, !tbaa !14
Count: 1
Found:   store i32 13, i32* %msg_code40, align 8, !tbaa !14
ScheduleNode: {
  store i32 %19, i32* %arrayidx45, align 4, !tbaa !18
}
Non-memory:   %arrayidx45 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %19, i32* %arrayidx45, align 4, !tbaa !18
Count: 1
Found:   store i32 %19, i32* %arrayidx45, align 4, !tbaa !18
I:   %21 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err39, align 8, !tbaa !13
Last:   br label %if.end48
Schedulable: 1
Loop Rolling: initial_setup
Generating tree
Generating MATCH
Match: 
  store i32 13, i32* %msg_code40, align 8, !tbaa !14
  store i32 %19, i32* %arrayidx45, align 4, !tbaa !18
Generating ALTSEQ
Values:
i32 13
  %19 = load i32, i32* %data_precision, align 8, !tbaa !19
Generated Version 4:
  %61 = icmp eq i8 %60, 0
  %62 = select i1 %61, i32 13, i32 %19
Generating ALTSEQ
Values:
  %msg_code40 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 5
  %arrayidx45 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %20, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %63 = select i1 %61, i32* %msg_code40, i32* %arrayidx45
Operands done!
Generated:   store i32 %62, i32* %63, align 1
Gen:   store i32 %62, i32* %63, align 1
Graph code generated!
Root:
  store i32 13, i32* %msg_code40, align 8, !tbaa !14
  store i32 %19, i32* %arrayidx45, align 4, !tbaa !18
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 13, %19", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code40, %arrayidx45", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; initial_setup
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 10, i32* %arrayidx63, align 4, !tbaa !18
Attempting Group:
  store i32 24, i32* %msg_code54, align 8, !tbaa !14
  store i32 %24, i32* %arrayidx59, align 4, !tbaa !18
Creating Node
  store i32 24, i32* %msg_code54, align 8, !tbaa !14
  store i32 %24, i32* %arrayidx59, align 4, !tbaa !18
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 24
  %24 = load i32, i32* %num_components49, align 4, !tbaa !11
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 24
Alt Seq
Creating Node
  %msg_code54 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 5
  %arrayidx59 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code54 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 5
  %arrayidx59 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code54 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 24, i32* %msg_code54, align 8, !tbaa !14
}
ScheduleNode: {
  store i32 %24, i32* %arrayidx59, align 4, !tbaa !18
}
ScheduleNode: {
  store i32 24, i32* %msg_code54, align 8, !tbaa !14
}
Count: 1
Start:   store i32 24, i32* %msg_code54, align 8, !tbaa !14
Processing:   store i32 24, i32* %msg_code54, align 8, !tbaa !14
Count: 1
Found:   store i32 24, i32* %msg_code54, align 8, !tbaa !14
ScheduleNode: {
  store i32 %24, i32* %arrayidx59, align 4, !tbaa !18
}
Non-memory:   %arrayidx59 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %24, i32* %arrayidx59, align 4, !tbaa !18
Count: 1
Found:   store i32 %24, i32* %arrayidx59, align 4, !tbaa !18
I:   %26 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err53, align 8, !tbaa !13
Last:   br label %if.end66
Schedulable: 1
Loop Rolling: initial_setup
Generating tree
Generating MATCH
Match: 
  store i32 24, i32* %msg_code54, align 8, !tbaa !14
  store i32 %24, i32* %arrayidx59, align 4, !tbaa !18
Generating ALTSEQ
Values:
i32 24
  %24 = load i32, i32* %num_components49, align 4, !tbaa !11
Generated Version 4:
  %61 = icmp eq i8 %60, 0
  %62 = select i1 %61, i32 24, i32 %24
Generating ALTSEQ
Values:
  %msg_code54 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 5
  %arrayidx59 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %63 = select i1 %61, i32* %msg_code54, i32* %arrayidx59
Operands done!
Generated:   store i32 %62, i32* %63, align 1
Gen:   store i32 %62, i32* %63, align 1
Graph code generated!
Root:
  store i32 24, i32* %msg_code54, align 8, !tbaa !14
  store i32 %24, i32* %arrayidx59, align 4, !tbaa !18
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 24, %24", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code54, %arrayidx59", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; initial_setup
Trying AGAIN
Trying AGAIN
  %.pre-phi = phi %struct.jpeg_common_struct* [ %.pre259, %if.end48.if.end66_crit_edge ], [ %29, %if.then52 ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %max_h_samp_factor, align 8, !tbaa !20
  store i32 1, i32* %max_v_samp_factor, align 4, !tbaa !21
Creating Node
  store i32 1, i32* %max_h_samp_factor, align 8, !tbaa !20
  store i32 1, i32* %max_v_samp_factor, align 4, !tbaa !21
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 1
i32 1
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
Match: 0
2 x 2
Final Match: 0
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
Alt Seq
ScheduleNode: {
  store i32 1, i32* %max_h_samp_factor, align 8, !tbaa !20
}
ScheduleNode: {
  store i32 1, i32* %max_v_samp_factor, align 4, !tbaa !21
}
ScheduleNode: {
  store i32 1, i32* %max_h_samp_factor, align 8, !tbaa !20
}
Count: 1
Start:   store i32 1, i32* %max_h_samp_factor, align 8, !tbaa !20
Processing:   store i32 1, i32* %max_h_samp_factor, align 8, !tbaa !20
Count: 1
Found:   store i32 1, i32* %max_h_samp_factor, align 8, !tbaa !20
ScheduleNode: {
  store i32 1, i32* %max_v_samp_factor, align 4, !tbaa !21
}
Non-memory:   %max_v_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
Processing:   store i32 1, i32* %max_v_samp_factor, align 4, !tbaa !21
Count: 1
Found:   store i32 1, i32* %max_v_samp_factor, align 4, !tbaa !21
I:   %comp_info = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 14
Last:   br label %for.cond
Schedulable: 1
Loop Rolling: initial_setup
Generating tree
Generating MATCH
Match: 
  store i32 1, i32* %max_h_samp_factor, align 8, !tbaa !20
  store i32 1, i32* %max_v_samp_factor, align 4, !tbaa !21
Generating IDENTICAL
Generating ALTSEQ
Values:
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
Generated Version 4:
  %61 = icmp eq i8 %60, 0
  %62 = select i1 %61, i32* %max_h_samp_factor, i32* %max_v_samp_factor
Operands done!
Generated:   store i32 1, i32* %62, align 1
Gen:   store i32 1, i32* %62, align 1
Graph code generated!
Root:
  store i32 1, i32* %max_h_samp_factor, align 8, !tbaa !20
  store i32 1, i32* %max_v_samp_factor, align 4, !tbaa !21
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="1", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %max_h_samp_factor, %max_v_samp_factor", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 5 = -1; Width: 2; Unprofitable; initial_setup
Trying AGAIN
Trying AGAIN
  %31 = phi i32 [ 1, %if.end66 ], [ %cond105, %if.end88 ]
  %32 = phi i32 [ 1, %if.end66 ], [ %cond, %if.end88 ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %30, %if.end66 ], [ %incdec.ptr, %if.end88 ]
  %ci.0 = phi i32 [ 0, %if.end66 ], [ %inc, %if.end88 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 16, i32* %msg_code85, align 8, !tbaa !14
  %40 = phi i32 [ %36, %lor.lhs.false76 ], [ %.pre258, %if.then83 ]
  %41 = phi i32 [ %31, %lor.lhs.false76 ], [ %.pre257, %if.then83 ]
  %42 = phi i32 [ %34, %lor.lhs.false76 ], [ %.pre256, %if.then83 ]
  %43 = phi i32 [ %32, %lor.lhs.false76 ], [ %.pre255, %if.then83 ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 %cond, i32* %max_h_samp_factor, align 8, !tbaa !20
  store i32 %cond105, i32* %max_v_samp_factor, align 4, !tbaa !21
Creating Node
  store i32 %cond, i32* %max_h_samp_factor, align 8, !tbaa !20
  store i32 %cond105, i32* %max_v_samp_factor, align 4, !tbaa !21
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %cond = select i1 %cmp91, i32 %43, i32 %42
  %cond105 = select i1 %cmp98, i32 %41, i32 %40
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %cmp91 = icmp sgt i32 %43, %42
  %cmp98 = icmp sgt i32 %41, %40
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %43 = phi i32 [ %32, %lor.lhs.false76 ], [ %.pre255, %if.then83 ]
  %41 = phi i32 [ %31, %lor.lhs.false76 ], [ %.pre257, %if.then83 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %43 = phi i32 [ %32, %lor.lhs.false76 ], [ %.pre255, %if.then83 ]
Alt Seq
Creating Node
  %42 = phi i32 [ %34, %lor.lhs.false76 ], [ %.pre256, %if.then83 ]
  %40 = phi i32 [ %36, %lor.lhs.false76 ], [ %.pre258, %if.then83 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %42 = phi i32 [ %34, %lor.lhs.false76 ], [ %.pre256, %if.then83 ]
Alt Seq
Creating Node
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
Match: 0
2 x 2
Final Match: 0
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
Alt Seq
ScheduleNode: {
  store i32 %cond, i32* %max_h_samp_factor, align 8, !tbaa !20
}
ScheduleNode: {
  store i32 %cond105, i32* %max_v_samp_factor, align 4, !tbaa !21
}
ScheduleNode: {
  store i32 %cond, i32* %max_h_samp_factor, align 8, !tbaa !20
}
Count: 1
Start:   %cmp91 = icmp sgt i32 %43, %42
Non-memory:   %cmp91 = icmp sgt i32 %43, %42
Non-memory:   %cond = select i1 %cmp91, i32 %43, i32 %42
Processing:   store i32 %cond, i32* %max_h_samp_factor, align 8, !tbaa !20
Count: 1
Found:   store i32 %cond, i32* %max_h_samp_factor, align 8, !tbaa !20
ScheduleNode: {
  store i32 %cond105, i32* %max_v_samp_factor, align 4, !tbaa !21
}
Non-memory:   %cmp98 = icmp sgt i32 %41, %40
Non-memory:   %cond105 = select i1 %cmp98, i32 %41, i32 %40
Processing:   store i32 %cond105, i32* %max_v_samp_factor, align 4, !tbaa !21
Count: 1
Found:   store i32 %cond105, i32* %max_v_samp_factor, align 4, !tbaa !21
I:   %inc = add nuw nsw i32 %ci.0, 1
Last:   br label %for.cond, !llvm.loop !26
Schedulable: 1
Loop Rolling: initial_setup
Generating tree
Generating MATCH
Match: 
  store i32 %cond, i32* %max_h_samp_factor, align 8, !tbaa !20
  store i32 %cond105, i32* %max_v_samp_factor, align 4, !tbaa !21
Generating MATCH
Match: 
  %cond = select i1 %cmp91, i32 %43, i32 %42
  %cond105 = select i1 %cmp98, i32 %41, i32 %40
Generating MATCH
Match: 
  %cmp91 = icmp sgt i32 %43, %42
  %cmp98 = icmp sgt i32 %41, %40
Generating ALTSEQ
Values:
  %43 = phi i32 [ %32, %lor.lhs.false76 ], [ %.pre255, %if.then83 ]
  %41 = phi i32 [ %31, %lor.lhs.false76 ], [ %.pre257, %if.then83 ]
Generated Version 4:
  %61 = icmp eq i8 %60, 0
  %62 = select i1 %61, i32 %43, i32 %41
Generating ALTSEQ
Values:
  %42 = phi i32 [ %34, %lor.lhs.false76 ], [ %.pre256, %if.then83 ]
  %40 = phi i32 [ %36, %lor.lhs.false76 ], [ %.pre258, %if.then83 ]
Generated Version 4:
  %63 = select i1 %61, i32 %42, i32 %40
Operands done!
Generated:   %64 = icmp sgt i32 %62, %63
Gen:   %64 = icmp sgt i32 %62, %63
Operands done!
Generated:   %65 = select i1 %64, i32 %62, i32 %63
Found use: 0:   %32 = phi i32 [ 1, %if.end66 ], [ %cond, %if.end88 ]
Found use: 1:   %31 = phi i32 [ 1, %if.end66 ], [ %cond105, %if.end88 ]
Extracting:   %65 = select i1 %64, i32 %62, i32 %63
Gen:   %66 = select i1 %65, i32 %63, i32 %64
Generating ALTSEQ
Values:
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
Generated Version 4:
  %68 = select i1 %62, i32* %max_h_samp_factor, i32* %max_v_samp_factor
Operands done!
Generated:   store i32 %66, i32* %68, align 1
Gen:   store i32 %66, i32* %68, align 1
Graph code generated!
Root:
  store i32 %cond, i32* %max_h_samp_factor, align 8, !tbaa !20
  store i32 %cond105, i32* %max_v_samp_factor, align 4, !tbaa !21
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="select", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="icmp", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %44, %42", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %43, %41", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="alt: %max_h_samp_factor, %max_v_samp_factor", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
5->0 
2->1 
3->1 
4->1 
3->2 
4->2 
6 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
1->6
7 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
1->7
}

Gains: 8 - 24 = -16; Width: 2; Unprofitable; initial_setup
Trying AGAIN
Trying AGAIN
  %.lcssa = phi i32 [ %34, %for.cond ]
  %46 = phi i32 [ %.lcssa, %for.end ], [ %.pre254, %for.body112 ]
  %compptr.1 = phi %struct.jpeg_component_info* [ %45, %for.end ], [ %incdec.ptr152, %for.body112 ]
  %ci.1 = phi i32 [ 0, %for.end ], [ %inc151, %for.body112 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul117 = mul nsw i64 %conv116, %conv114
looking for reduction
looking for reduction
looking for reduction
  %mul126 = mul nsw i64 %conv125, %conv123
looking for reduction
looking for reduction
looking for reduction
  %mul136 = mul nsw i64 %conv135, %conv133
looking for reduction
looking for reduction
looking for reduction
  %mul145 = mul nsw i64 %conv144, %conv142
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %ci.1, i32* %component_index, align 4, !tbaa !28
  store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !29
  store i32 %conv121, i32* %width_in_blocks, align 4, !tbaa !30
  store i32 %conv131, i32* %height_in_blocks, align 8, !tbaa !31
  store i32 %conv140, i32* %downsampled_width, align 8, !tbaa !32
  store i32 %conv149, i32* %downsampled_height, align 4, !tbaa !33
  store i32 1, i32* %component_needed, align 8, !tbaa !34
Attempting Group:
  %call = tail call i64 @jdiv_round_up(i64 %mul117, i64 %conv120) #3
  %call130 = tail call i64 @jdiv_round_up(i64 %mul126, i64 %conv129) #3
  %call139 = tail call i64 @jdiv_round_up(i64 %mul136, i64 %conv138) #3
  %call148 = tail call i64 @jdiv_round_up(i64 %mul145, i64 %conv147) #3
Creating Node
  store i32 %ci.1, i32* %component_index, align 4, !tbaa !28
  store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !29
  store i32 %conv121, i32* %width_in_blocks, align 4, !tbaa !30
  store i32 %conv131, i32* %height_in_blocks, align 8, !tbaa !31
  store i32 %conv140, i32* %downsampled_width, align 8, !tbaa !32
  store i32 %conv149, i32* %downsampled_height, align 4, !tbaa !33
  store i32 1, i32* %component_needed, align 8, !tbaa !34
Match: 1
7 x 7
Final Match: 1
Matching
Creating Node
  %ci.1 = phi i32 [ 0, %for.end ], [ %inc151, %for.body112 ]
i32 8
  %conv121 = trunc i64 %call to i32
  %conv131 = trunc i64 %call130 to i32
  %conv140 = trunc i64 %call139 to i32
  %conv149 = trunc i64 %call148 to i32
i32 1
Match: 0
7 x 7
Final Match: 0
GEPSeq2
BinOP?
  %ci.1 = phi i32 [ 0, %for.end ], [ %inc151, %for.body112 ]
Mismatching
Creating Node
  %component_index = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 1
  %DCT_scaled_size = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 9
  %width_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 7
  %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 8
  %downsampled_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 10
  %downsampled_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 11
  %component_needed = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 12
Match: 0
7 x 7
Final Match: 0
  %component_index = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 1
  %DCT_scaled_size = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 9
  %width_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 7
  %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 8
  %downsampled_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 10
  %downsampled_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 11
  %component_needed = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 12
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %component_index = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 1
Mismatching
ScheduleNode: {
  store i32 %ci.1, i32* %component_index, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !29
}
ScheduleNode: {
  store i32 %conv121, i32* %width_in_blocks, align 4, !tbaa !30
}
ScheduleNode: {
  store i32 %conv131, i32* %height_in_blocks, align 8, !tbaa !31
}
ScheduleNode: {
  store i32 %conv140, i32* %downsampled_width, align 8, !tbaa !32
}
ScheduleNode: {
  store i32 %conv149, i32* %downsampled_height, align 4, !tbaa !33
}
ScheduleNode: {
  store i32 1, i32* %component_needed, align 8, !tbaa !34
}
ScheduleNode: {
  store i32 %ci.1, i32* %component_index, align 4, !tbaa !28
}
Count: 1
Start:   store i32 %ci.1, i32* %component_index, align 4, !tbaa !28
Processing:   store i32 %ci.1, i32* %component_index, align 4, !tbaa !28
Count: 1
Found:   store i32 %ci.1, i32* %component_index, align 4, !tbaa !28
ScheduleNode: {
  store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !29
}
Non-memory:   %DCT_scaled_size = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 9
Processing:   store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !29
Count: 1
Found:   store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !29
ScheduleNode: {
  store i32 %conv121, i32* %width_in_blocks, align 4, !tbaa !30
}
Processing:   %47 = load i32, i32* %image_width22, align 8, !tbaa !10
Count: 1
Not found:   %47 = load i32, i32* %image_width22, align 8, !tbaa !10
Read/Write memory
I:   %47 = load i32, i32* %image_width22, align 8, !tbaa !10
Last:   br label %for.cond108, !llvm.loop !35
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


for.body112:                                      ; preds = %for.cond108
  %component_index = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 1
  store i32 %ci.1, i32* %component_index, align 4, !tbaa !28
  %DCT_scaled_size = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 9
  store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !29
  %47 = load i32, i32* %image_width22, align 8, !tbaa !10
  %conv114 = zext i32 %47 to i64
  %h_samp_factor115 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
  %48 = load i32, i32* %h_samp_factor115, align 8, !tbaa !23
  %conv116 = sext i32 %48 to i64
  %mul117 = mul nsw i64 %conv116, %conv114
  %49 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !20
  %mul119 = shl nsw i32 %49, 3
  %conv120 = sext i32 %mul119 to i64
  %call = tail call i64 @jdiv_round_up(i64 %mul117, i64 %conv120) #3
  %conv121 = trunc i64 %call to i32
  %width_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 7
  store i32 %conv121, i32* %width_in_blocks, align 4, !tbaa !30
  %50 = load i32, i32* %image_height, align 4, !tbaa !2
  %conv123 = zext i32 %50 to i64
  %v_samp_factor124 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 3
  %51 = load i32, i32* %v_samp_factor124, align 4, !tbaa !25
  %conv125 = sext i32 %51 to i64
  %mul126 = mul nsw i64 %conv125, %conv123
  %52 = load i32, i32* %max_v_samp_factor, align 4, !tbaa !21
  %mul128 = shl nsw i32 %52, 3
  %conv129 = sext i32 %mul128 to i64
  %call130 = tail call i64 @jdiv_round_up(i64 %mul126, i64 %conv129) #3
  %conv131 = trunc i64 %call130 to i32
  %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 8
  store i32 %conv131, i32* %height_in_blocks, align 8, !tbaa !31
  %53 = load i32, i32* %image_width22, align 8, !tbaa !10
  %conv133 = zext i32 %53 to i64
  %54 = load i32, i32* %h_samp_factor115, align 8, !tbaa !23
  %conv135 = sext i32 %54 to i64
  %mul136 = mul nsw i64 %conv135, %conv133
  %55 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !20
  %conv138 = sext i32 %55 to i64
  %call139 = tail call i64 @jdiv_round_up(i64 %mul136, i64 %conv138) #3
  %conv140 = trunc i64 %call139 to i32
  %downsampled_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 10
  store i32 %conv140, i32* %downsampled_width, align 8, !tbaa !32
  %56 = load i32, i32* %image_height, align 4, !tbaa !2
  %conv142 = zext i32 %56 to i64
  %57 = load i32, i32* %v_samp_factor124, align 4, !tbaa !25
  %conv144 = sext i32 %57 to i64
  %mul145 = mul nsw i64 %conv144, %conv142
  %58 = load i32, i32* %max_v_samp_factor, align 4, !tbaa !21
  %conv147 = sext i32 %58 to i64
  %call148 = tail call i64 @jdiv_round_up(i64 %mul145, i64 %conv147) #3
  %conv149 = trunc i64 %call148 to i32
  %downsampled_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 11
  store i32 %conv149, i32* %downsampled_height, align 4, !tbaa !33
  %component_needed = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 12
  store i32 1, i32* %component_needed, align 8, !tbaa !34
  %inc151 = add nuw nsw i32 %ci.1, 1
  %incdec.ptr152 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 1
  %.pre254 = load i32, i32* %num_components49, align 4, !tbaa !11
  br label %for.cond108, !llvm.loop !35

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Creating Node
  %call = tail call i64 @jdiv_round_up(i64 %mul117, i64 %conv120) #3
  %call130 = tail call i64 @jdiv_round_up(i64 %mul126, i64 %conv129) #3
  %call139 = tail call i64 @jdiv_round_up(i64 %mul136, i64 %conv138) #3
  %call148 = tail call i64 @jdiv_round_up(i64 %mul145, i64 %conv147) #3
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %mul117 = mul nsw i64 %conv116, %conv114
  %mul126 = mul nsw i64 %conv125, %conv123
  %mul136 = mul nsw i64 %conv135, %conv133
  %mul145 = mul nsw i64 %conv144, %conv142
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %conv116 = sext i32 %48 to i64
  %conv125 = sext i32 %51 to i64
  %conv135 = sext i32 %54 to i64
  %conv144 = sext i32 %57 to i64
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %48 = load i32, i32* %h_samp_factor115, align 8, !tbaa !23
  %51 = load i32, i32* %v_samp_factor124, align 4, !tbaa !25
  %54 = load i32, i32* %h_samp_factor115, align 8, !tbaa !23
  %57 = load i32, i32* %v_samp_factor124, align 4, !tbaa !25
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %h_samp_factor115 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
  %v_samp_factor124 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 3
  %h_samp_factor115 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
  %v_samp_factor124 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 3
Match: 0
2 x 4
Final Match: 0
  %h_samp_factor115 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
  %v_samp_factor124 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 3
  %h_samp_factor115 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
  %v_samp_factor124 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 3
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %h_samp_factor115 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
Alt Seq
Creating Node
  %conv114 = zext i32 %47 to i64
  %conv123 = zext i32 %50 to i64
  %conv133 = zext i32 %53 to i64
  %conv142 = zext i32 %56 to i64
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %47 = load i32, i32* %image_width22, align 8, !tbaa !10
  %50 = load i32, i32* %image_height, align 4, !tbaa !2
  %53 = load i32, i32* %image_width22, align 8, !tbaa !10
  %56 = load i32, i32* %image_height, align 4, !tbaa !2
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %image_width22 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
  %image_width22 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
Match: 0
2 x 4
Final Match: 0
  %image_width22 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
  %image_width22 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %image_width22 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
Alt Seq
Creating Node
  %conv120 = sext i32 %mul119 to i64
  %conv129 = sext i32 %mul128 to i64
  %conv138 = sext i32 %55 to i64
  %conv147 = sext i32 %58 to i64
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %mul119 = shl nsw i32 %49, 3
  %mul128 = shl nsw i32 %52, 3
  %55 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !20
  %58 = load i32, i32* %max_v_samp_factor, align 4, !tbaa !21
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %mul119 = shl nsw i32 %49, 3
Mismatching
Creating Node
Function: jdiv_round_up
Function: jdiv_round_up
Function: jdiv_round_up
Function: jdiv_round_up
Match: 1
1 x 4
Final Match: 1
All the Same
ScheduleNode: {
  %47 = load i32, i32* %image_width22, align 8, !tbaa !10
  %48 = load i32, i32* %h_samp_factor115, align 8, !tbaa !23
}
ScheduleNode: {
  %call = tail call i64 @jdiv_round_up(i64 %mul117, i64 %conv120) #3
}
ScheduleNode: {
  %50 = load i32, i32* %image_height, align 4, !tbaa !2
  %51 = load i32, i32* %v_samp_factor124, align 4, !tbaa !25
}
ScheduleNode: {
  %call130 = tail call i64 @jdiv_round_up(i64 %mul126, i64 %conv129) #3
}
ScheduleNode: {
  %53 = load i32, i32* %image_width22, align 8, !tbaa !10
  %54 = load i32, i32* %h_samp_factor115, align 8, !tbaa !23
}
ScheduleNode: {
  %call139 = tail call i64 @jdiv_round_up(i64 %mul136, i64 %conv138) #3
}
ScheduleNode: {
  %56 = load i32, i32* %image_height, align 4, !tbaa !2
  %57 = load i32, i32* %v_samp_factor124, align 4, !tbaa !25
}
ScheduleNode: {
  %call148 = tail call i64 @jdiv_round_up(i64 %mul145, i64 %conv147) #3
}
ScheduleNode: {
  %47 = load i32, i32* %image_width22, align 8, !tbaa !10
  %48 = load i32, i32* %h_samp_factor115, align 8, !tbaa !23
}
Count: 2
Start:   %47 = load i32, i32* %image_width22, align 8, !tbaa !10
Processing:   %47 = load i32, i32* %image_width22, align 8, !tbaa !10
Count: 2
Found:   %47 = load i32, i32* %image_width22, align 8, !tbaa !10
Non-memory:   %conv114 = zext i32 %47 to i64
Non-memory:   %h_samp_factor115 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
Processing:   %48 = load i32, i32* %h_samp_factor115, align 8, !tbaa !23
Count: 1
Found:   %48 = load i32, i32* %h_samp_factor115, align 8, !tbaa !23
ScheduleNode: {
  %call = tail call i64 @jdiv_round_up(i64 %mul117, i64 %conv120) #3
}
Non-memory:   %conv116 = sext i32 %48 to i64
Non-memory:   %mul117 = mul nsw i64 %conv116, %conv114
Processing:   %49 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !20
Count: 1
Not found:   %49 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !20
Read/Write memory
I:   %49 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !20
Last:   br label %for.cond108, !llvm.loop !35
Schedulable: 0
digraph VTree {
0 [label="call: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mul", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %h_samp_factor115, %v_samp_factor124", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %image_width22, %image_height", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
10 [label="func: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
8->0 
10->0 
2->1 
5->1 
3->2 
4->3 
6->5 
7->6 
9->8 
11 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->11
12 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->12
13 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->13
14 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->14
}


for.body112:                                      ; preds = %for.cond108
  %component_index = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 1
  store i32 %ci.1, i32* %component_index, align 4, !tbaa !28
  %DCT_scaled_size = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 9
  store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !29
  %47 = load i32, i32* %image_width22, align 8, !tbaa !10
  %conv114 = zext i32 %47 to i64
  %h_samp_factor115 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
  %48 = load i32, i32* %h_samp_factor115, align 8, !tbaa !23
  %conv116 = sext i32 %48 to i64
  %mul117 = mul nsw i64 %conv116, %conv114
  %49 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !20
  %mul119 = shl nsw i32 %49, 3
  %conv120 = sext i32 %mul119 to i64
  %call = tail call i64 @jdiv_round_up(i64 %mul117, i64 %conv120) #3
  %conv121 = trunc i64 %call to i32
  %width_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 7
  store i32 %conv121, i32* %width_in_blocks, align 4, !tbaa !30
  %50 = load i32, i32* %image_height, align 4, !tbaa !2
  %conv123 = zext i32 %50 to i64
  %v_samp_factor124 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 3
  %51 = load i32, i32* %v_samp_factor124, align 4, !tbaa !25
  %conv125 = sext i32 %51 to i64
  %mul126 = mul nsw i64 %conv125, %conv123
  %52 = load i32, i32* %max_v_samp_factor, align 4, !tbaa !21
  %mul128 = shl nsw i32 %52, 3
  %conv129 = sext i32 %mul128 to i64
  %call130 = tail call i64 @jdiv_round_up(i64 %mul126, i64 %conv129) #3
  %conv131 = trunc i64 %call130 to i32
  %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 8
  store i32 %conv131, i32* %height_in_blocks, align 8, !tbaa !31
  %53 = load i32, i32* %image_width22, align 8, !tbaa !10
  %conv133 = zext i32 %53 to i64
  %54 = load i32, i32* %h_samp_factor115, align 8, !tbaa !23
  %conv135 = sext i32 %54 to i64
  %mul136 = mul nsw i64 %conv135, %conv133
  %55 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !20
  %conv138 = sext i32 %55 to i64
  %call139 = tail call i64 @jdiv_round_up(i64 %mul136, i64 %conv138) #3
  %conv140 = trunc i64 %call139 to i32
  %downsampled_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 10
  store i32 %conv140, i32* %downsampled_width, align 8, !tbaa !32
  %56 = load i32, i32* %image_height, align 4, !tbaa !2
  %conv142 = zext i32 %56 to i64
  %57 = load i32, i32* %v_samp_factor124, align 4, !tbaa !25
  %conv144 = sext i32 %57 to i64
  %mul145 = mul nsw i64 %conv144, %conv142
  %58 = load i32, i32* %max_v_samp_factor, align 4, !tbaa !21
  %conv147 = sext i32 %58 to i64
  %call148 = tail call i64 @jdiv_round_up(i64 %mul145, i64 %conv147) #3
  %conv149 = trunc i64 %call148 to i32
  %downsampled_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 11
  store i32 %conv149, i32* %downsampled_height, align 4, !tbaa !33
  %component_needed = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 12
  store i32 1, i32* %component_needed, align 8, !tbaa !34
  %inc151 = add nuw nsw i32 %ci.1, 1
  %incdec.ptr152 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 1
  %.pre254 = load i32, i32* %num_components49, align 4, !tbaa !11
  br label %for.cond108, !llvm.loop !35

looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %conv160, i32* %total_iMCU_rows, align 8, !tbaa !36
Attempting Group:
  %call159 = tail call i64 @jdiv_round_up(i64 %conv155, i64 %conv158) #3
Done Loop Roller: 0/5
Optimizing: validate_script
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 17, i32* %msg_code, align 8, !tbaa !11
  store i32 0, i32* %arrayidx, align 4, !tbaa !14
Creating Node
  store i32 17, i32* %msg_code, align 8, !tbaa !11
  store i32 0, i32* %arrayidx, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 17
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 17
Int Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 17, i32* %msg_code, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 0, i32* %arrayidx, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 17, i32* %msg_code, align 8, !tbaa !11
}
Count: 1
Start:   store i32 17, i32* %msg_code, align 8, !tbaa !11
Processing:   store i32 17, i32* %msg_code, align 8, !tbaa !11
Count: 1
Found:   store i32 17, i32* %msg_code, align 8, !tbaa !11
ScheduleNode: {
  store i32 0, i32* %arrayidx, align 4, !tbaa !14
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 0, i32* %arrayidx, align 4, !tbaa !14
Count: 1
Found:   store i32 0, i32* %arrayidx, align 4, !tbaa !14
I:   %4 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !10
Last:   br label %if.end
Schedulable: 1
Loop Rolling: validate_script
Generating tree
Generating MATCH
Match: 
  store i32 17, i32* %msg_code, align 8, !tbaa !11
  store i32 0, i32* %arrayidx, align 4, !tbaa !14
Generating INTSEQ
Gen:   %95 = add i32 %94, 17
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %96 = icmp eq i8 %92, 0
  %97 = select i1 %96, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %95, i32* %97, align 1
Gen:   store i32 %95, i32* %97, align 1
Graph code generated!
Root:
  store i32 17, i32* %msg_code, align 8, !tbaa !11
  store i32 0, i32* %arrayidx, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="17..0, -17", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; validate_script
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %progressive_mode, align 4, !tbaa !20
  %ci.0 = phi i32 [ 0, %if.then7 ], [ %inc15, %for.inc14 ]
  %last_bitpos_ptr.0 = phi i32* [ %arrayidx9, %if.then7 ], [ %last_bitpos_ptr.1.lcssa, %for.inc14 ]
looking for reduction
  %coefi.0 = phi i32 [ %inc, %for.body13 ], [ 0, %for.cond11.preheader ]
  %last_bitpos_ptr.1 = phi i32* [ %incdec.ptr, %for.body13 ], [ %last_bitpos_ptr.0, %for.cond11.preheader ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 -1, i32* %last_bitpos_ptr.1, align 4, !tbaa !22
  %last_bitpos_ptr.1.lcssa = phi i32* [ %last_bitpos_ptr.1, %for.cond11 ]
looking for reduction
Attempting Group:
  store i32 0, i32* %progressive_mode17, align 4, !tbaa !20
  %indvars.iv488 = phi i64 [ %indvars.iv.next489, %for.body21 ], [ 0, %if.else ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %arrayidx22, align 4, !tbaa !22
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
  %scanptr.0 = phi %struct.jpeg_scan_info* [ %7, %if.end26 ], [ %incdec.ptr253, %for.inc252 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 4, i32* %arrayidx44, align 4, !tbaa !14
Attempting Group:
  store i32 24, i32* %msg_code36, align 8, !tbaa !11
  store i32 %15, i32* %arrayidx40, align 4, !tbaa !14
Creating Node
  store i32 24, i32* %msg_code36, align 8, !tbaa !11
  store i32 %15, i32* %arrayidx40, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 24
  %15 = load i32, i32* %comps_in_scan, align 4, !tbaa !27
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 24
Alt Seq
Creating Node
  %msg_code36 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 5
  %arrayidx40 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code36 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 5
  %arrayidx40 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code36 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 24, i32* %msg_code36, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %15, i32* %arrayidx40, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 24, i32* %msg_code36, align 8, !tbaa !11
}
Count: 1
Start:   store i32 24, i32* %msg_code36, align 8, !tbaa !11
Processing:   store i32 24, i32* %msg_code36, align 8, !tbaa !11
Count: 1
Found:   store i32 24, i32* %msg_code36, align 8, !tbaa !11
ScheduleNode: {
  store i32 %15, i32* %arrayidx40, align 4, !tbaa !14
}
Non-memory:   %arrayidx40 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %15, i32* %arrayidx40, align 4, !tbaa !14
Count: 1
Found:   store i32 %15, i32* %arrayidx40, align 4, !tbaa !14
I:   %18 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err35, align 8, !tbaa !10
Last:   br label %if.end47
Schedulable: 1
Loop Rolling: validate_script
Generating tree
Generating MATCH
Match: 
  store i32 24, i32* %msg_code36, align 8, !tbaa !11
  store i32 %15, i32* %arrayidx40, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 24
  %15 = load i32, i32* %comps_in_scan, align 4, !tbaa !27
Generated Version 4:
  %93 = icmp eq i8 %92, 0
  %94 = select i1 %93, i32 24, i32 %15
Generating ALTSEQ
Values:
  %msg_code36 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 5
  %arrayidx40 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %17, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %95 = select i1 %93, i32* %msg_code36, i32* %arrayidx40
Operands done!
Generated:   store i32 %94, i32* %95, align 1
Gen:   store i32 %94, i32* %95, align 1
Graph code generated!
Root:
  store i32 24, i32* %msg_code36, align 8, !tbaa !11
  store i32 %15, i32* %arrayidx40, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 24, %15", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code36, %arrayidx40", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; validate_script
Trying AGAIN
Trying AGAIN
  %indvars.iv474 = phi i64 [ %indvars.iv.next475, %for.inc82 ], [ 0, %if.end47 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 17, i32* %msg_code59, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx63, align 4, !tbaa !14
Creating Node
  store i32 17, i32* %msg_code59, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx63, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 17
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 17
Alt Seq
Creating Node
  %msg_code59 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 5
  %arrayidx63 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code59 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 5
  %arrayidx63 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code59 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 17, i32* %msg_code59, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx63, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 17, i32* %msg_code59, align 8, !tbaa !11
}
Count: 1
Start:   store i32 17, i32* %msg_code59, align 8, !tbaa !11
Processing:   store i32 17, i32* %msg_code59, align 8, !tbaa !11
Count: 1
Found:   store i32 17, i32* %msg_code59, align 8, !tbaa !11
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx63, align 4, !tbaa !14
}
Non-memory:   %arrayidx63 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0, i32* %arrayidx63, align 4, !tbaa !14
Count: 1
Found:   store i32 %scanno.0, i32* %arrayidx63, align 4, !tbaa !14
I:   %26 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err35, align 8, !tbaa !10
Last:   br label %if.end66
Schedulable: 1
Loop Rolling: validate_script
Generating tree
Generating MATCH
Match: 
  store i32 17, i32* %msg_code59, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx63, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 17
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Generated Version 4:
  %93 = icmp eq i8 %92, 0
  %94 = select i1 %93, i32 17, i32 %scanno.0
Generating ALTSEQ
Values:
  %msg_code59 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 5
  %arrayidx63 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %25, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %95 = select i1 %93, i32* %msg_code59, i32* %arrayidx63
Operands done!
Generated:   store i32 %94, i32* %95, align 1
Gen:   store i32 %94, i32* %95, align 1
Graph code generated!
Root:
  store i32 17, i32* %msg_code59, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx63, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 17, %scanno.0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code59, %arrayidx63", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; validate_script
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 17, i32* %msg_code74, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx78, align 4, !tbaa !14
Creating Node
  store i32 17, i32* %msg_code74, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx78, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 17
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 17
Alt Seq
Creating Node
  %msg_code74 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %31, i64 0, i32 5
  %arrayidx78 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %31, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code74 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %31, i64 0, i32 5
  %arrayidx78 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %31, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code74 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %31, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 17, i32* %msg_code74, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx78, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 17, i32* %msg_code74, align 8, !tbaa !11
}
Count: 1
Start:   store i32 17, i32* %msg_code74, align 8, !tbaa !11
Processing:   store i32 17, i32* %msg_code74, align 8, !tbaa !11
Count: 1
Found:   store i32 17, i32* %msg_code74, align 8, !tbaa !11
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx78, align 4, !tbaa !14
}
Non-memory:   %arrayidx78 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %31, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0, i32* %arrayidx78, align 4, !tbaa !14
Count: 1
Found:   store i32 %scanno.0, i32* %arrayidx78, align 4, !tbaa !14
I:   %32 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err35, align 8, !tbaa !10
Last:   br label %for.inc82
Schedulable: 1
Loop Rolling: validate_script
Generating tree
Generating MATCH
Match: 
  store i32 17, i32* %msg_code74, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx78, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 17
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Generated Version 4:
  %93 = icmp eq i8 %92, 0
  %94 = select i1 %93, i32 17, i32 %scanno.0
Generating ALTSEQ
Values:
  %msg_code74 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %31, i64 0, i32 5
  %arrayidx78 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %31, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %95 = select i1 %93, i32* %msg_code74, i32* %arrayidx78
Operands done!
Generated:   store i32 %94, i32* %95, align 1
Gen:   store i32 %94, i32* %95, align 1
Graph code generated!
Root:
  store i32 17, i32* %msg_code74, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx78, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 17, %scanno.0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code74, %arrayidx78", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; validate_script
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
  %43 = or i1 %42, %41
Found
Building reduction
  br i1 %43, label %if.then106, label %if.end115
  %43 = or i1 %42, %41
BOs:
  %43 = or i1 %42, %41
  %41 = or i1 %40, %or.cond295
  %or.cond295 = or i1 %cmp95, %cmp97
Operands:
  %42 = icmp ugt i32 %37, 13
  %40 = icmp ugt i32 %36, 13
  %cmp95 = icmp slt i32 %35, %34
  %cmp97 = icmp sgt i32 %35, 63
Operands:
  %42 = icmp ugt i32 %37, 13
  %40 = icmp ugt i32 %36, 13
  %cmp97 = icmp sgt i32 %35, 63
  %cmp95 = icmp slt i32 %35, %34
ReductionNode
Creating Node
  %42 = icmp ugt i32 %37, 13
  %40 = icmp ugt i32 %36, 13
  %cmp97 = icmp sgt i32 %35, 63
  %cmp95 = icmp slt i32 %35, %34
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %37 = load i32, i32* %Al88, align 4, !tbaa !30
  %36 = load i32, i32* %Ah87, align 4, !tbaa !29
  %35 = load i32, i32* %Se86, align 4, !tbaa !19
  %35 = load i32, i32* %Se86, align 4, !tbaa !19
Match: 0
3 x 4
Final Match: 0
GEPSeq2
BinOP?
  %37 = load i32, i32* %Al88, align 4, !tbaa !30
Mismatching
Creating Node
i32 13
i32 13
i32 63
  %34 = load i32, i32* %Ss85, align 4, !tbaa !17
Match: 0
3 x 4
Final Match: 0
GEPSeq2
BinOP?
i32 13
Mismatching
Empty scheduling entries
Loop Rolling: validate_script
Generating tree
Generating REDUCTION
Generating MATCH
Match: 
  %42 = icmp ugt i32 %37, 13
  %40 = icmp ugt i32 %36, 13
  %cmp97 = icmp sgt i32 %35, 63
  %cmp95 = icmp slt i32 %35, %34
Generating Mismatch
Mismatched Values:
inst:   %37 = load i32, i32* %Al88, align 4, !tbaa !30
inst:   %36 = load i32, i32* %Ah87, align 4, !tbaa !29
inst:   %35 = load i32, i32* %Se86, align 4, !tbaa !19
inst:   %35 = load i32, i32* %Se86, align 4, !tbaa !19
Non constants
Array Type: 4:i32
Created array:   %92 = alloca i32, i8 4, align 4
Gen:   %99 = load i32, i32* %98, align 4
Generating Mismatch
Mismatched Values:
int: i32 13
int: i32 13
int: i32 63
inst:   %34 = load i32, i32* %Ss85, align 4, !tbaa !17
Non constants
Array Type: 4:i32
Created array:   %97 = alloca i32, i8 4, align 4
Gen:   %106 = load i32, i32* %105, align 4
Operands done!
Generated:   %107 = icmp ugt i32 %104, %106
Gen:   %107 = icmp ugt i32 %104, %106
Closing REDUCTION
Found use: 0:   br i1 %43, label %if.then106, label %if.end115
Extracting:   %109 = or i1 %103, %108
Gen:   %109 = or i1 %103, %108
Graph code generated!
Root:
  %43 = or i1 %42, %41
  %41 = or i1 %40, %or.cond295
  %or.cond295 = or i1 %cmp95, %cmp97
Root size: 3
digraph VTree {
0 [label="or red.", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="icmp", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->1 
3->1 
4 [label="br", style="filled" , fillcolor="#f2eb5c", shape=box];
0->4
}

Gains: 7 - 106 = -99; Width: 3; Reduction Unprofitable; validate_script
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code108, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx112, align 4, !tbaa !14
Creating Node
  store i32 15, i32* %msg_code108, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx112, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code108 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %44, i64 0, i32 5
  %arrayidx112 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %44, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code108 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %44, i64 0, i32 5
  %arrayidx112 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %44, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code108 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %44, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code108, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx112, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 15, i32* %msg_code108, align 8, !tbaa !11
}
Count: 1
Start:   store i32 15, i32* %msg_code108, align 8, !tbaa !11
Processing:   store i32 15, i32* %msg_code108, align 8, !tbaa !11
Count: 1
Found:   store i32 15, i32* %msg_code108, align 8, !tbaa !11
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx112, align 4, !tbaa !14
}
Non-memory:   %arrayidx112 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %44, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0, i32* %arrayidx112, align 4, !tbaa !14
Count: 1
Found:   store i32 %scanno.0, i32* %arrayidx112, align 4, !tbaa !14
I:   %45 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err35, align 8, !tbaa !10
Last:   br label %if.end115
Schedulable: 1
Loop Rolling: validate_script
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code108, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx112, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Generated Version 4:
  %93 = icmp eq i8 %92, 0
  %94 = select i1 %93, i32 15, i32 %scanno.0
Generating ALTSEQ
Values:
  %msg_code108 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %44, i64 0, i32 5
  %arrayidx112 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %44, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %95 = select i1 %93, i32* %msg_code108, i32* %arrayidx112
Operands done!
Generated:   store i32 %94, i32* %95, align 1
Gen:   store i32 %94, i32* %95, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code108, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx112, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code108, %arrayidx112", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; validate_script
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code121, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx125, align 4, !tbaa !14
Creating Node
  store i32 15, i32* %msg_code121, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx125, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code121 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %47, i64 0, i32 5
  %arrayidx125 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %47, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code121 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %47, i64 0, i32 5
  %arrayidx125 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %47, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code121 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %47, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code121, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx125, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 15, i32* %msg_code121, align 8, !tbaa !11
}
Count: 1
Start:   store i32 15, i32* %msg_code121, align 8, !tbaa !11
Processing:   store i32 15, i32* %msg_code121, align 8, !tbaa !11
Count: 1
Found:   store i32 15, i32* %msg_code121, align 8, !tbaa !11
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx125, align 4, !tbaa !14
}
Non-memory:   %arrayidx125 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %47, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0, i32* %arrayidx125, align 4, !tbaa !14
Count: 1
Found:   store i32 %scanno.0, i32* %arrayidx125, align 4, !tbaa !14
I:   %48 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err35, align 8, !tbaa !10
Last:   br label %if.end141
Schedulable: 1
Loop Rolling: validate_script
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code121, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx125, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Generated Version 4:
  %93 = icmp eq i8 %92, 0
  %94 = select i1 %93, i32 15, i32 %scanno.0
Generating ALTSEQ
Values:
  %msg_code121 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %47, i64 0, i32 5
  %arrayidx125 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %47, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %95 = select i1 %93, i32* %msg_code121, i32* %arrayidx125
Operands done!
Generated:   store i32 %94, i32* %95, align 1
Gen:   store i32 %94, i32* %95, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code121, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx125, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code121, %arrayidx125", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; validate_script
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code133, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx137, align 4, !tbaa !14
Creating Node
  store i32 15, i32* %msg_code133, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx137, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code133 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %50, i64 0, i32 5
  %arrayidx137 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %50, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code133 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %50, i64 0, i32 5
  %arrayidx137 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %50, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code133 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %50, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code133, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx137, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 15, i32* %msg_code133, align 8, !tbaa !11
}
Count: 1
Start:   store i32 15, i32* %msg_code133, align 8, !tbaa !11
Processing:   store i32 15, i32* %msg_code133, align 8, !tbaa !11
Count: 1
Found:   store i32 15, i32* %msg_code133, align 8, !tbaa !11
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx137, align 4, !tbaa !14
}
Non-memory:   %arrayidx137 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %50, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0, i32* %arrayidx137, align 4, !tbaa !14
Count: 1
Found:   store i32 %scanno.0, i32* %arrayidx137, align 4, !tbaa !14
I:   %51 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err35, align 8, !tbaa !10
Last:   br label %if.end141
Schedulable: 1
Loop Rolling: validate_script
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code133, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx137, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Generated Version 4:
  %93 = icmp eq i8 %92, 0
  %94 = select i1 %93, i32 15, i32 %scanno.0
Generating ALTSEQ
Values:
  %msg_code133 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %50, i64 0, i32 5
  %arrayidx137 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %50, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %95 = select i1 %93, i32* %msg_code133, i32* %arrayidx137
Operands done!
Generated:   store i32 %94, i32* %95, align 1
Gen:   store i32 %94, i32* %95, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code133, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx137, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code133, %arrayidx137", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; validate_script
Trying AGAIN
Trying AGAIN
  %indvars.iv479 = phi i64 [ %indvars.iv.next480, %for.inc206 ], [ 0, %if.end141 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code157, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx161, align 4, !tbaa !14
Creating Node
  store i32 15, i32* %msg_code157, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx161, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code157 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %58, i64 0, i32 5
  %arrayidx161 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %58, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code157 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %58, i64 0, i32 5
  %arrayidx161 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %58, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code157 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %58, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code157, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx161, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 15, i32* %msg_code157, align 8, !tbaa !11
}
Count: 1
Start:   store i32 15, i32* %msg_code157, align 8, !tbaa !11
Processing:   store i32 15, i32* %msg_code157, align 8, !tbaa !11
Count: 1
Found:   store i32 15, i32* %msg_code157, align 8, !tbaa !11
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx161, align 4, !tbaa !14
}
Non-memory:   %arrayidx161 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %58, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0, i32* %arrayidx161, align 4, !tbaa !14
Count: 1
Found:   store i32 %scanno.0, i32* %arrayidx161, align 4, !tbaa !14
I:   %59 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err35, align 8, !tbaa !10
Last:   br label %if.end164
Schedulable: 1
Loop Rolling: validate_script
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code157, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx161, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Generated Version 4:
  %93 = icmp eq i8 %92, 0
  %94 = select i1 %93, i32 15, i32 %scanno.0
Generating ALTSEQ
Values:
  %msg_code157 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %58, i64 0, i32 5
  %arrayidx161 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %58, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %95 = select i1 %93, i32* %msg_code157, i32* %arrayidx161
Operands done!
Generated:   store i32 %94, i32* %95, align 1
Gen:   store i32 %94, i32* %95, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code157, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx161, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code157, %arrayidx161", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; validate_script
Trying AGAIN
Trying AGAIN
  %indvars.iv477 = phi i64 [ %indvars.iv.next478, %if.end200 ], [ %53, %if.end164 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code175, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx179, align 4, !tbaa !14
Creating Node
  store i32 15, i32* %msg_code175, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx179, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code175 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %62, i64 0, i32 5
  %arrayidx179 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %62, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code175 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %62, i64 0, i32 5
  %arrayidx179 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %62, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code175 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %62, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code175, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx179, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 15, i32* %msg_code175, align 8, !tbaa !11
}
Count: 1
Start:   store i32 15, i32* %msg_code175, align 8, !tbaa !11
Processing:   store i32 15, i32* %msg_code175, align 8, !tbaa !11
Count: 1
Found:   store i32 15, i32* %msg_code175, align 8, !tbaa !11
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx179, align 4, !tbaa !14
}
Non-memory:   %arrayidx179 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %62, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0, i32* %arrayidx179, align 4, !tbaa !14
Count: 1
Found:   store i32 %scanno.0, i32* %arrayidx179, align 4, !tbaa !14
I:   %63 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err35, align 8, !tbaa !10
Last:   br label %if.end200
Schedulable: 1
Loop Rolling: validate_script
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code175, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx179, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Generated Version 4:
  %93 = icmp eq i8 %92, 0
  %94 = select i1 %93, i32 15, i32 %scanno.0
Generating ALTSEQ
Values:
  %msg_code175 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %62, i64 0, i32 5
  %arrayidx179 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %62, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %95 = select i1 %93, i32* %msg_code175, i32* %arrayidx179
Operands done!
Generated:   store i32 %94, i32* %95, align 1
Gen:   store i32 %94, i32* %95, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code175, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx179, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code175, %arrayidx179", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; validate_script
Trying AGAIN
Trying AGAIN
looking for reduction
  %or.cond = and i1 %cmp189.not, %cmp186.not
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code192, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx196, align 4, !tbaa !14
Creating Node
  store i32 15, i32* %msg_code192, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx196, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code192 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %65, i64 0, i32 5
  %arrayidx196 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %65, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code192 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %65, i64 0, i32 5
  %arrayidx196 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %65, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code192 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %65, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code192, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx196, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 15, i32* %msg_code192, align 8, !tbaa !11
}
Count: 1
Start:   store i32 15, i32* %msg_code192, align 8, !tbaa !11
Processing:   store i32 15, i32* %msg_code192, align 8, !tbaa !11
Count: 1
Found:   store i32 15, i32* %msg_code192, align 8, !tbaa !11
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx196, align 4, !tbaa !14
}
Non-memory:   %arrayidx196 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %65, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0, i32* %arrayidx196, align 4, !tbaa !14
Count: 1
Found:   store i32 %scanno.0, i32* %arrayidx196, align 4, !tbaa !14
I:   %66 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err35, align 8, !tbaa !10
Last:   br label %if.end200
Schedulable: 1
Loop Rolling: validate_script
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code192, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx196, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Generated Version 4:
  %93 = icmp eq i8 %92, 0
  %94 = select i1 %93, i32 15, i32 %scanno.0
Generating ALTSEQ
Values:
  %msg_code192 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %65, i64 0, i32 5
  %arrayidx196 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %65, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %95 = select i1 %93, i32* %msg_code192, i32* %arrayidx196
Operands done!
Generated:   store i32 %94, i32* %95, align 1
Gen:   store i32 %94, i32* %95, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code192, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx196, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code192, %arrayidx196", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; validate_script
Trying AGAIN
Trying AGAIN
looking for reduction
Attempting Group:
  store i32 %37, i32* %arrayidx169, align 4, !tbaa !22
looking for reduction
  %71 = or i1 %cmp212, %70
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code219, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx223, align 4, !tbaa !14
Creating Node
  store i32 15, i32* %msg_code219, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx223, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code219 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %72, i64 0, i32 5
  %arrayidx223 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %72, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code219 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %72, i64 0, i32 5
  %arrayidx223 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %72, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code219 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %72, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code219, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx223, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 15, i32* %msg_code219, align 8, !tbaa !11
}
Count: 1
Start:   store i32 15, i32* %msg_code219, align 8, !tbaa !11
Processing:   store i32 15, i32* %msg_code219, align 8, !tbaa !11
Count: 1
Found:   store i32 15, i32* %msg_code219, align 8, !tbaa !11
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx223, align 4, !tbaa !14
}
Non-memory:   %arrayidx223 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %72, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0, i32* %arrayidx223, align 4, !tbaa !14
Count: 1
Found:   store i32 %scanno.0, i32* %arrayidx223, align 4, !tbaa !14
I:   %73 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err35, align 8, !tbaa !10
Last:   br label %if.end226
Schedulable: 1
Loop Rolling: validate_script
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code219, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx223, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 15
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Generated Version 4:
  %93 = icmp eq i8 %92, 0
  %94 = select i1 %93, i32 15, i32 %scanno.0
Generating ALTSEQ
Values:
  %msg_code219 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %72, i64 0, i32 5
  %arrayidx223 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %72, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %95 = select i1 %93, i32* %msg_code219, i32* %arrayidx223
Operands done!
Generated:   store i32 %94, i32* %95, align 1
Gen:   store i32 %94, i32* %95, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code219, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx223, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code219, %arrayidx223", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; validate_script
Trying AGAIN
Trying AGAIN
  %indvars.iv483 = phi i64 [ %indvars.iv.next484, %if.end245 ], [ 0, %if.end226 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 17, i32* %msg_code238, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx242, align 4, !tbaa !14
Creating Node
  store i32 17, i32* %msg_code238, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx242, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 17
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 17
Alt Seq
Creating Node
  %msg_code238 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %78, i64 0, i32 5
  %arrayidx242 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %78, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code238 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %78, i64 0, i32 5
  %arrayidx242 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %78, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code238 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %78, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 17, i32* %msg_code238, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx242, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 17, i32* %msg_code238, align 8, !tbaa !11
}
Count: 1
Start:   store i32 17, i32* %msg_code238, align 8, !tbaa !11
Processing:   store i32 17, i32* %msg_code238, align 8, !tbaa !11
Count: 1
Found:   store i32 17, i32* %msg_code238, align 8, !tbaa !11
ScheduleNode: {
  store i32 %scanno.0, i32* %arrayidx242, align 4, !tbaa !14
}
Non-memory:   %arrayidx242 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %78, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0, i32* %arrayidx242, align 4, !tbaa !14
Count: 1
Found:   store i32 %scanno.0, i32* %arrayidx242, align 4, !tbaa !14
I:   %79 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err35, align 8, !tbaa !10
Last:   br label %if.end245
Schedulable: 1
Loop Rolling: validate_script
Generating tree
Generating MATCH
Match: 
  store i32 17, i32* %msg_code238, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx242, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 17
  %scanno.0 = phi i32 [ 1, %if.end26 ], [ %inc254, %for.inc252 ]
Generated Version 4:
  %93 = icmp eq i8 %92, 0
  %94 = select i1 %93, i32 17, i32 %scanno.0
Generating ALTSEQ
Values:
  %msg_code238 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %78, i64 0, i32 5
  %arrayidx242 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %78, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %95 = select i1 %93, i32* %msg_code238, i32* %arrayidx242
Operands done!
Generated:   store i32 %94, i32* %95, align 1
Gen:   store i32 %94, i32* %95, align 1
Graph code generated!
Root:
  store i32 17, i32* %msg_code238, align 8, !tbaa !11
  store i32 %scanno.0, i32* %arrayidx242, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 17, %scanno.0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code238, %arrayidx242", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; validate_script
Trying AGAIN
Trying AGAIN
looking for reduction
Attempting Group:
  store i32 1, i32* %arrayidx234, align 4, !tbaa !22
looking for reduction
  %indvars.iv472 = phi i64 [ %indvars.iv.next473, %for.inc273 ], [ 0, %for.cond259.preheader ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 44, i32* %msg_code269, align 8, !tbaa !11
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc290 ], [ 0, %for.cond277.preheader ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 44, i32* %msg_code286, align 8, !tbaa !11
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 0/13
Optimizing: jinit_c_master_control
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
  store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
  store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
Attempting Group:
  store i8* %call, i8** %3, align 8, !tbaa !13
Creating Node
  store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
  store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
  store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
Function: prepare_for_pass
Function: pass_startup
Function: finish_pass_master
Match: 0
3 x 3
Final Match: 0
; Function Attrs: minsize nounwind optsize uwtable
define internal void @prepare_for_pass(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master1 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = bitcast %struct.jpeg_comp_master** %master1 to %struct.my_comp_master**
  %1 = load %struct.my_comp_master*, %struct.my_comp_master** %0, align 8, !tbaa !13
  %pass_type = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 1
  %2 = load i32, i32* %pass_type, align 8, !tbaa !68
  switch i32 %2, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb15
    i32 2, label %sw.bb30
  ]

sw.bb:                                            ; preds = %entry
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  %raw_data_in = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 23
  %3 = load i32, i32* %raw_data_in, align 8, !tbaa !72
  %tobool.not = icmp eq i32 %3, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %cconvert = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 56
  %4 = load %struct.jpeg_color_converter*, %struct.jpeg_color_converter** %cconvert, align 8, !tbaa !73
  %start_pass = getelementptr inbounds %struct.jpeg_color_converter, %struct.jpeg_color_converter* %4, i64 0, i32 0
  %5 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass, align 8, !tbaa !74
  call void %5(%struct.jpeg_compress_struct* %cinfo) #4
  %downsample = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 57
  %6 = load %struct.jpeg_downsampler*, %struct.jpeg_downsampler** %downsample, align 8, !tbaa !76
  %start_pass2 = getelementptr inbounds %struct.jpeg_downsampler, %struct.jpeg_downsampler* %6, i64 0, i32 0
  %7 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass2, align 8, !tbaa !77
  call void %7(%struct.jpeg_compress_struct* %cinfo) #4
  %prep = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 53
  %8 = load %struct.jpeg_c_prep_controller*, %struct.jpeg_c_prep_controller** %prep, align 8, !tbaa !79
  %start_pass3 = getelementptr inbounds %struct.jpeg_c_prep_controller, %struct.jpeg_c_prep_controller* %8, i64 0, i32 0
  %9 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass3, align 8, !tbaa !80
  call void %9(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %fdct = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 58
  %10 = load %struct.jpeg_forward_dct*, %struct.jpeg_forward_dct** %fdct, align 8, !tbaa !82
  %start_pass4 = getelementptr inbounds %struct.jpeg_forward_dct, %struct.jpeg_forward_dct* %10, i64 0, i32 0
  %11 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass4, align 8, !tbaa !83
  call void %11(%struct.jpeg_compress_struct* %cinfo) #4
  %entropy = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %12 = bitcast %struct.jpeg_entropy_encoder** %entropy to void (%struct.jpeg_compress_struct*, i32)***
  %13 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %12, align 8, !tbaa !85
  %14 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %13, align 8, !tbaa !86
  %optimize_coding = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %15 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  call void %14(%struct.jpeg_compress_struct* %cinfo, i32 %15) #4
  %coef = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %16 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef, align 8, !tbaa !88
  %start_pass7 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %16, i64 0, i32 0
  %17 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass7, align 8, !tbaa !89
  %total_passes = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 3
  %18 = load i32, i32* %total_passes, align 8, !tbaa !71
  %cmp = icmp sgt i32 %18, 1
  %cond = select i1 %cmp, i32 3, i32 0
  call void %17(%struct.jpeg_compress_struct* %cinfo, i32 %cond) #4
  %main = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 52
  %19 = load %struct.jpeg_c_main_controller*, %struct.jpeg_c_main_controller** %main, align 8, !tbaa !91
  %start_pass8 = getelementptr inbounds %struct.jpeg_c_main_controller, %struct.jpeg_c_main_controller* %19, i64 0, i32 0
  %20 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass8, align 8, !tbaa !92
  call void %20(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  %21 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  %tobool10.not = icmp eq i32 %21, 0
  br i1 %tobool10.not, label %if.else, label %if.then11

if.then11:                                        ; preds = %if.end
  %call_pass_startup = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup, align 8, !tbaa !94
  br label %sw.epilog

if.else:                                          ; preds = %if.end
  %call_pass_startup13 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 1, i32* %call_pass_startup13, align 8, !tbaa !94
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  %Ss = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
  %22 = load i32, i32* %Ss, align 4, !tbaa !95
  %cmp16.not = icmp eq i32 %22, 0
  br i1 %cmp16.not, label %lor.lhs.false, label %if.then20

lor.lhs.false:                                    ; preds = %sw.bb15
  %Ah = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
  %23 = load i32, i32* %Ah, align 4, !tbaa !96
  %cmp17 = icmp eq i32 %23, 0
  br i1 %cmp17, label %if.then20, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %lor.lhs.false
  %arith_code = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 24
  %24 = load i32, i32* %arith_code, align 4, !tbaa !97
  %tobool19.not = icmp eq i32 %24, 0
  br i1 %tobool19.not, label %if.end28, label %if.then20

if.then20:                                        ; preds = %lor.lhs.false18, %lor.lhs.false, %sw.bb15
  %entropy21 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %25 = bitcast %struct.jpeg_entropy_encoder** %entropy21 to void (%struct.jpeg_compress_struct*, i32)***
  %26 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %25, align 8, !tbaa !85
  %27 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %26, align 8, !tbaa !86
  call void %27(%struct.jpeg_compress_struct* %cinfo, i32 1) #4
  %coef24 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %28 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef24, align 8, !tbaa !88
  %start_pass25 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %28, i64 0, i32 0
  %29 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass25, align 8, !tbaa !89
  call void %29(%struct.jpeg_compress_struct* %cinfo, i32 2) #4
  %call_pass_startup27 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup27, align 8, !tbaa !94
  br label %sw.epilog

if.end28:                                         ; preds = %lor.lhs.false18
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %30 = load i32, i32* %pass_number, align 4, !tbaa !70
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %pass_number, align 4, !tbaa !70
  br label %sw.bb30

sw.bb30:                                          ; preds = %entry, %if.end28
  %optimize_coding31 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %31 = load i32, i32* %optimize_coding31, align 8, !tbaa !67
  %tobool32.not = icmp eq i32 %31, 0
  br i1 %tobool32.not, label %if.then33, label %if.end34

if.then33:                                        ; preds = %sw.bb30
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %sw.bb30
  %entropy35 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %32 = bitcast %struct.jpeg_entropy_encoder** %entropy35 to void (%struct.jpeg_compress_struct*, i32)***
  %33 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %32, align 8, !tbaa !85
  %34 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %33, align 8, !tbaa !86
  call void %34(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  %coef38 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %35 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef38, align 8, !tbaa !88
  %start_pass39 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %35, i64 0, i32 0
  %36 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass39, align 8, !tbaa !89
  call void %36(%struct.jpeg_compress_struct* %cinfo, i32 2) #4
  %scan_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %37 = load i32, i32* %scan_number, align 4, !tbaa !69
  %cmp40 = icmp eq i32 %37, 0
  br i1 %cmp40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.end34
  %marker = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %38 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_frame_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %38, i64 0, i32 2
  %39 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_frame_header, align 8, !tbaa !99
  call void %39(%struct.jpeg_compress_struct* %cinfo) #4
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %if.end34
  %marker43 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %40 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker43, align 8, !tbaa !98
  %write_scan_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %40, i64 0, i32 3
  %41 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_scan_header, align 8, !tbaa !101
  call void %41(%struct.jpeg_compress_struct* %cinfo) #4
  %call_pass_startup45 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup45, align 8, !tbaa !94
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %err = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 0
  %42 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !24
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %42, i64 0, i32 5
  store i32 47, i32* %msg_code, align 8, !tbaa !25
  %43 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !24
  %error_exit = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 0
  %44 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %error_exit, align 8, !tbaa !27
  %45 = bitcast %struct.jpeg_compress_struct* %cinfo to %struct.jpeg_common_struct*
  call void %44(%struct.jpeg_common_struct* %45) #4
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then11, %if.else, %sw.default, %if.end42, %if.then20
  %pass_number47 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %46 = load i32, i32* %pass_number47, align 4, !tbaa !70
  %total_passes48 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 3
  %47 = load i32, i32* %total_passes48, align 8, !tbaa !71
  %sub = add nsw i32 %47, -1
  %cmp49 = icmp eq i32 %46, %sub
  %conv = zext i1 %cmp49 to i32
  %is_last_pass = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 4
  store i32 %conv, i32* %is_last_pass, align 4, !tbaa !19
  %progress = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 2
  %48 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr** %progress, align 8, !tbaa !102
  %cmp51.not = icmp eq %struct.jpeg_progress_mgr* %48, null
  br i1 %cmp51.not, label %if.end59, label %if.then53

if.then53:                                        ; preds = %sw.epilog
  %49 = load i32, i32* %pass_number47, align 4, !tbaa !70
  %completed_passes = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %48, i64 0, i32 3
  store i32 %49, i32* %completed_passes, align 8, !tbaa !103
  %50 = load i32, i32* %total_passes48, align 8, !tbaa !71
  %51 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr** %progress, align 8, !tbaa !102
  %total_passes58 = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %51, i64 0, i32 4
  store i32 %50, i32* %total_passes58, align 4, !tbaa !105
  br label %if.end59

if.end59:                                         ; preds = %if.then53, %sw.epilog
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @pass_startup(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = load %struct.jpeg_comp_master*, %struct.jpeg_comp_master** %master, align 8, !tbaa !13
  %call_pass_startup = getelementptr inbounds %struct.jpeg_comp_master, %struct.jpeg_comp_master* %0, i64 0, i32 3
  store i32 0, i32* %call_pass_startup, align 8, !tbaa !106
  %marker = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %1 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_frame_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %1, i64 0, i32 2
  %2 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_frame_header, align 8, !tbaa !99
  call void %2(%struct.jpeg_compress_struct* %cinfo) #3
  %3 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_scan_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %3, i64 0, i32 3
  %4 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_scan_header, align 8, !tbaa !101
  call void %4(%struct.jpeg_compress_struct* %cinfo) #3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @finish_pass_master(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master1 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = bitcast %struct.jpeg_comp_master** %master1 to %struct.my_comp_master**
  %1 = load %struct.my_comp_master*, %struct.my_comp_master** %0, align 8, !tbaa !13
  %entropy = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %2 = load %struct.jpeg_entropy_encoder*, %struct.jpeg_entropy_encoder** %entropy, align 8, !tbaa !85
  %finish_pass = getelementptr inbounds %struct.jpeg_entropy_encoder, %struct.jpeg_entropy_encoder* %2, i64 0, i32 2
  %3 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %finish_pass, align 8, !tbaa !107
  call void %3(%struct.jpeg_compress_struct* %cinfo) #3
  %pass_type = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 1
  %4 = load i32, i32* %pass_type, align 8, !tbaa !68
  switch i32 %4, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  %optimize_coding = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %5 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  %tobool.not = icmp eq i32 %5, 0
  br i1 %tobool.not, label %if.then, label %sw.epilog

if.then:                                          ; preds = %sw.bb
  %scan_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %6 = load i32, i32* %scan_number, align 4, !tbaa !69
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %scan_number, align 4, !tbaa !69
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %optimize_coding6 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %7 = load i32, i32* %optimize_coding6, align 8, !tbaa !67
  %tobool7.not = icmp eq i32 %7, 0
  br i1 %tobool7.not, label %if.end10, label %if.then8

if.then8:                                         ; preds = %sw.bb5
  store i32 1, i32* %pass_type, align 8, !tbaa !68
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %sw.bb5
  %scan_number11 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %8 = load i32, i32* %scan_number11, align 4, !tbaa !69
  %inc12 = add nsw i32 %8, 1
  store i32 %inc12, i32* %scan_number11, align 4, !tbaa !69
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb, %if.then, %entry, %if.end10, %sw.bb3
  %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %9 = load i32, i32* %pass_number, align 4, !tbaa !70
  %inc13 = add nsw i32 %9, 1
  store i32 %inc13, i32* %pass_number, align 4, !tbaa !70
  ret void
}

GEPSeq2
BinOP?
; Function Attrs: minsize nounwind optsize uwtable
define internal void @prepare_for_pass(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master1 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = bitcast %struct.jpeg_comp_master** %master1 to %struct.my_comp_master**
  %1 = load %struct.my_comp_master*, %struct.my_comp_master** %0, align 8, !tbaa !13
  %pass_type = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 1
  %2 = load i32, i32* %pass_type, align 8, !tbaa !68
  switch i32 %2, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb15
    i32 2, label %sw.bb30
  ]

sw.bb:                                            ; preds = %entry
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  %raw_data_in = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 23
  %3 = load i32, i32* %raw_data_in, align 8, !tbaa !72
  %tobool.not = icmp eq i32 %3, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %cconvert = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 56
  %4 = load %struct.jpeg_color_converter*, %struct.jpeg_color_converter** %cconvert, align 8, !tbaa !73
  %start_pass = getelementptr inbounds %struct.jpeg_color_converter, %struct.jpeg_color_converter* %4, i64 0, i32 0
  %5 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass, align 8, !tbaa !74
  call void %5(%struct.jpeg_compress_struct* %cinfo) #4
  %downsample = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 57
  %6 = load %struct.jpeg_downsampler*, %struct.jpeg_downsampler** %downsample, align 8, !tbaa !76
  %start_pass2 = getelementptr inbounds %struct.jpeg_downsampler, %struct.jpeg_downsampler* %6, i64 0, i32 0
  %7 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass2, align 8, !tbaa !77
  call void %7(%struct.jpeg_compress_struct* %cinfo) #4
  %prep = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 53
  %8 = load %struct.jpeg_c_prep_controller*, %struct.jpeg_c_prep_controller** %prep, align 8, !tbaa !79
  %start_pass3 = getelementptr inbounds %struct.jpeg_c_prep_controller, %struct.jpeg_c_prep_controller* %8, i64 0, i32 0
  %9 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass3, align 8, !tbaa !80
  call void %9(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %fdct = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 58
  %10 = load %struct.jpeg_forward_dct*, %struct.jpeg_forward_dct** %fdct, align 8, !tbaa !82
  %start_pass4 = getelementptr inbounds %struct.jpeg_forward_dct, %struct.jpeg_forward_dct* %10, i64 0, i32 0
  %11 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass4, align 8, !tbaa !83
  call void %11(%struct.jpeg_compress_struct* %cinfo) #4
  %entropy = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %12 = bitcast %struct.jpeg_entropy_encoder** %entropy to void (%struct.jpeg_compress_struct*, i32)***
  %13 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %12, align 8, !tbaa !85
  %14 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %13, align 8, !tbaa !86
  %optimize_coding = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %15 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  call void %14(%struct.jpeg_compress_struct* %cinfo, i32 %15) #4
  %coef = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %16 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef, align 8, !tbaa !88
  %start_pass7 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %16, i64 0, i32 0
  %17 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass7, align 8, !tbaa !89
  %total_passes = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 3
  %18 = load i32, i32* %total_passes, align 8, !tbaa !71
  %cmp = icmp sgt i32 %18, 1
  %cond = select i1 %cmp, i32 3, i32 0
  call void %17(%struct.jpeg_compress_struct* %cinfo, i32 %cond) #4
  %main = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 52
  %19 = load %struct.jpeg_c_main_controller*, %struct.jpeg_c_main_controller** %main, align 8, !tbaa !91
  %start_pass8 = getelementptr inbounds %struct.jpeg_c_main_controller, %struct.jpeg_c_main_controller* %19, i64 0, i32 0
  %20 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass8, align 8, !tbaa !92
  call void %20(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  %21 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  %tobool10.not = icmp eq i32 %21, 0
  br i1 %tobool10.not, label %if.else, label %if.then11

if.then11:                                        ; preds = %if.end
  %call_pass_startup = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup, align 8, !tbaa !94
  br label %sw.epilog

if.else:                                          ; preds = %if.end
  %call_pass_startup13 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 1, i32* %call_pass_startup13, align 8, !tbaa !94
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  %Ss = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
  %22 = load i32, i32* %Ss, align 4, !tbaa !95
  %cmp16.not = icmp eq i32 %22, 0
  br i1 %cmp16.not, label %lor.lhs.false, label %if.then20

lor.lhs.false:                                    ; preds = %sw.bb15
  %Ah = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
  %23 = load i32, i32* %Ah, align 4, !tbaa !96
  %cmp17 = icmp eq i32 %23, 0
  br i1 %cmp17, label %if.then20, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %lor.lhs.false
  %arith_code = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 24
  %24 = load i32, i32* %arith_code, align 4, !tbaa !97
  %tobool19.not = icmp eq i32 %24, 0
  br i1 %tobool19.not, label %if.end28, label %if.then20

if.then20:                                        ; preds = %lor.lhs.false18, %lor.lhs.false, %sw.bb15
  %entropy21 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %25 = bitcast %struct.jpeg_entropy_encoder** %entropy21 to void (%struct.jpeg_compress_struct*, i32)***
  %26 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %25, align 8, !tbaa !85
  %27 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %26, align 8, !tbaa !86
  call void %27(%struct.jpeg_compress_struct* %cinfo, i32 1) #4
  %coef24 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %28 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef24, align 8, !tbaa !88
  %start_pass25 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %28, i64 0, i32 0
  %29 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass25, align 8, !tbaa !89
  call void %29(%struct.jpeg_compress_struct* %cinfo, i32 2) #4
  %call_pass_startup27 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup27, align 8, !tbaa !94
  br label %sw.epilog

if.end28:                                         ; preds = %lor.lhs.false18
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %30 = load i32, i32* %pass_number, align 4, !tbaa !70
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %pass_number, align 4, !tbaa !70
  br label %sw.bb30

sw.bb30:                                          ; preds = %entry, %if.end28
  %optimize_coding31 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %31 = load i32, i32* %optimize_coding31, align 8, !tbaa !67
  %tobool32.not = icmp eq i32 %31, 0
  br i1 %tobool32.not, label %if.then33, label %if.end34

if.then33:                                        ; preds = %sw.bb30
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %sw.bb30
  %entropy35 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %32 = bitcast %struct.jpeg_entropy_encoder** %entropy35 to void (%struct.jpeg_compress_struct*, i32)***
  %33 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %32, align 8, !tbaa !85
  %34 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %33, align 8, !tbaa !86
  call void %34(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  %coef38 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %35 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef38, align 8, !tbaa !88
  %start_pass39 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %35, i64 0, i32 0
  %36 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass39, align 8, !tbaa !89
  call void %36(%struct.jpeg_compress_struct* %cinfo, i32 2) #4
  %scan_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %37 = load i32, i32* %scan_number, align 4, !tbaa !69
  %cmp40 = icmp eq i32 %37, 0
  br i1 %cmp40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.end34
  %marker = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %38 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_frame_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %38, i64 0, i32 2
  %39 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_frame_header, align 8, !tbaa !99
  call void %39(%struct.jpeg_compress_struct* %cinfo) #4
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %if.end34
  %marker43 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %40 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker43, align 8, !tbaa !98
  %write_scan_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %40, i64 0, i32 3
  %41 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_scan_header, align 8, !tbaa !101
  call void %41(%struct.jpeg_compress_struct* %cinfo) #4
  %call_pass_startup45 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup45, align 8, !tbaa !94
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %err = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 0
  %42 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !24
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %42, i64 0, i32 5
  store i32 47, i32* %msg_code, align 8, !tbaa !25
  %43 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !24
  %error_exit = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 0
  %44 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %error_exit, align 8, !tbaa !27
  %45 = bitcast %struct.jpeg_compress_struct* %cinfo to %struct.jpeg_common_struct*
  call void %44(%struct.jpeg_common_struct* %45) #4
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then11, %if.else, %sw.default, %if.end42, %if.then20
  %pass_number47 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %46 = load i32, i32* %pass_number47, align 4, !tbaa !70
  %total_passes48 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 3
  %47 = load i32, i32* %total_passes48, align 8, !tbaa !71
  %sub = add nsw i32 %47, -1
  %cmp49 = icmp eq i32 %46, %sub
  %conv = zext i1 %cmp49 to i32
  %is_last_pass = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 4
  store i32 %conv, i32* %is_last_pass, align 4, !tbaa !19
  %progress = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 2
  %48 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr** %progress, align 8, !tbaa !102
  %cmp51.not = icmp eq %struct.jpeg_progress_mgr* %48, null
  br i1 %cmp51.not, label %if.end59, label %if.then53

if.then53:                                        ; preds = %sw.epilog
  %49 = load i32, i32* %pass_number47, align 4, !tbaa !70
  %completed_passes = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %48, i64 0, i32 3
  store i32 %49, i32* %completed_passes, align 8, !tbaa !103
  %50 = load i32, i32* %total_passes48, align 8, !tbaa !71
  %51 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr** %progress, align 8, !tbaa !102
  %total_passes58 = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %51, i64 0, i32 4
  store i32 %50, i32* %total_passes58, align 4, !tbaa !105
  br label %if.end59

if.end59:                                         ; preds = %if.then53, %sw.epilog
  ret void
}

Mismatching
Creating Node
  %prepare_for_pass = bitcast i8* %call to void (%struct.jpeg_compress_struct*)**
  %4 = bitcast i8* %pass_startup to void (%struct.jpeg_compress_struct*)**
  %5 = bitcast i8* %finish_pass to void (%struct.jpeg_compress_struct*)**
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %call = tail call i8* %1(%struct.jpeg_common_struct* %2, i32 1, i64 48) #3
  %pass_startup = getelementptr inbounds i8, i8* %call, i64 8
  %finish_pass = getelementptr inbounds i8, i8* %call, i64 16
Match: 0
3 x 3
Final Match: 0
  %call = tail call i8* %1(%struct.jpeg_common_struct* %2, i32 1, i64 48) #3
  %pass_startup = getelementptr inbounds i8, i8* %call, i64 8
  %finish_pass = getelementptr inbounds i8, i8* %call, i64 16
Ptr:   %call = tail call i8* %1(%struct.jpeg_common_struct* %2, i32 1, i64 48) #3
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 8
i64 16
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
ScheduleNode: {
  store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
}
ScheduleNode: {
  store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
}
ScheduleNode: {
  store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
}
ScheduleNode: {
  store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
}
Count: 1
Start:   %prepare_for_pass = bitcast i8* %call to void (%struct.jpeg_compress_struct*)**
Non-memory:   %prepare_for_pass = bitcast i8* %call to void (%struct.jpeg_compress_struct*)**
Processing:   store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
Count: 1
Found:   store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
ScheduleNode: {
  store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
}
Non-memory:   %pass_startup = getelementptr inbounds i8, i8* %call, i64 8
Non-memory:   %4 = bitcast i8* %pass_startup to void (%struct.jpeg_compress_struct*)**
Processing:   store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
Count: 1
Found:   store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
ScheduleNode: {
  store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
}
Non-memory:   %finish_pass = getelementptr inbounds i8, i8* %call, i64 16
Non-memory:   %5 = bitcast i8* %finish_pass to void (%struct.jpeg_compress_struct*)**
Processing:   store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
Count: 1
Found:   store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
I:   %is_last_pass = getelementptr inbounds i8, i8* %call, i64 28
Last:   br i1 %cmp.i, label %if.then.i, label %lor.lhs.false.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
  store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
  store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
Generating Mismatch
Mismatched Values:
const: ; Function Attrs: minsize nounwind optsize uwtable
define internal void @prepare_for_pass(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master1 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = bitcast %struct.jpeg_comp_master** %master1 to %struct.my_comp_master**
  %1 = load %struct.my_comp_master*, %struct.my_comp_master** %0, align 8, !tbaa !13
  %pass_type = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 1
  %2 = load i32, i32* %pass_type, align 8, !tbaa !68
  switch i32 %2, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb15
    i32 2, label %sw.bb30
  ]

sw.bb:                                            ; preds = %entry
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  %raw_data_in = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 23
  %3 = load i32, i32* %raw_data_in, align 8, !tbaa !72
  %tobool.not = icmp eq i32 %3, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %cconvert = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 56
  %4 = load %struct.jpeg_color_converter*, %struct.jpeg_color_converter** %cconvert, align 8, !tbaa !73
  %start_pass = getelementptr inbounds %struct.jpeg_color_converter, %struct.jpeg_color_converter* %4, i64 0, i32 0
  %5 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass, align 8, !tbaa !74
  call void %5(%struct.jpeg_compress_struct* %cinfo) #4
  %downsample = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 57
  %6 = load %struct.jpeg_downsampler*, %struct.jpeg_downsampler** %downsample, align 8, !tbaa !76
  %start_pass2 = getelementptr inbounds %struct.jpeg_downsampler, %struct.jpeg_downsampler* %6, i64 0, i32 0
  %7 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass2, align 8, !tbaa !77
  call void %7(%struct.jpeg_compress_struct* %cinfo) #4
  %prep = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 53
  %8 = load %struct.jpeg_c_prep_controller*, %struct.jpeg_c_prep_controller** %prep, align 8, !tbaa !79
  %start_pass3 = getelementptr inbounds %struct.jpeg_c_prep_controller, %struct.jpeg_c_prep_controller* %8, i64 0, i32 0
  %9 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass3, align 8, !tbaa !80
  call void %9(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %fdct = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 58
  %10 = load %struct.jpeg_forward_dct*, %struct.jpeg_forward_dct** %fdct, align 8, !tbaa !82
  %start_pass4 = getelementptr inbounds %struct.jpeg_forward_dct, %struct.jpeg_forward_dct* %10, i64 0, i32 0
  %11 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass4, align 8, !tbaa !83
  call void %11(%struct.jpeg_compress_struct* %cinfo) #4
  %entropy = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %12 = bitcast %struct.jpeg_entropy_encoder** %entropy to void (%struct.jpeg_compress_struct*, i32)***
  %13 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %12, align 8, !tbaa !85
  %14 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %13, align 8, !tbaa !86
  %optimize_coding = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %15 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  call void %14(%struct.jpeg_compress_struct* %cinfo, i32 %15) #4
  %coef = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %16 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef, align 8, !tbaa !88
  %start_pass7 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %16, i64 0, i32 0
  %17 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass7, align 8, !tbaa !89
  %total_passes = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 3
  %18 = load i32, i32* %total_passes, align 8, !tbaa !71
  %cmp = icmp sgt i32 %18, 1
  %cond = select i1 %cmp, i32 3, i32 0
  call void %17(%struct.jpeg_compress_struct* %cinfo, i32 %cond) #4
  %main = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 52
  %19 = load %struct.jpeg_c_main_controller*, %struct.jpeg_c_main_controller** %main, align 8, !tbaa !91
  %start_pass8 = getelementptr inbounds %struct.jpeg_c_main_controller, %struct.jpeg_c_main_controller* %19, i64 0, i32 0
  %20 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass8, align 8, !tbaa !92
  call void %20(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  %21 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  %tobool10.not = icmp eq i32 %21, 0
  br i1 %tobool10.not, label %if.else, label %if.then11

if.then11:                                        ; preds = %if.end
  %call_pass_startup = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup, align 8, !tbaa !94
  br label %sw.epilog

if.else:                                          ; preds = %if.end
  %call_pass_startup13 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 1, i32* %call_pass_startup13, align 8, !tbaa !94
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  %Ss = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
  %22 = load i32, i32* %Ss, align 4, !tbaa !95
  %cmp16.not = icmp eq i32 %22, 0
  br i1 %cmp16.not, label %lor.lhs.false, label %if.then20

lor.lhs.false:                                    ; preds = %sw.bb15
  %Ah = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
  %23 = load i32, i32* %Ah, align 4, !tbaa !96
  %cmp17 = icmp eq i32 %23, 0
  br i1 %cmp17, label %if.then20, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %lor.lhs.false
  %arith_code = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 24
  %24 = load i32, i32* %arith_code, align 4, !tbaa !97
  %tobool19.not = icmp eq i32 %24, 0
  br i1 %tobool19.not, label %if.end28, label %if.then20

if.then20:                                        ; preds = %lor.lhs.false18, %lor.lhs.false, %sw.bb15
  %entropy21 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %25 = bitcast %struct.jpeg_entropy_encoder** %entropy21 to void (%struct.jpeg_compress_struct*, i32)***
  %26 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %25, align 8, !tbaa !85
  %27 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %26, align 8, !tbaa !86
  call void %27(%struct.jpeg_compress_struct* %cinfo, i32 1) #4
  %coef24 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %28 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef24, align 8, !tbaa !88
  %start_pass25 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %28, i64 0, i32 0
  %29 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass25, align 8, !tbaa !89
  call void %29(%struct.jpeg_compress_struct* %cinfo, i32 2) #4
  %call_pass_startup27 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup27, align 8, !tbaa !94
  br label %sw.epilog

if.end28:                                         ; preds = %lor.lhs.false18
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %30 = load i32, i32* %pass_number, align 4, !tbaa !70
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %pass_number, align 4, !tbaa !70
  br label %sw.bb30

sw.bb30:                                          ; preds = %entry, %if.end28
  %optimize_coding31 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %31 = load i32, i32* %optimize_coding31, align 8, !tbaa !67
  %tobool32.not = icmp eq i32 %31, 0
  br i1 %tobool32.not, label %if.then33, label %if.end34

if.then33:                                        ; preds = %sw.bb30
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %sw.bb30
  %entropy35 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %32 = bitcast %struct.jpeg_entropy_encoder** %entropy35 to void (%struct.jpeg_compress_struct*, i32)***
  %33 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %32, align 8, !tbaa !85
  %34 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %33, align 8, !tbaa !86
  call void %34(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  %coef38 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %35 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef38, align 8, !tbaa !88
  %start_pass39 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %35, i64 0, i32 0
  %36 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass39, align 8, !tbaa !89
  call void %36(%struct.jpeg_compress_struct* %cinfo, i32 2) #4
  %scan_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %37 = load i32, i32* %scan_number, align 4, !tbaa !69
  %cmp40 = icmp eq i32 %37, 0
  br i1 %cmp40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.end34
  %marker = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %38 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_frame_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %38, i64 0, i32 2
  %39 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_frame_header, align 8, !tbaa !99
  call void %39(%struct.jpeg_compress_struct* %cinfo) #4
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %if.end34
  %marker43 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %40 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker43, align 8, !tbaa !98
  %write_scan_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %40, i64 0, i32 3
  %41 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_scan_header, align 8, !tbaa !101
  call void %41(%struct.jpeg_compress_struct* %cinfo) #4
  %call_pass_startup45 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup45, align 8, !tbaa !94
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %err = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 0
  %42 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !24
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %42, i64 0, i32 5
  store i32 47, i32* %msg_code, align 8, !tbaa !25
  %43 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !24
  %error_exit = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 0
  %44 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %error_exit, align 8, !tbaa !27
  %45 = bitcast %struct.jpeg_compress_struct* %cinfo to %struct.jpeg_common_struct*
  call void %44(%struct.jpeg_common_struct* %45) #4
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then11, %if.else, %sw.default, %if.end42, %if.then20
  %pass_number47 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %46 = load i32, i32* %pass_number47, align 4, !tbaa !70
  %total_passes48 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 3
  %47 = load i32, i32* %total_passes48, align 8, !tbaa !71
  %sub = add nsw i32 %47, -1
  %cmp49 = icmp eq i32 %46, %sub
  %conv = zext i1 %cmp49 to i32
  %is_last_pass = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 4
  store i32 %conv, i32* %is_last_pass, align 4, !tbaa !19
  %progress = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 2
  %48 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr** %progress, align 8, !tbaa !102
  %cmp51.not = icmp eq %struct.jpeg_progress_mgr* %48, null
  br i1 %cmp51.not, label %if.end59, label %if.then53

if.then53:                                        ; preds = %sw.epilog
  %49 = load i32, i32* %pass_number47, align 4, !tbaa !70
  %completed_passes = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %48, i64 0, i32 3
  store i32 %49, i32* %completed_passes, align 8, !tbaa !103
  %50 = load i32, i32* %total_passes48, align 8, !tbaa !71
  %51 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr** %progress, align 8, !tbaa !102
  %total_passes58 = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %51, i64 0, i32 4
  store i32 %50, i32* %total_passes58, align 4, !tbaa !105
  br label %if.end59

if.end59:                                         ; preds = %if.then53, %sw.epilog
  ret void
}

const: ; Function Attrs: minsize nounwind optsize uwtable
define internal void @pass_startup(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = load %struct.jpeg_comp_master*, %struct.jpeg_comp_master** %master, align 8, !tbaa !13
  %call_pass_startup = getelementptr inbounds %struct.jpeg_comp_master, %struct.jpeg_comp_master* %0, i64 0, i32 3
  store i32 0, i32* %call_pass_startup, align 8, !tbaa !106
  %marker = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %1 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_frame_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %1, i64 0, i32 2
  %2 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_frame_header, align 8, !tbaa !99
  call void %2(%struct.jpeg_compress_struct* %cinfo) #3
  %3 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_scan_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %3, i64 0, i32 3
  %4 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_scan_header, align 8, !tbaa !101
  call void %4(%struct.jpeg_compress_struct* %cinfo) #3
  ret void
}

const: ; Function Attrs: minsize nounwind optsize uwtable
define internal void @finish_pass_master(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master1 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = bitcast %struct.jpeg_comp_master** %master1 to %struct.my_comp_master**
  %1 = load %struct.my_comp_master*, %struct.my_comp_master** %0, align 8, !tbaa !13
  %entropy = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %2 = load %struct.jpeg_entropy_encoder*, %struct.jpeg_entropy_encoder** %entropy, align 8, !tbaa !85
  %finish_pass = getelementptr inbounds %struct.jpeg_entropy_encoder, %struct.jpeg_entropy_encoder* %2, i64 0, i32 2
  %3 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %finish_pass, align 8, !tbaa !107
  call void %3(%struct.jpeg_compress_struct* %cinfo) #3
  %pass_type = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 1
  %4 = load i32, i32* %pass_type, align 8, !tbaa !68
  switch i32 %4, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  %optimize_coding = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %5 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  %tobool.not = icmp eq i32 %5, 0
  br i1 %tobool.not, label %if.then, label %sw.epilog

if.then:                                          ; preds = %sw.bb
  %scan_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %6 = load i32, i32* %scan_number, align 4, !tbaa !69
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %scan_number, align 4, !tbaa !69
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %optimize_coding6 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %7 = load i32, i32* %optimize_coding6, align 8, !tbaa !67
  %tobool7.not = icmp eq i32 %7, 0
  br i1 %tobool7.not, label %if.end10, label %if.then8

if.then8:                                         ; preds = %sw.bb5
  store i32 1, i32* %pass_type, align 8, !tbaa !68
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %sw.bb5
  %scan_number11 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %8 = load i32, i32* %scan_number11, align 4, !tbaa !69
  %inc12 = add nsw i32 %8, 1
  store i32 %inc12, i32* %scan_number11, align 4, !tbaa !69
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb, %if.then, %entry, %if.end10, %sw.bb3
  %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %9 = load i32, i32* %pass_number, align 4, !tbaa !70
  %inc13 = add nsw i32 %9, 1
  store i32 %inc13, i32* %pass_number, align 4, !tbaa !70
  ret void
}

Non constants
Array Type: 3:void (%struct.jpeg_compress_struct*)*
Created array:   %167 = alloca void (%struct.jpeg_compress_struct*)*, i8 3, align 8
Gen:   %173 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %172, align 8
Generating MATCH
Match: 
  %prepare_for_pass = bitcast i8* %call to void (%struct.jpeg_compress_struct*)**
  %4 = bitcast i8* %pass_startup to void (%struct.jpeg_compress_struct*)**
  %5 = bitcast i8* %finish_pass to void (%struct.jpeg_compress_struct*)**
Generating GEPSEQ
Generating INTSEQ
Gen:   %176 = add i64 %175, 0
Closing GEPSEQ
Gen:   %177 = getelementptr i8, i8* %call, i64 %176
Operands done!
Generated:   %178 = bitcast i8* %177 to void (%struct.jpeg_compress_struct*)**
Gen:   %178 = bitcast i8* %177 to void (%struct.jpeg_compress_struct*)**
Operands done!
Generated:   store void (%struct.jpeg_compress_struct*)* %173, void (%struct.jpeg_compress_struct*)** %178, align 1
Gen:   store void (%struct.jpeg_compress_struct*)* %173, void (%struct.jpeg_compress_struct*)** %178, align 1
Graph code generated!
Root:
  store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
  store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
  store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
Root size: 3
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0..16, 8", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->2 
4->3 
}

Gains: 11 - 52 = -41; Width: 3; Unprofitable; jinit_c_master_control
Trying AGAIN
Creating Node
  store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
  store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
  store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
Function: prepare_for_pass
Function: pass_startup
Function: finish_pass_master
Match: 0
3 x 3
Final Match: 0
; Function Attrs: minsize nounwind optsize uwtable
define internal void @prepare_for_pass(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master1 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = bitcast %struct.jpeg_comp_master** %master1 to %struct.my_comp_master**
  %1 = load %struct.my_comp_master*, %struct.my_comp_master** %0, align 8, !tbaa !13
  %pass_type = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 1
  %2 = load i32, i32* %pass_type, align 8, !tbaa !68
  switch i32 %2, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb15
    i32 2, label %sw.bb30
  ]

sw.bb:                                            ; preds = %entry
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  %raw_data_in = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 23
  %3 = load i32, i32* %raw_data_in, align 8, !tbaa !72
  %tobool.not = icmp eq i32 %3, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %cconvert = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 56
  %4 = load %struct.jpeg_color_converter*, %struct.jpeg_color_converter** %cconvert, align 8, !tbaa !73
  %start_pass = getelementptr inbounds %struct.jpeg_color_converter, %struct.jpeg_color_converter* %4, i64 0, i32 0
  %5 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass, align 8, !tbaa !74
  call void %5(%struct.jpeg_compress_struct* %cinfo) #4
  %downsample = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 57
  %6 = load %struct.jpeg_downsampler*, %struct.jpeg_downsampler** %downsample, align 8, !tbaa !76
  %start_pass2 = getelementptr inbounds %struct.jpeg_downsampler, %struct.jpeg_downsampler* %6, i64 0, i32 0
  %7 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass2, align 8, !tbaa !77
  call void %7(%struct.jpeg_compress_struct* %cinfo) #4
  %prep = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 53
  %8 = load %struct.jpeg_c_prep_controller*, %struct.jpeg_c_prep_controller** %prep, align 8, !tbaa !79
  %start_pass3 = getelementptr inbounds %struct.jpeg_c_prep_controller, %struct.jpeg_c_prep_controller* %8, i64 0, i32 0
  %9 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass3, align 8, !tbaa !80
  call void %9(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %fdct = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 58
  %10 = load %struct.jpeg_forward_dct*, %struct.jpeg_forward_dct** %fdct, align 8, !tbaa !82
  %start_pass4 = getelementptr inbounds %struct.jpeg_forward_dct, %struct.jpeg_forward_dct* %10, i64 0, i32 0
  %11 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass4, align 8, !tbaa !83
  call void %11(%struct.jpeg_compress_struct* %cinfo) #4
  %entropy = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %12 = bitcast %struct.jpeg_entropy_encoder** %entropy to void (%struct.jpeg_compress_struct*, i32)***
  %13 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %12, align 8, !tbaa !85
  %14 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %13, align 8, !tbaa !86
  %optimize_coding = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %15 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  call void %14(%struct.jpeg_compress_struct* %cinfo, i32 %15) #4
  %coef = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %16 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef, align 8, !tbaa !88
  %start_pass7 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %16, i64 0, i32 0
  %17 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass7, align 8, !tbaa !89
  %total_passes = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 3
  %18 = load i32, i32* %total_passes, align 8, !tbaa !71
  %cmp = icmp sgt i32 %18, 1
  %cond = select i1 %cmp, i32 3, i32 0
  call void %17(%struct.jpeg_compress_struct* %cinfo, i32 %cond) #4
  %main = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 52
  %19 = load %struct.jpeg_c_main_controller*, %struct.jpeg_c_main_controller** %main, align 8, !tbaa !91
  %start_pass8 = getelementptr inbounds %struct.jpeg_c_main_controller, %struct.jpeg_c_main_controller* %19, i64 0, i32 0
  %20 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass8, align 8, !tbaa !92
  call void %20(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  %21 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  %tobool10.not = icmp eq i32 %21, 0
  br i1 %tobool10.not, label %if.else, label %if.then11

if.then11:                                        ; preds = %if.end
  %call_pass_startup = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup, align 8, !tbaa !94
  br label %sw.epilog

if.else:                                          ; preds = %if.end
  %call_pass_startup13 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 1, i32* %call_pass_startup13, align 8, !tbaa !94
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  %Ss = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
  %22 = load i32, i32* %Ss, align 4, !tbaa !95
  %cmp16.not = icmp eq i32 %22, 0
  br i1 %cmp16.not, label %lor.lhs.false, label %if.then20

lor.lhs.false:                                    ; preds = %sw.bb15
  %Ah = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
  %23 = load i32, i32* %Ah, align 4, !tbaa !96
  %cmp17 = icmp eq i32 %23, 0
  br i1 %cmp17, label %if.then20, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %lor.lhs.false
  %arith_code = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 24
  %24 = load i32, i32* %arith_code, align 4, !tbaa !97
  %tobool19.not = icmp eq i32 %24, 0
  br i1 %tobool19.not, label %if.end28, label %if.then20

if.then20:                                        ; preds = %lor.lhs.false18, %lor.lhs.false, %sw.bb15
  %entropy21 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %25 = bitcast %struct.jpeg_entropy_encoder** %entropy21 to void (%struct.jpeg_compress_struct*, i32)***
  %26 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %25, align 8, !tbaa !85
  %27 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %26, align 8, !tbaa !86
  call void %27(%struct.jpeg_compress_struct* %cinfo, i32 1) #4
  %coef24 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %28 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef24, align 8, !tbaa !88
  %start_pass25 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %28, i64 0, i32 0
  %29 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass25, align 8, !tbaa !89
  call void %29(%struct.jpeg_compress_struct* %cinfo, i32 2) #4
  %call_pass_startup27 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup27, align 8, !tbaa !94
  br label %sw.epilog

if.end28:                                         ; preds = %lor.lhs.false18
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %30 = load i32, i32* %pass_number, align 4, !tbaa !70
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %pass_number, align 4, !tbaa !70
  br label %sw.bb30

sw.bb30:                                          ; preds = %entry, %if.end28
  %optimize_coding31 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %31 = load i32, i32* %optimize_coding31, align 8, !tbaa !67
  %tobool32.not = icmp eq i32 %31, 0
  br i1 %tobool32.not, label %if.then33, label %if.end34

if.then33:                                        ; preds = %sw.bb30
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %sw.bb30
  %entropy35 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %32 = bitcast %struct.jpeg_entropy_encoder** %entropy35 to void (%struct.jpeg_compress_struct*, i32)***
  %33 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %32, align 8, !tbaa !85
  %34 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %33, align 8, !tbaa !86
  call void %34(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  %coef38 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %35 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef38, align 8, !tbaa !88
  %start_pass39 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %35, i64 0, i32 0
  %36 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass39, align 8, !tbaa !89
  call void %36(%struct.jpeg_compress_struct* %cinfo, i32 2) #4
  %scan_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %37 = load i32, i32* %scan_number, align 4, !tbaa !69
  %cmp40 = icmp eq i32 %37, 0
  br i1 %cmp40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.end34
  %marker = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %38 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_frame_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %38, i64 0, i32 2
  %39 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_frame_header, align 8, !tbaa !99
  call void %39(%struct.jpeg_compress_struct* %cinfo) #4
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %if.end34
  %marker43 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %40 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker43, align 8, !tbaa !98
  %write_scan_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %40, i64 0, i32 3
  %41 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_scan_header, align 8, !tbaa !101
  call void %41(%struct.jpeg_compress_struct* %cinfo) #4
  %call_pass_startup45 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup45, align 8, !tbaa !94
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %err = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 0
  %42 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !24
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %42, i64 0, i32 5
  store i32 47, i32* %msg_code, align 8, !tbaa !25
  %43 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !24
  %error_exit = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 0
  %44 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %error_exit, align 8, !tbaa !27
  %45 = bitcast %struct.jpeg_compress_struct* %cinfo to %struct.jpeg_common_struct*
  call void %44(%struct.jpeg_common_struct* %45) #4
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then11, %if.else, %sw.default, %if.end42, %if.then20
  %pass_number47 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %46 = load i32, i32* %pass_number47, align 4, !tbaa !70
  %total_passes48 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 3
  %47 = load i32, i32* %total_passes48, align 8, !tbaa !71
  %sub = add nsw i32 %47, -1
  %cmp49 = icmp eq i32 %46, %sub
  %conv = zext i1 %cmp49 to i32
  %is_last_pass = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 4
  store i32 %conv, i32* %is_last_pass, align 4, !tbaa !19
  %progress = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 2
  %48 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr** %progress, align 8, !tbaa !102
  %cmp51.not = icmp eq %struct.jpeg_progress_mgr* %48, null
  br i1 %cmp51.not, label %if.end59, label %if.then53

if.then53:                                        ; preds = %sw.epilog
  %49 = load i32, i32* %pass_number47, align 4, !tbaa !70
  %completed_passes = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %48, i64 0, i32 3
  store i32 %49, i32* %completed_passes, align 8, !tbaa !103
  %50 = load i32, i32* %total_passes48, align 8, !tbaa !71
  %51 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr** %progress, align 8, !tbaa !102
  %total_passes58 = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %51, i64 0, i32 4
  store i32 %50, i32* %total_passes58, align 4, !tbaa !105
  br label %if.end59

if.end59:                                         ; preds = %if.then53, %sw.epilog
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @pass_startup(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = load %struct.jpeg_comp_master*, %struct.jpeg_comp_master** %master, align 8, !tbaa !13
  %call_pass_startup = getelementptr inbounds %struct.jpeg_comp_master, %struct.jpeg_comp_master* %0, i64 0, i32 3
  store i32 0, i32* %call_pass_startup, align 8, !tbaa !106
  %marker = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %1 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_frame_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %1, i64 0, i32 2
  %2 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_frame_header, align 8, !tbaa !99
  call void %2(%struct.jpeg_compress_struct* %cinfo) #3
  %3 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_scan_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %3, i64 0, i32 3
  %4 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_scan_header, align 8, !tbaa !101
  call void %4(%struct.jpeg_compress_struct* %cinfo) #3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @finish_pass_master(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master1 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = bitcast %struct.jpeg_comp_master** %master1 to %struct.my_comp_master**
  %1 = load %struct.my_comp_master*, %struct.my_comp_master** %0, align 8, !tbaa !13
  %entropy = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %2 = load %struct.jpeg_entropy_encoder*, %struct.jpeg_entropy_encoder** %entropy, align 8, !tbaa !85
  %finish_pass = getelementptr inbounds %struct.jpeg_entropy_encoder, %struct.jpeg_entropy_encoder* %2, i64 0, i32 2
  %3 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %finish_pass, align 8, !tbaa !107
  call void %3(%struct.jpeg_compress_struct* %cinfo) #3
  %pass_type = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 1
  %4 = load i32, i32* %pass_type, align 8, !tbaa !68
  switch i32 %4, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  %optimize_coding = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %5 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  %tobool.not = icmp eq i32 %5, 0
  br i1 %tobool.not, label %if.then, label %sw.epilog

if.then:                                          ; preds = %sw.bb
  %scan_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %6 = load i32, i32* %scan_number, align 4, !tbaa !69
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %scan_number, align 4, !tbaa !69
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %optimize_coding6 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %7 = load i32, i32* %optimize_coding6, align 8, !tbaa !67
  %tobool7.not = icmp eq i32 %7, 0
  br i1 %tobool7.not, label %if.end10, label %if.then8

if.then8:                                         ; preds = %sw.bb5
  store i32 1, i32* %pass_type, align 8, !tbaa !68
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %sw.bb5
  %scan_number11 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %8 = load i32, i32* %scan_number11, align 4, !tbaa !69
  %inc12 = add nsw i32 %8, 1
  store i32 %inc12, i32* %scan_number11, align 4, !tbaa !69
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb, %if.then, %entry, %if.end10, %sw.bb3
  %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %9 = load i32, i32* %pass_number, align 4, !tbaa !70
  %inc13 = add nsw i32 %9, 1
  store i32 %inc13, i32* %pass_number, align 4, !tbaa !70
  ret void
}

GEPSeq2
BinOP?
; Function Attrs: minsize nounwind optsize uwtable
define internal void @prepare_for_pass(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master1 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = bitcast %struct.jpeg_comp_master** %master1 to %struct.my_comp_master**
  %1 = load %struct.my_comp_master*, %struct.my_comp_master** %0, align 8, !tbaa !13
  %pass_type = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 1
  %2 = load i32, i32* %pass_type, align 8, !tbaa !68
  switch i32 %2, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb15
    i32 2, label %sw.bb30
  ]

sw.bb:                                            ; preds = %entry
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  %raw_data_in = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 23
  %3 = load i32, i32* %raw_data_in, align 8, !tbaa !72
  %tobool.not = icmp eq i32 %3, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %cconvert = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 56
  %4 = load %struct.jpeg_color_converter*, %struct.jpeg_color_converter** %cconvert, align 8, !tbaa !73
  %start_pass = getelementptr inbounds %struct.jpeg_color_converter, %struct.jpeg_color_converter* %4, i64 0, i32 0
  %5 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass, align 8, !tbaa !74
  call void %5(%struct.jpeg_compress_struct* %cinfo) #4
  %downsample = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 57
  %6 = load %struct.jpeg_downsampler*, %struct.jpeg_downsampler** %downsample, align 8, !tbaa !76
  %start_pass2 = getelementptr inbounds %struct.jpeg_downsampler, %struct.jpeg_downsampler* %6, i64 0, i32 0
  %7 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass2, align 8, !tbaa !77
  call void %7(%struct.jpeg_compress_struct* %cinfo) #4
  %prep = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 53
  %8 = load %struct.jpeg_c_prep_controller*, %struct.jpeg_c_prep_controller** %prep, align 8, !tbaa !79
  %start_pass3 = getelementptr inbounds %struct.jpeg_c_prep_controller, %struct.jpeg_c_prep_controller* %8, i64 0, i32 0
  %9 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass3, align 8, !tbaa !80
  call void %9(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %fdct = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 58
  %10 = load %struct.jpeg_forward_dct*, %struct.jpeg_forward_dct** %fdct, align 8, !tbaa !82
  %start_pass4 = getelementptr inbounds %struct.jpeg_forward_dct, %struct.jpeg_forward_dct* %10, i64 0, i32 0
  %11 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass4, align 8, !tbaa !83
  call void %11(%struct.jpeg_compress_struct* %cinfo) #4
  %entropy = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %12 = bitcast %struct.jpeg_entropy_encoder** %entropy to void (%struct.jpeg_compress_struct*, i32)***
  %13 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %12, align 8, !tbaa !85
  %14 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %13, align 8, !tbaa !86
  %optimize_coding = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %15 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  call void %14(%struct.jpeg_compress_struct* %cinfo, i32 %15) #4
  %coef = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %16 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef, align 8, !tbaa !88
  %start_pass7 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %16, i64 0, i32 0
  %17 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass7, align 8, !tbaa !89
  %total_passes = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 3
  %18 = load i32, i32* %total_passes, align 8, !tbaa !71
  %cmp = icmp sgt i32 %18, 1
  %cond = select i1 %cmp, i32 3, i32 0
  call void %17(%struct.jpeg_compress_struct* %cinfo, i32 %cond) #4
  %main = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 52
  %19 = load %struct.jpeg_c_main_controller*, %struct.jpeg_c_main_controller** %main, align 8, !tbaa !91
  %start_pass8 = getelementptr inbounds %struct.jpeg_c_main_controller, %struct.jpeg_c_main_controller* %19, i64 0, i32 0
  %20 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass8, align 8, !tbaa !92
  call void %20(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  %21 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  %tobool10.not = icmp eq i32 %21, 0
  br i1 %tobool10.not, label %if.else, label %if.then11

if.then11:                                        ; preds = %if.end
  %call_pass_startup = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup, align 8, !tbaa !94
  br label %sw.epilog

if.else:                                          ; preds = %if.end
  %call_pass_startup13 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 1, i32* %call_pass_startup13, align 8, !tbaa !94
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  %Ss = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
  %22 = load i32, i32* %Ss, align 4, !tbaa !95
  %cmp16.not = icmp eq i32 %22, 0
  br i1 %cmp16.not, label %lor.lhs.false, label %if.then20

lor.lhs.false:                                    ; preds = %sw.bb15
  %Ah = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
  %23 = load i32, i32* %Ah, align 4, !tbaa !96
  %cmp17 = icmp eq i32 %23, 0
  br i1 %cmp17, label %if.then20, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %lor.lhs.false
  %arith_code = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 24
  %24 = load i32, i32* %arith_code, align 4, !tbaa !97
  %tobool19.not = icmp eq i32 %24, 0
  br i1 %tobool19.not, label %if.end28, label %if.then20

if.then20:                                        ; preds = %lor.lhs.false18, %lor.lhs.false, %sw.bb15
  %entropy21 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %25 = bitcast %struct.jpeg_entropy_encoder** %entropy21 to void (%struct.jpeg_compress_struct*, i32)***
  %26 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %25, align 8, !tbaa !85
  %27 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %26, align 8, !tbaa !86
  call void %27(%struct.jpeg_compress_struct* %cinfo, i32 1) #4
  %coef24 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %28 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef24, align 8, !tbaa !88
  %start_pass25 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %28, i64 0, i32 0
  %29 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass25, align 8, !tbaa !89
  call void %29(%struct.jpeg_compress_struct* %cinfo, i32 2) #4
  %call_pass_startup27 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup27, align 8, !tbaa !94
  br label %sw.epilog

if.end28:                                         ; preds = %lor.lhs.false18
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %30 = load i32, i32* %pass_number, align 4, !tbaa !70
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %pass_number, align 4, !tbaa !70
  br label %sw.bb30

sw.bb30:                                          ; preds = %entry, %if.end28
  %optimize_coding31 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %31 = load i32, i32* %optimize_coding31, align 8, !tbaa !67
  %tobool32.not = icmp eq i32 %31, 0
  br i1 %tobool32.not, label %if.then33, label %if.end34

if.then33:                                        ; preds = %sw.bb30
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %sw.bb30
  %entropy35 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %32 = bitcast %struct.jpeg_entropy_encoder** %entropy35 to void (%struct.jpeg_compress_struct*, i32)***
  %33 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %32, align 8, !tbaa !85
  %34 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %33, align 8, !tbaa !86
  call void %34(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  %coef38 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %35 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef38, align 8, !tbaa !88
  %start_pass39 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %35, i64 0, i32 0
  %36 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass39, align 8, !tbaa !89
  call void %36(%struct.jpeg_compress_struct* %cinfo, i32 2) #4
  %scan_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %37 = load i32, i32* %scan_number, align 4, !tbaa !69
  %cmp40 = icmp eq i32 %37, 0
  br i1 %cmp40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.end34
  %marker = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %38 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_frame_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %38, i64 0, i32 2
  %39 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_frame_header, align 8, !tbaa !99
  call void %39(%struct.jpeg_compress_struct* %cinfo) #4
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %if.end34
  %marker43 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %40 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker43, align 8, !tbaa !98
  %write_scan_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %40, i64 0, i32 3
  %41 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_scan_header, align 8, !tbaa !101
  call void %41(%struct.jpeg_compress_struct* %cinfo) #4
  %call_pass_startup45 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup45, align 8, !tbaa !94
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %err = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 0
  %42 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !24
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %42, i64 0, i32 5
  store i32 47, i32* %msg_code, align 8, !tbaa !25
  %43 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !24
  %error_exit = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 0
  %44 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %error_exit, align 8, !tbaa !27
  %45 = bitcast %struct.jpeg_compress_struct* %cinfo to %struct.jpeg_common_struct*
  call void %44(%struct.jpeg_common_struct* %45) #4
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then11, %if.else, %sw.default, %if.end42, %if.then20
  %pass_number47 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %46 = load i32, i32* %pass_number47, align 4, !tbaa !70
  %total_passes48 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 3
  %47 = load i32, i32* %total_passes48, align 8, !tbaa !71
  %sub = add nsw i32 %47, -1
  %cmp49 = icmp eq i32 %46, %sub
  %conv = zext i1 %cmp49 to i32
  %is_last_pass = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 4
  store i32 %conv, i32* %is_last_pass, align 4, !tbaa !19
  %progress = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 2
  %48 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr** %progress, align 8, !tbaa !102
  %cmp51.not = icmp eq %struct.jpeg_progress_mgr* %48, null
  br i1 %cmp51.not, label %if.end59, label %if.then53

if.then53:                                        ; preds = %sw.epilog
  %49 = load i32, i32* %pass_number47, align 4, !tbaa !70
  %completed_passes = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %48, i64 0, i32 3
  store i32 %49, i32* %completed_passes, align 8, !tbaa !103
  %50 = load i32, i32* %total_passes48, align 8, !tbaa !71
  %51 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr** %progress, align 8, !tbaa !102
  %total_passes58 = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %51, i64 0, i32 4
  store i32 %50, i32* %total_passes58, align 4, !tbaa !105
  br label %if.end59

if.end59:                                         ; preds = %if.then53, %sw.epilog
  ret void
}

Mismatching
Creating Node
  %prepare_for_pass = bitcast i8* %call to void (%struct.jpeg_compress_struct*)**
  %4 = bitcast i8* %pass_startup to void (%struct.jpeg_compress_struct*)**
  %5 = bitcast i8* %finish_pass to void (%struct.jpeg_compress_struct*)**
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %call = tail call i8* %1(%struct.jpeg_common_struct* %2, i32 1, i64 48) #3
  %pass_startup = getelementptr inbounds i8, i8* %call, i64 8
  %finish_pass = getelementptr inbounds i8, i8* %call, i64 16
Match: 0
3 x 3
Final Match: 0
  %call = tail call i8* %1(%struct.jpeg_common_struct* %2, i32 1, i64 48) #3
  %pass_startup = getelementptr inbounds i8, i8* %call, i64 8
  %finish_pass = getelementptr inbounds i8, i8* %call, i64 16
Ptr:   %call = tail call i8* %1(%struct.jpeg_common_struct* %2, i32 1, i64 48) #3
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 8
i64 16
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
ScheduleNode: {
  store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
}
ScheduleNode: {
  store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
}
ScheduleNode: {
  store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
}
ScheduleNode: {
  store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
}
Count: 1
Start:   %prepare_for_pass = bitcast i8* %call to void (%struct.jpeg_compress_struct*)**
Non-memory:   %prepare_for_pass = bitcast i8* %call to void (%struct.jpeg_compress_struct*)**
Processing:   store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
Count: 1
Found:   store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
ScheduleNode: {
  store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
}
Non-memory:   %pass_startup = getelementptr inbounds i8, i8* %call, i64 8
Non-memory:   %4 = bitcast i8* %pass_startup to void (%struct.jpeg_compress_struct*)**
Processing:   store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
Count: 1
Found:   store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
ScheduleNode: {
  store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
}
Non-memory:   %finish_pass = getelementptr inbounds i8, i8* %call, i64 16
Non-memory:   %5 = bitcast i8* %finish_pass to void (%struct.jpeg_compress_struct*)**
Processing:   store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
Count: 1
Found:   store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
I:   %is_last_pass = getelementptr inbounds i8, i8* %call, i64 28
Last:   br i1 %cmp.i, label %if.then.i, label %lor.lhs.false.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
  store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
  store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
Generating Mismatch
Mismatched Values:
const: ; Function Attrs: minsize nounwind optsize uwtable
define internal void @prepare_for_pass(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master1 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = bitcast %struct.jpeg_comp_master** %master1 to %struct.my_comp_master**
  %1 = load %struct.my_comp_master*, %struct.my_comp_master** %0, align 8, !tbaa !13
  %pass_type = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 1
  %2 = load i32, i32* %pass_type, align 8, !tbaa !68
  switch i32 %2, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb15
    i32 2, label %sw.bb30
  ]

sw.bb:                                            ; preds = %entry
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  %raw_data_in = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 23
  %3 = load i32, i32* %raw_data_in, align 8, !tbaa !72
  %tobool.not = icmp eq i32 %3, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %cconvert = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 56
  %4 = load %struct.jpeg_color_converter*, %struct.jpeg_color_converter** %cconvert, align 8, !tbaa !73
  %start_pass = getelementptr inbounds %struct.jpeg_color_converter, %struct.jpeg_color_converter* %4, i64 0, i32 0
  %5 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass, align 8, !tbaa !74
  call void %5(%struct.jpeg_compress_struct* %cinfo) #4
  %downsample = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 57
  %6 = load %struct.jpeg_downsampler*, %struct.jpeg_downsampler** %downsample, align 8, !tbaa !76
  %start_pass2 = getelementptr inbounds %struct.jpeg_downsampler, %struct.jpeg_downsampler* %6, i64 0, i32 0
  %7 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass2, align 8, !tbaa !77
  call void %7(%struct.jpeg_compress_struct* %cinfo) #4
  %prep = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 53
  %8 = load %struct.jpeg_c_prep_controller*, %struct.jpeg_c_prep_controller** %prep, align 8, !tbaa !79
  %start_pass3 = getelementptr inbounds %struct.jpeg_c_prep_controller, %struct.jpeg_c_prep_controller* %8, i64 0, i32 0
  %9 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass3, align 8, !tbaa !80
  call void %9(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %fdct = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 58
  %10 = load %struct.jpeg_forward_dct*, %struct.jpeg_forward_dct** %fdct, align 8, !tbaa !82
  %start_pass4 = getelementptr inbounds %struct.jpeg_forward_dct, %struct.jpeg_forward_dct* %10, i64 0, i32 0
  %11 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %start_pass4, align 8, !tbaa !83
  call void %11(%struct.jpeg_compress_struct* %cinfo) #4
  %entropy = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %12 = bitcast %struct.jpeg_entropy_encoder** %entropy to void (%struct.jpeg_compress_struct*, i32)***
  %13 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %12, align 8, !tbaa !85
  %14 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %13, align 8, !tbaa !86
  %optimize_coding = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %15 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  call void %14(%struct.jpeg_compress_struct* %cinfo, i32 %15) #4
  %coef = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %16 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef, align 8, !tbaa !88
  %start_pass7 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %16, i64 0, i32 0
  %17 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass7, align 8, !tbaa !89
  %total_passes = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 3
  %18 = load i32, i32* %total_passes, align 8, !tbaa !71
  %cmp = icmp sgt i32 %18, 1
  %cond = select i1 %cmp, i32 3, i32 0
  call void %17(%struct.jpeg_compress_struct* %cinfo, i32 %cond) #4
  %main = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 52
  %19 = load %struct.jpeg_c_main_controller*, %struct.jpeg_c_main_controller** %main, align 8, !tbaa !91
  %start_pass8 = getelementptr inbounds %struct.jpeg_c_main_controller, %struct.jpeg_c_main_controller* %19, i64 0, i32 0
  %20 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass8, align 8, !tbaa !92
  call void %20(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  %21 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  %tobool10.not = icmp eq i32 %21, 0
  br i1 %tobool10.not, label %if.else, label %if.then11

if.then11:                                        ; preds = %if.end
  %call_pass_startup = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup, align 8, !tbaa !94
  br label %sw.epilog

if.else:                                          ; preds = %if.end
  %call_pass_startup13 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 1, i32* %call_pass_startup13, align 8, !tbaa !94
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  %Ss = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
  %22 = load i32, i32* %Ss, align 4, !tbaa !95
  %cmp16.not = icmp eq i32 %22, 0
  br i1 %cmp16.not, label %lor.lhs.false, label %if.then20

lor.lhs.false:                                    ; preds = %sw.bb15
  %Ah = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
  %23 = load i32, i32* %Ah, align 4, !tbaa !96
  %cmp17 = icmp eq i32 %23, 0
  br i1 %cmp17, label %if.then20, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %lor.lhs.false
  %arith_code = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 24
  %24 = load i32, i32* %arith_code, align 4, !tbaa !97
  %tobool19.not = icmp eq i32 %24, 0
  br i1 %tobool19.not, label %if.end28, label %if.then20

if.then20:                                        ; preds = %lor.lhs.false18, %lor.lhs.false, %sw.bb15
  %entropy21 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %25 = bitcast %struct.jpeg_entropy_encoder** %entropy21 to void (%struct.jpeg_compress_struct*, i32)***
  %26 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %25, align 8, !tbaa !85
  %27 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %26, align 8, !tbaa !86
  call void %27(%struct.jpeg_compress_struct* %cinfo, i32 1) #4
  %coef24 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %28 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef24, align 8, !tbaa !88
  %start_pass25 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %28, i64 0, i32 0
  %29 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass25, align 8, !tbaa !89
  call void %29(%struct.jpeg_compress_struct* %cinfo, i32 2) #4
  %call_pass_startup27 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup27, align 8, !tbaa !94
  br label %sw.epilog

if.end28:                                         ; preds = %lor.lhs.false18
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %30 = load i32, i32* %pass_number, align 4, !tbaa !70
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %pass_number, align 4, !tbaa !70
  br label %sw.bb30

sw.bb30:                                          ; preds = %entry, %if.end28
  %optimize_coding31 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %31 = load i32, i32* %optimize_coding31, align 8, !tbaa !67
  %tobool32.not = icmp eq i32 %31, 0
  br i1 %tobool32.not, label %if.then33, label %if.end34

if.then33:                                        ; preds = %sw.bb30
  call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* %cinfo) #3
  call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* %cinfo) #3
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %sw.bb30
  %entropy35 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %32 = bitcast %struct.jpeg_entropy_encoder** %entropy35 to void (%struct.jpeg_compress_struct*, i32)***
  %33 = load void (%struct.jpeg_compress_struct*, i32)**, void (%struct.jpeg_compress_struct*, i32)*** %32, align 8, !tbaa !85
  %34 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %33, align 8, !tbaa !86
  call void %34(%struct.jpeg_compress_struct* %cinfo, i32 0) #4
  %coef38 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 54
  %35 = load %struct.jpeg_c_coef_controller*, %struct.jpeg_c_coef_controller** %coef38, align 8, !tbaa !88
  %start_pass39 = getelementptr inbounds %struct.jpeg_c_coef_controller, %struct.jpeg_c_coef_controller* %35, i64 0, i32 0
  %36 = load void (%struct.jpeg_compress_struct*, i32)*, void (%struct.jpeg_compress_struct*, i32)** %start_pass39, align 8, !tbaa !89
  call void %36(%struct.jpeg_compress_struct* %cinfo, i32 2) #4
  %scan_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %37 = load i32, i32* %scan_number, align 4, !tbaa !69
  %cmp40 = icmp eq i32 %37, 0
  br i1 %cmp40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.end34
  %marker = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %38 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_frame_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %38, i64 0, i32 2
  %39 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_frame_header, align 8, !tbaa !99
  call void %39(%struct.jpeg_compress_struct* %cinfo) #4
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %if.end34
  %marker43 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %40 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker43, align 8, !tbaa !98
  %write_scan_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %40, i64 0, i32 3
  %41 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_scan_header, align 8, !tbaa !101
  call void %41(%struct.jpeg_compress_struct* %cinfo) #4
  %call_pass_startup45 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 3
  store i32 0, i32* %call_pass_startup45, align 8, !tbaa !94
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %err = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 0
  %42 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !24
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %42, i64 0, i32 5
  store i32 47, i32* %msg_code, align 8, !tbaa !25
  %43 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !24
  %error_exit = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %43, i64 0, i32 0
  %44 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %error_exit, align 8, !tbaa !27
  %45 = bitcast %struct.jpeg_compress_struct* %cinfo to %struct.jpeg_common_struct*
  call void %44(%struct.jpeg_common_struct* %45) #4
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then11, %if.else, %sw.default, %if.end42, %if.then20
  %pass_number47 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %46 = load i32, i32* %pass_number47, align 4, !tbaa !70
  %total_passes48 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 3
  %47 = load i32, i32* %total_passes48, align 8, !tbaa !71
  %sub = add nsw i32 %47, -1
  %cmp49 = icmp eq i32 %46, %sub
  %conv = zext i1 %cmp49 to i32
  %is_last_pass = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 0, i32 4
  store i32 %conv, i32* %is_last_pass, align 4, !tbaa !19
  %progress = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 2
  %48 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr** %progress, align 8, !tbaa !102
  %cmp51.not = icmp eq %struct.jpeg_progress_mgr* %48, null
  br i1 %cmp51.not, label %if.end59, label %if.then53

if.then53:                                        ; preds = %sw.epilog
  %49 = load i32, i32* %pass_number47, align 4, !tbaa !70
  %completed_passes = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %48, i64 0, i32 3
  store i32 %49, i32* %completed_passes, align 8, !tbaa !103
  %50 = load i32, i32* %total_passes48, align 8, !tbaa !71
  %51 = load %struct.jpeg_progress_mgr*, %struct.jpeg_progress_mgr** %progress, align 8, !tbaa !102
  %total_passes58 = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %51, i64 0, i32 4
  store i32 %50, i32* %total_passes58, align 4, !tbaa !105
  br label %if.end59

if.end59:                                         ; preds = %if.then53, %sw.epilog
  ret void
}

const: ; Function Attrs: minsize nounwind optsize uwtable
define internal void @pass_startup(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = load %struct.jpeg_comp_master*, %struct.jpeg_comp_master** %master, align 8, !tbaa !13
  %call_pass_startup = getelementptr inbounds %struct.jpeg_comp_master, %struct.jpeg_comp_master* %0, i64 0, i32 3
  store i32 0, i32* %call_pass_startup, align 8, !tbaa !106
  %marker = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 55
  %1 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_frame_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %1, i64 0, i32 2
  %2 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_frame_header, align 8, !tbaa !99
  call void %2(%struct.jpeg_compress_struct* %cinfo) #3
  %3 = load %struct.jpeg_marker_writer*, %struct.jpeg_marker_writer** %marker, align 8, !tbaa !98
  %write_scan_header = getelementptr inbounds %struct.jpeg_marker_writer, %struct.jpeg_marker_writer* %3, i64 0, i32 3
  %4 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %write_scan_header, align 8, !tbaa !101
  call void %4(%struct.jpeg_compress_struct* %cinfo) #3
  ret void
}

const: ; Function Attrs: minsize nounwind optsize uwtable
define internal void @finish_pass_master(%struct.jpeg_compress_struct* %cinfo) #0 {
entry:
  %master1 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %0 = bitcast %struct.jpeg_comp_master** %master1 to %struct.my_comp_master**
  %1 = load %struct.my_comp_master*, %struct.my_comp_master** %0, align 8, !tbaa !13
  %entropy = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 59
  %2 = load %struct.jpeg_entropy_encoder*, %struct.jpeg_entropy_encoder** %entropy, align 8, !tbaa !85
  %finish_pass = getelementptr inbounds %struct.jpeg_entropy_encoder, %struct.jpeg_entropy_encoder* %2, i64 0, i32 2
  %3 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %finish_pass, align 8, !tbaa !107
  call void %3(%struct.jpeg_compress_struct* %cinfo) #3
  %pass_type = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 1
  %4 = load i32, i32* %pass_type, align 8, !tbaa !68
  switch i32 %4, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  %optimize_coding = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %5 = load i32, i32* %optimize_coding, align 8, !tbaa !67
  %tobool.not = icmp eq i32 %5, 0
  br i1 %tobool.not, label %if.then, label %sw.epilog

if.then:                                          ; preds = %sw.bb
  %scan_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %6 = load i32, i32* %scan_number, align 4, !tbaa !69
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %scan_number, align 4, !tbaa !69
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  store i32 2, i32* %pass_type, align 8, !tbaa !68
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %optimize_coding6 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %7 = load i32, i32* %optimize_coding6, align 8, !tbaa !67
  %tobool7.not = icmp eq i32 %7, 0
  br i1 %tobool7.not, label %if.end10, label %if.then8

if.then8:                                         ; preds = %sw.bb5
  store i32 1, i32* %pass_type, align 8, !tbaa !68
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %sw.bb5
  %scan_number11 = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 4
  %8 = load i32, i32* %scan_number11, align 4, !tbaa !69
  %inc12 = add nsw i32 %8, 1
  store i32 %inc12, i32* %scan_number11, align 4, !tbaa !69
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb, %if.then, %entry, %if.end10, %sw.bb3
  %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %9 = load i32, i32* %pass_number, align 4, !tbaa !70
  %inc13 = add nsw i32 %9, 1
  store i32 %inc13, i32* %pass_number, align 4, !tbaa !70
  ret void
}

Non constants
Array Type: 3:void (%struct.jpeg_compress_struct*)*
Created array:   %167 = alloca void (%struct.jpeg_compress_struct*)*, i8 3, align 8
Gen:   %173 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %172, align 8
Generating MATCH
Match: 
  %prepare_for_pass = bitcast i8* %call to void (%struct.jpeg_compress_struct*)**
  %4 = bitcast i8* %pass_startup to void (%struct.jpeg_compress_struct*)**
  %5 = bitcast i8* %finish_pass to void (%struct.jpeg_compress_struct*)**
Generating GEPSEQ
Generating INTSEQ
Gen:   %176 = add i64 %175, 0
Closing GEPSEQ
Gen:   %177 = getelementptr i8, i8* %call, i64 %176
Operands done!
Generated:   %178 = bitcast i8* %177 to void (%struct.jpeg_compress_struct*)**
Gen:   %178 = bitcast i8* %177 to void (%struct.jpeg_compress_struct*)**
Operands done!
Generated:   store void (%struct.jpeg_compress_struct*)* %173, void (%struct.jpeg_compress_struct*)** %178, align 1
Gen:   store void (%struct.jpeg_compress_struct*)* %173, void (%struct.jpeg_compress_struct*)** %178, align 1
Graph code generated!
Root:
  store void (%struct.jpeg_compress_struct*)* @prepare_for_pass, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !14
  store void (%struct.jpeg_compress_struct*)* @pass_startup, void (%struct.jpeg_compress_struct*)** %4, align 8, !tbaa !17
  store void (%struct.jpeg_compress_struct*)* @finish_pass_master, void (%struct.jpeg_compress_struct*)** %5, align 8, !tbaa !18
Root size: 3
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0..16, 8", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->2 
4->3 
}

Gains: 11 - 52 = -41; Width: 3; Unprofitable; jinit_c_master_control
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 31, i32* %msg_code.i, align 8, !tbaa !25
  %13 = phi i32 [ %.pre.i, %if.then.i ], [ %7, %lor.lhs.false4.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 40, i32* %msg_code17.i, align 8, !tbaa !25
  store i32 65500, i32* %arrayidx.i, align 4, !tbaa !28
Creating Node
  store i32 40, i32* %msg_code17.i, align 8, !tbaa !25
  store i32 65500, i32* %arrayidx.i, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 40
i32 65500
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 40
Int Seq
Creating Node
  %msg_code17.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %15, i64 0, i32 5
  %arrayidx.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %15, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code17.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %15, i64 0, i32 5
  %arrayidx.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %15, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code17.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %15, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 40, i32* %msg_code17.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 65500, i32* %arrayidx.i, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 40, i32* %msg_code17.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 40, i32* %msg_code17.i, align 8, !tbaa !25
Processing:   store i32 40, i32* %msg_code17.i, align 8, !tbaa !25
Count: 1
Found:   store i32 40, i32* %msg_code17.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 65500, i32* %arrayidx.i, align 4, !tbaa !28
}
Non-memory:   %arrayidx.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %15, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 65500, i32* %arrayidx.i, align 4, !tbaa !28
Count: 1
Found:   store i32 65500, i32* %arrayidx.i, align 4, !tbaa !28
I:   %16 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err16.i, align 8, !tbaa !24
Last:   br label %if.end21.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 40, i32* %msg_code17.i, align 8, !tbaa !25
  store i32 65500, i32* %arrayidx.i, align 4, !tbaa !28
Generating INTSEQ
Gen:   %170 = add i32 %169, 40
Generating ALTSEQ
Values:
  %msg_code17.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %15, i64 0, i32 5
  %arrayidx.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %15, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %171 = icmp eq i8 %167, 0
  %172 = select i1 %171, i32* %msg_code17.i, i32* %arrayidx.i
Operands done!
Generated:   store i32 %170, i32* %172, align 1
Gen:   store i32 %170, i32* %172, align 1
Graph code generated!
Root:
  store i32 40, i32* %msg_code17.i, align 8, !tbaa !25
  store i32 65500, i32* %arrayidx.i, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="40..65500, 65460", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code17.i, %arrayidx.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
  %18 = phi i32 [ %.pre253.i, %if.then15.i ], [ %14, %lor.lhs.false10.i ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 69, i32* %msg_code32.i, align 8, !tbaa !25
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 13, i32* %msg_code40.i, align 8, !tbaa !25
  store i32 %23, i32* %arrayidx45.i, align 4, !tbaa !28
Creating Node
  store i32 13, i32* %msg_code40.i, align 8, !tbaa !25
  store i32 %23, i32* %arrayidx45.i, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 13
  %23 = load i32, i32* %data_precision.i, align 8, !tbaa !29
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 13
Alt Seq
Creating Node
  %msg_code40.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %24, i64 0, i32 5
  %arrayidx45.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %24, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code40.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %24, i64 0, i32 5
  %arrayidx45.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %24, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code40.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %24, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 13, i32* %msg_code40.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %23, i32* %arrayidx45.i, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 13, i32* %msg_code40.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 13, i32* %msg_code40.i, align 8, !tbaa !25
Processing:   store i32 13, i32* %msg_code40.i, align 8, !tbaa !25
Count: 1
Found:   store i32 13, i32* %msg_code40.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 %23, i32* %arrayidx45.i, align 4, !tbaa !28
}
Non-memory:   %arrayidx45.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %24, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %23, i32* %arrayidx45.i, align 4, !tbaa !28
Count: 1
Found:   store i32 %23, i32* %arrayidx45.i, align 4, !tbaa !28
I:   %25 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err39.i, align 8, !tbaa !24
Last:   br label %if.end48.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 13, i32* %msg_code40.i, align 8, !tbaa !25
  store i32 %23, i32* %arrayidx45.i, align 4, !tbaa !28
Generating ALTSEQ
Values:
i32 13
  %23 = load i32, i32* %data_precision.i, align 8, !tbaa !29
Generated Version 4:
  %168 = icmp eq i8 %167, 0
  %169 = select i1 %168, i32 13, i32 %23
Generating ALTSEQ
Values:
  %msg_code40.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %24, i64 0, i32 5
  %arrayidx45.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %24, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %170 = select i1 %168, i32* %msg_code40.i, i32* %arrayidx45.i
Operands done!
Generated:   store i32 %169, i32* %170, align 1
Gen:   store i32 %169, i32* %170, align 1
Graph code generated!
Root:
  store i32 13, i32* %msg_code40.i, align 8, !tbaa !25
  store i32 %23, i32* %arrayidx45.i, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 13, %23", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code40.i, %arrayidx45.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 10, i32* %arrayidx63.i, align 4, !tbaa !28
Attempting Group:
  store i32 24, i32* %msg_code54.i, align 8, !tbaa !25
  store i32 %27, i32* %arrayidx59.i, align 4, !tbaa !28
Creating Node
  store i32 24, i32* %msg_code54.i, align 8, !tbaa !25
  store i32 %27, i32* %arrayidx59.i, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 24
  %27 = load i32, i32* %num_components49.i, align 4, !tbaa !22
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 24
Alt Seq
Creating Node
  %msg_code54.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %28, i64 0, i32 5
  %arrayidx59.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %28, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code54.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %28, i64 0, i32 5
  %arrayidx59.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %28, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code54.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %28, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 24, i32* %msg_code54.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %27, i32* %arrayidx59.i, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 24, i32* %msg_code54.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 24, i32* %msg_code54.i, align 8, !tbaa !25
Processing:   store i32 24, i32* %msg_code54.i, align 8, !tbaa !25
Count: 1
Found:   store i32 24, i32* %msg_code54.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 %27, i32* %arrayidx59.i, align 4, !tbaa !28
}
Non-memory:   %arrayidx59.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %28, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %27, i32* %arrayidx59.i, align 4, !tbaa !28
Count: 1
Found:   store i32 %27, i32* %arrayidx59.i, align 4, !tbaa !28
I:   %29 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err53.i, align 8, !tbaa !24
Last:   br label %if.end66.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 24, i32* %msg_code54.i, align 8, !tbaa !25
  store i32 %27, i32* %arrayidx59.i, align 4, !tbaa !28
Generating ALTSEQ
Values:
i32 24
  %27 = load i32, i32* %num_components49.i, align 4, !tbaa !22
Generated Version 4:
  %168 = icmp eq i8 %167, 0
  %169 = select i1 %168, i32 24, i32 %27
Generating ALTSEQ
Values:
  %msg_code54.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %28, i64 0, i32 5
  %arrayidx59.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %28, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %170 = select i1 %168, i32* %msg_code54.i, i32* %arrayidx59.i
Operands done!
Generated:   store i32 %169, i32* %170, align 1
Gen:   store i32 %169, i32* %170, align 1
Graph code generated!
Root:
  store i32 24, i32* %msg_code54.i, align 8, !tbaa !25
  store i32 %27, i32* %arrayidx59.i, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 24, %27", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code54.i, %arrayidx59.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %max_h_samp_factor.i, align 8, !tbaa !30
  store i32 1, i32* %max_v_samp_factor.i, align 4, !tbaa !31
Creating Node
  store i32 1, i32* %max_h_samp_factor.i, align 8, !tbaa !30
  store i32 1, i32* %max_v_samp_factor.i, align 4, !tbaa !31
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 1
i32 1
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
Match: 0
2 x 2
Final Match: 0
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
Alt Seq
ScheduleNode: {
  store i32 1, i32* %max_h_samp_factor.i, align 8, !tbaa !30
}
ScheduleNode: {
  store i32 1, i32* %max_v_samp_factor.i, align 4, !tbaa !31
}
ScheduleNode: {
  store i32 1, i32* %max_h_samp_factor.i, align 8, !tbaa !30
}
Count: 1
Start:   store i32 1, i32* %max_h_samp_factor.i, align 8, !tbaa !30
Processing:   store i32 1, i32* %max_h_samp_factor.i, align 8, !tbaa !30
Count: 1
Found:   store i32 1, i32* %max_h_samp_factor.i, align 8, !tbaa !30
ScheduleNode: {
  store i32 1, i32* %max_v_samp_factor.i, align 4, !tbaa !31
}
Non-memory:   %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
Processing:   store i32 1, i32* %max_v_samp_factor.i, align 4, !tbaa !31
Count: 1
Found:   store i32 1, i32* %max_v_samp_factor.i, align 4, !tbaa !31
I:   %comp_info.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 14
Last:   br label %for.cond.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 1, i32* %max_h_samp_factor.i, align 8, !tbaa !30
  store i32 1, i32* %max_v_samp_factor.i, align 4, !tbaa !31
Generating IDENTICAL
Generating ALTSEQ
Values:
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
Generated Version 4:
  %168 = icmp eq i8 %167, 0
  %169 = select i1 %168, i32* %max_h_samp_factor.i, i32* %max_v_samp_factor.i
Operands done!
Generated:   store i32 1, i32* %169, align 1
Gen:   store i32 1, i32* %169, align 1
Graph code generated!
Root:
  store i32 1, i32* %max_h_samp_factor.i, align 8, !tbaa !30
  store i32 1, i32* %max_v_samp_factor.i, align 4, !tbaa !31
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="1", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %max_h_samp_factor.i, %max_v_samp_factor.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 5 = -1; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
  %33 = phi i32 [ 1, %if.end66.i ], [ %cond105.i, %if.end88.i ]
  %34 = phi i32 [ 1, %if.end66.i ], [ %cond.i, %if.end88.i ]
  %compptr.0.i = phi %struct.jpeg_component_info* [ %32, %if.end66.i ], [ %incdec.ptr.i, %if.end88.i ]
  %ci.0.i = phi i32 [ 0, %if.end66.i ], [ %inc.i, %if.end88.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 16, i32* %msg_code85.i, align 8, !tbaa !25
  %42 = phi i32 [ %38, %lor.lhs.false76.i ], [ %.pre258.i, %if.then83.i ]
  %43 = phi i32 [ %33, %lor.lhs.false76.i ], [ %.pre257.i, %if.then83.i ]
  %44 = phi i32 [ %36, %lor.lhs.false76.i ], [ %.pre256.i, %if.then83.i ]
  %45 = phi i32 [ %34, %lor.lhs.false76.i ], [ %.pre255.i, %if.then83.i ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 %cond.i, i32* %max_h_samp_factor.i, align 8, !tbaa !30
  store i32 %cond105.i, i32* %max_v_samp_factor.i, align 4, !tbaa !31
Creating Node
  store i32 %cond.i, i32* %max_h_samp_factor.i, align 8, !tbaa !30
  store i32 %cond105.i, i32* %max_v_samp_factor.i, align 4, !tbaa !31
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %cond.i = select i1 %cmp91.i, i32 %45, i32 %44
  %cond105.i = select i1 %cmp98.i, i32 %43, i32 %42
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %cmp91.i = icmp sgt i32 %45, %44
  %cmp98.i = icmp sgt i32 %43, %42
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %45 = phi i32 [ %34, %lor.lhs.false76.i ], [ %.pre255.i, %if.then83.i ]
  %43 = phi i32 [ %33, %lor.lhs.false76.i ], [ %.pre257.i, %if.then83.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %45 = phi i32 [ %34, %lor.lhs.false76.i ], [ %.pre255.i, %if.then83.i ]
Alt Seq
Creating Node
  %44 = phi i32 [ %36, %lor.lhs.false76.i ], [ %.pre256.i, %if.then83.i ]
  %42 = phi i32 [ %38, %lor.lhs.false76.i ], [ %.pre258.i, %if.then83.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %44 = phi i32 [ %36, %lor.lhs.false76.i ], [ %.pre256.i, %if.then83.i ]
Alt Seq
Creating Node
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
Match: 0
2 x 2
Final Match: 0
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
Alt Seq
ScheduleNode: {
  store i32 %cond.i, i32* %max_h_samp_factor.i, align 8, !tbaa !30
}
ScheduleNode: {
  store i32 %cond105.i, i32* %max_v_samp_factor.i, align 4, !tbaa !31
}
ScheduleNode: {
  store i32 %cond.i, i32* %max_h_samp_factor.i, align 8, !tbaa !30
}
Count: 1
Start:   %cmp91.i = icmp sgt i32 %45, %44
Non-memory:   %cmp91.i = icmp sgt i32 %45, %44
Non-memory:   %cond.i = select i1 %cmp91.i, i32 %45, i32 %44
Processing:   store i32 %cond.i, i32* %max_h_samp_factor.i, align 8, !tbaa !30
Count: 1
Found:   store i32 %cond.i, i32* %max_h_samp_factor.i, align 8, !tbaa !30
ScheduleNode: {
  store i32 %cond105.i, i32* %max_v_samp_factor.i, align 4, !tbaa !31
}
Non-memory:   %cmp98.i = icmp sgt i32 %43, %42
Non-memory:   %cond105.i = select i1 %cmp98.i, i32 %43, i32 %42
Processing:   store i32 %cond105.i, i32* %max_v_samp_factor.i, align 4, !tbaa !31
Count: 1
Found:   store i32 %cond105.i, i32* %max_v_samp_factor.i, align 4, !tbaa !31
I:   %inc.i = add nuw nsw i32 %ci.0.i, 1
Last:   br label %for.cond.i, !llvm.loop !36
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 %cond.i, i32* %max_h_samp_factor.i, align 8, !tbaa !30
  store i32 %cond105.i, i32* %max_v_samp_factor.i, align 4, !tbaa !31
Generating MATCH
Match: 
  %cond.i = select i1 %cmp91.i, i32 %45, i32 %44
  %cond105.i = select i1 %cmp98.i, i32 %43, i32 %42
Generating MATCH
Match: 
  %cmp91.i = icmp sgt i32 %45, %44
  %cmp98.i = icmp sgt i32 %43, %42
Generating ALTSEQ
Values:
  %45 = phi i32 [ %34, %lor.lhs.false76.i ], [ %.pre255.i, %if.then83.i ]
  %43 = phi i32 [ %33, %lor.lhs.false76.i ], [ %.pre257.i, %if.then83.i ]
Generated Version 4:
  %168 = icmp eq i8 %167, 0
  %169 = select i1 %168, i32 %45, i32 %43
Generating ALTSEQ
Values:
  %44 = phi i32 [ %36, %lor.lhs.false76.i ], [ %.pre256.i, %if.then83.i ]
  %42 = phi i32 [ %38, %lor.lhs.false76.i ], [ %.pre258.i, %if.then83.i ]
Generated Version 4:
  %170 = select i1 %168, i32 %44, i32 %42
Operands done!
Generated:   %171 = icmp sgt i32 %169, %170
Gen:   %171 = icmp sgt i32 %169, %170
Operands done!
Generated:   %172 = select i1 %171, i32 %169, i32 %170
Found use: 0:   %34 = phi i32 [ 1, %if.end66.i ], [ %cond.i, %if.end88.i ]
Found use: 1:   %33 = phi i32 [ 1, %if.end66.i ], [ %cond105.i, %if.end88.i ]
Extracting:   %172 = select i1 %171, i32 %169, i32 %170
Gen:   %173 = select i1 %172, i32 %170, i32 %171
Generating ALTSEQ
Values:
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
Generated Version 4:
  %175 = select i1 %169, i32* %max_h_samp_factor.i, i32* %max_v_samp_factor.i
Operands done!
Generated:   store i32 %173, i32* %175, align 1
Gen:   store i32 %173, i32* %175, align 1
Graph code generated!
Root:
  store i32 %cond.i, i32* %max_h_samp_factor.i, align 8, !tbaa !30
  store i32 %cond105.i, i32* %max_v_samp_factor.i, align 4, !tbaa !31
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="select", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="icmp", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %46, %44", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %45, %43", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="alt: %max_h_samp_factor.i, %max_v_samp_factor.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
5->0 
2->1 
3->1 
4->1 
3->2 
4->2 
6 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
1->6
7 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
1->7
}

Gains: 8 - 24 = -16; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
  %.lcssa = phi i32 [ %36, %for.cond.i ]
  %48 = phi i32 [ %.lcssa, %for.end.i ], [ %.pre254.i, %for.body112.i ]
  %compptr.1.i = phi %struct.jpeg_component_info* [ %47, %for.end.i ], [ %incdec.ptr152.i, %for.body112.i ]
  %ci.1.i = phi i32 [ 0, %for.end.i ], [ %inc151.i, %for.body112.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul117.i = mul nsw i64 %conv116.i, %conv114.i
looking for reduction
looking for reduction
looking for reduction
  %mul126.i = mul nsw i64 %conv125.i, %conv123.i
looking for reduction
looking for reduction
looking for reduction
  %mul136.i = mul nsw i64 %conv135.i, %conv133.i
looking for reduction
looking for reduction
looking for reduction
  %mul145.i = mul nsw i64 %conv144.i, %conv142.i
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %ci.1.i, i32* %component_index.i, align 4, !tbaa !38
  store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !39
  store i32 %conv121.i, i32* %width_in_blocks.i, align 4, !tbaa !40
  store i32 %conv131.i, i32* %height_in_blocks.i, align 8, !tbaa !41
  store i32 %conv140.i, i32* %downsampled_width.i, align 8, !tbaa !42
  store i32 %conv149.i, i32* %downsampled_height.i, align 4, !tbaa !43
  store i32 1, i32* %component_needed.i, align 8, !tbaa !44
Attempting Group:
  %call.i = tail call i64 @jdiv_round_up(i64 %mul117.i, i64 %conv120.i) #3
  %call130.i = tail call i64 @jdiv_round_up(i64 %mul126.i, i64 %conv129.i) #3
  %call139.i = tail call i64 @jdiv_round_up(i64 %mul136.i, i64 %conv138.i) #3
  %call148.i = tail call i64 @jdiv_round_up(i64 %mul145.i, i64 %conv147.i) #3
Creating Node
  store i32 %ci.1.i, i32* %component_index.i, align 4, !tbaa !38
  store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !39
  store i32 %conv121.i, i32* %width_in_blocks.i, align 4, !tbaa !40
  store i32 %conv131.i, i32* %height_in_blocks.i, align 8, !tbaa !41
  store i32 %conv140.i, i32* %downsampled_width.i, align 8, !tbaa !42
  store i32 %conv149.i, i32* %downsampled_height.i, align 4, !tbaa !43
  store i32 1, i32* %component_needed.i, align 8, !tbaa !44
Match: 1
7 x 7
Final Match: 1
Matching
Creating Node
  %ci.1.i = phi i32 [ 0, %for.end.i ], [ %inc151.i, %for.body112.i ]
i32 8
  %conv121.i = trunc i64 %call.i to i32
  %conv131.i = trunc i64 %call130.i to i32
  %conv140.i = trunc i64 %call139.i to i32
  %conv149.i = trunc i64 %call148.i to i32
i32 1
Match: 0
7 x 7
Final Match: 0
GEPSeq2
BinOP?
  %ci.1.i = phi i32 [ 0, %for.end.i ], [ %inc151.i, %for.body112.i ]
Mismatching
Creating Node
  %component_index.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 1
  %DCT_scaled_size.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 9
  %width_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 7
  %height_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 8
  %downsampled_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 10
  %downsampled_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 11
  %component_needed.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 12
Match: 0
7 x 7
Final Match: 0
  %component_index.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 1
  %DCT_scaled_size.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 9
  %width_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 7
  %height_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 8
  %downsampled_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 10
  %downsampled_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 11
  %component_needed.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 12
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %component_index.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 1
Mismatching
ScheduleNode: {
  store i32 %ci.1.i, i32* %component_index.i, align 4, !tbaa !38
}
ScheduleNode: {
  store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !39
}
ScheduleNode: {
  store i32 %conv121.i, i32* %width_in_blocks.i, align 4, !tbaa !40
}
ScheduleNode: {
  store i32 %conv131.i, i32* %height_in_blocks.i, align 8, !tbaa !41
}
ScheduleNode: {
  store i32 %conv140.i, i32* %downsampled_width.i, align 8, !tbaa !42
}
ScheduleNode: {
  store i32 %conv149.i, i32* %downsampled_height.i, align 4, !tbaa !43
}
ScheduleNode: {
  store i32 1, i32* %component_needed.i, align 8, !tbaa !44
}
ScheduleNode: {
  store i32 %ci.1.i, i32* %component_index.i, align 4, !tbaa !38
}
Count: 1
Start:   store i32 %ci.1.i, i32* %component_index.i, align 4, !tbaa !38
Processing:   store i32 %ci.1.i, i32* %component_index.i, align 4, !tbaa !38
Count: 1
Found:   store i32 %ci.1.i, i32* %component_index.i, align 4, !tbaa !38
ScheduleNode: {
  store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !39
}
Non-memory:   %DCT_scaled_size.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 9
Processing:   store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !39
Count: 1
Found:   store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !39
ScheduleNode: {
  store i32 %conv121.i, i32* %width_in_blocks.i, align 4, !tbaa !40
}
Processing:   %49 = load i32, i32* %image_width22.i, align 8, !tbaa !21
Count: 1
Not found:   %49 = load i32, i32* %image_width22.i, align 8, !tbaa !21
Read/Write memory
I:   %49 = load i32, i32* %image_width22.i, align 8, !tbaa !21
Last:   br label %for.cond108.i, !llvm.loop !45
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


for.body112.i:                                    ; preds = %for.cond108.i
  %component_index.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 1
  store i32 %ci.1.i, i32* %component_index.i, align 4, !tbaa !38
  %DCT_scaled_size.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 9
  store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !39
  %49 = load i32, i32* %image_width22.i, align 8, !tbaa !21
  %conv114.i = zext i32 %49 to i64
  %h_samp_factor115.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
  %50 = load i32, i32* %h_samp_factor115.i, align 8, !tbaa !33
  %conv116.i = sext i32 %50 to i64
  %mul117.i = mul nsw i64 %conv116.i, %conv114.i
  %51 = load i32, i32* %max_h_samp_factor.i, align 8, !tbaa !30
  %mul119.i = shl nsw i32 %51, 3
  %conv120.i = sext i32 %mul119.i to i64
  %call.i = tail call i64 @jdiv_round_up(i64 %mul117.i, i64 %conv120.i) #3
  %conv121.i = trunc i64 %call.i to i32
  %width_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 7
  store i32 %conv121.i, i32* %width_in_blocks.i, align 4, !tbaa !40
  %52 = load i32, i32* %image_height.i, align 4, !tbaa !20
  %conv123.i = zext i32 %52 to i64
  %v_samp_factor124.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 3
  %53 = load i32, i32* %v_samp_factor124.i, align 4, !tbaa !35
  %conv125.i = sext i32 %53 to i64
  %mul126.i = mul nsw i64 %conv125.i, %conv123.i
  %54 = load i32, i32* %max_v_samp_factor.i, align 4, !tbaa !31
  %mul128.i = shl nsw i32 %54, 3
  %conv129.i = sext i32 %mul128.i to i64
  %call130.i = tail call i64 @jdiv_round_up(i64 %mul126.i, i64 %conv129.i) #3
  %conv131.i = trunc i64 %call130.i to i32
  %height_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 8
  store i32 %conv131.i, i32* %height_in_blocks.i, align 8, !tbaa !41
  %55 = load i32, i32* %image_width22.i, align 8, !tbaa !21
  %conv133.i = zext i32 %55 to i64
  %56 = load i32, i32* %h_samp_factor115.i, align 8, !tbaa !33
  %conv135.i = sext i32 %56 to i64
  %mul136.i = mul nsw i64 %conv135.i, %conv133.i
  %57 = load i32, i32* %max_h_samp_factor.i, align 8, !tbaa !30
  %conv138.i = sext i32 %57 to i64
  %call139.i = tail call i64 @jdiv_round_up(i64 %mul136.i, i64 %conv138.i) #3
  %conv140.i = trunc i64 %call139.i to i32
  %downsampled_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 10
  store i32 %conv140.i, i32* %downsampled_width.i, align 8, !tbaa !42
  %58 = load i32, i32* %image_height.i, align 4, !tbaa !20
  %conv142.i = zext i32 %58 to i64
  %59 = load i32, i32* %v_samp_factor124.i, align 4, !tbaa !35
  %conv144.i = sext i32 %59 to i64
  %mul145.i = mul nsw i64 %conv144.i, %conv142.i
  %60 = load i32, i32* %max_v_samp_factor.i, align 4, !tbaa !31
  %conv147.i = sext i32 %60 to i64
  %call148.i = tail call i64 @jdiv_round_up(i64 %mul145.i, i64 %conv147.i) #3
  %conv149.i = trunc i64 %call148.i to i32
  %downsampled_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 11
  store i32 %conv149.i, i32* %downsampled_height.i, align 4, !tbaa !43
  %component_needed.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 12
  store i32 1, i32* %component_needed.i, align 8, !tbaa !44
  %inc151.i = add nuw nsw i32 %ci.1.i, 1
  %incdec.ptr152.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 1
  %.pre254.i = load i32, i32* %num_components49.i, align 4, !tbaa !22
  br label %for.cond108.i, !llvm.loop !45

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Creating Node
  %call.i = tail call i64 @jdiv_round_up(i64 %mul117.i, i64 %conv120.i) #3
  %call130.i = tail call i64 @jdiv_round_up(i64 %mul126.i, i64 %conv129.i) #3
  %call139.i = tail call i64 @jdiv_round_up(i64 %mul136.i, i64 %conv138.i) #3
  %call148.i = tail call i64 @jdiv_round_up(i64 %mul145.i, i64 %conv147.i) #3
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %mul117.i = mul nsw i64 %conv116.i, %conv114.i
  %mul126.i = mul nsw i64 %conv125.i, %conv123.i
  %mul136.i = mul nsw i64 %conv135.i, %conv133.i
  %mul145.i = mul nsw i64 %conv144.i, %conv142.i
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %conv116.i = sext i32 %50 to i64
  %conv125.i = sext i32 %53 to i64
  %conv135.i = sext i32 %56 to i64
  %conv144.i = sext i32 %59 to i64
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %50 = load i32, i32* %h_samp_factor115.i, align 8, !tbaa !33
  %53 = load i32, i32* %v_samp_factor124.i, align 4, !tbaa !35
  %56 = load i32, i32* %h_samp_factor115.i, align 8, !tbaa !33
  %59 = load i32, i32* %v_samp_factor124.i, align 4, !tbaa !35
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %h_samp_factor115.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
  %v_samp_factor124.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 3
  %h_samp_factor115.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
  %v_samp_factor124.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 3
Match: 0
2 x 4
Final Match: 0
  %h_samp_factor115.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
  %v_samp_factor124.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 3
  %h_samp_factor115.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
  %v_samp_factor124.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 3
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %h_samp_factor115.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
Alt Seq
Creating Node
  %conv114.i = zext i32 %49 to i64
  %conv123.i = zext i32 %52 to i64
  %conv133.i = zext i32 %55 to i64
  %conv142.i = zext i32 %58 to i64
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %49 = load i32, i32* %image_width22.i, align 8, !tbaa !21
  %52 = load i32, i32* %image_height.i, align 4, !tbaa !20
  %55 = load i32, i32* %image_width22.i, align 8, !tbaa !21
  %58 = load i32, i32* %image_height.i, align 4, !tbaa !20
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %image_width22.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %image_height.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
  %image_width22.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %image_height.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
Match: 0
2 x 4
Final Match: 0
  %image_width22.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %image_height.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
  %image_width22.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %image_height.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %image_width22.i = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
Alt Seq
Creating Node
  %conv120.i = sext i32 %mul119.i to i64
  %conv129.i = sext i32 %mul128.i to i64
  %conv138.i = sext i32 %57 to i64
  %conv147.i = sext i32 %60 to i64
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %mul119.i = shl nsw i32 %51, 3
  %mul128.i = shl nsw i32 %54, 3
  %57 = load i32, i32* %max_h_samp_factor.i, align 8, !tbaa !30
  %60 = load i32, i32* %max_v_samp_factor.i, align 4, !tbaa !31
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %mul119.i = shl nsw i32 %51, 3
Mismatching
Creating Node
Function: jdiv_round_up
Function: jdiv_round_up
Function: jdiv_round_up
Function: jdiv_round_up
Match: 1
1 x 4
Final Match: 1
All the Same
ScheduleNode: {
  %50 = load i32, i32* %h_samp_factor115.i, align 8, !tbaa !33
  %49 = load i32, i32* %image_width22.i, align 8, !tbaa !21
}
ScheduleNode: {
  %call.i = tail call i64 @jdiv_round_up(i64 %mul117.i, i64 %conv120.i) #3
}
ScheduleNode: {
  %53 = load i32, i32* %v_samp_factor124.i, align 4, !tbaa !35
  %52 = load i32, i32* %image_height.i, align 4, !tbaa !20
}
ScheduleNode: {
  %call130.i = tail call i64 @jdiv_round_up(i64 %mul126.i, i64 %conv129.i) #3
}
ScheduleNode: {
  %55 = load i32, i32* %image_width22.i, align 8, !tbaa !21
  %56 = load i32, i32* %h_samp_factor115.i, align 8, !tbaa !33
}
ScheduleNode: {
  %call139.i = tail call i64 @jdiv_round_up(i64 %mul136.i, i64 %conv138.i) #3
}
ScheduleNode: {
  %58 = load i32, i32* %image_height.i, align 4, !tbaa !20
  %59 = load i32, i32* %v_samp_factor124.i, align 4, !tbaa !35
}
ScheduleNode: {
  %call148.i = tail call i64 @jdiv_round_up(i64 %mul145.i, i64 %conv147.i) #3
}
ScheduleNode: {
  %50 = load i32, i32* %h_samp_factor115.i, align 8, !tbaa !33
  %49 = load i32, i32* %image_width22.i, align 8, !tbaa !21
}
Count: 2
Start:   %49 = load i32, i32* %image_width22.i, align 8, !tbaa !21
Processing:   %49 = load i32, i32* %image_width22.i, align 8, !tbaa !21
Count: 2
Found:   %49 = load i32, i32* %image_width22.i, align 8, !tbaa !21
Non-memory:   %conv114.i = zext i32 %49 to i64
Non-memory:   %h_samp_factor115.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
Processing:   %50 = load i32, i32* %h_samp_factor115.i, align 8, !tbaa !33
Count: 1
Found:   %50 = load i32, i32* %h_samp_factor115.i, align 8, !tbaa !33
ScheduleNode: {
  %call.i = tail call i64 @jdiv_round_up(i64 %mul117.i, i64 %conv120.i) #3
}
Non-memory:   %conv116.i = sext i32 %50 to i64
Non-memory:   %mul117.i = mul nsw i64 %conv116.i, %conv114.i
Processing:   %51 = load i32, i32* %max_h_samp_factor.i, align 8, !tbaa !30
Count: 1
Not found:   %51 = load i32, i32* %max_h_samp_factor.i, align 8, !tbaa !30
Read/Write memory
I:   %51 = load i32, i32* %max_h_samp_factor.i, align 8, !tbaa !30
Last:   br label %for.cond108.i, !llvm.loop !45
Schedulable: 0
digraph VTree {
0 [label="call: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mul", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %h_samp_factor115.i, %v_samp_factor124.i", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %image_width22.i, %image_height.i", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
10 [label="func: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
8->0 
10->0 
2->1 
5->1 
3->2 
4->3 
6->5 
7->6 
9->8 
11 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->11
12 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->12
13 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->13
14 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->14
}


for.body112.i:                                    ; preds = %for.cond108.i
  %component_index.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 1
  store i32 %ci.1.i, i32* %component_index.i, align 4, !tbaa !38
  %DCT_scaled_size.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 9
  store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !39
  %49 = load i32, i32* %image_width22.i, align 8, !tbaa !21
  %conv114.i = zext i32 %49 to i64
  %h_samp_factor115.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
  %50 = load i32, i32* %h_samp_factor115.i, align 8, !tbaa !33
  %conv116.i = sext i32 %50 to i64
  %mul117.i = mul nsw i64 %conv116.i, %conv114.i
  %51 = load i32, i32* %max_h_samp_factor.i, align 8, !tbaa !30
  %mul119.i = shl nsw i32 %51, 3
  %conv120.i = sext i32 %mul119.i to i64
  %call.i = tail call i64 @jdiv_round_up(i64 %mul117.i, i64 %conv120.i) #3
  %conv121.i = trunc i64 %call.i to i32
  %width_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 7
  store i32 %conv121.i, i32* %width_in_blocks.i, align 4, !tbaa !40
  %52 = load i32, i32* %image_height.i, align 4, !tbaa !20
  %conv123.i = zext i32 %52 to i64
  %v_samp_factor124.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 3
  %53 = load i32, i32* %v_samp_factor124.i, align 4, !tbaa !35
  %conv125.i = sext i32 %53 to i64
  %mul126.i = mul nsw i64 %conv125.i, %conv123.i
  %54 = load i32, i32* %max_v_samp_factor.i, align 4, !tbaa !31
  %mul128.i = shl nsw i32 %54, 3
  %conv129.i = sext i32 %mul128.i to i64
  %call130.i = tail call i64 @jdiv_round_up(i64 %mul126.i, i64 %conv129.i) #3
  %conv131.i = trunc i64 %call130.i to i32
  %height_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 8
  store i32 %conv131.i, i32* %height_in_blocks.i, align 8, !tbaa !41
  %55 = load i32, i32* %image_width22.i, align 8, !tbaa !21
  %conv133.i = zext i32 %55 to i64
  %56 = load i32, i32* %h_samp_factor115.i, align 8, !tbaa !33
  %conv135.i = sext i32 %56 to i64
  %mul136.i = mul nsw i64 %conv135.i, %conv133.i
  %57 = load i32, i32* %max_h_samp_factor.i, align 8, !tbaa !30
  %conv138.i = sext i32 %57 to i64
  %call139.i = tail call i64 @jdiv_round_up(i64 %mul136.i, i64 %conv138.i) #3
  %conv140.i = trunc i64 %call139.i to i32
  %downsampled_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 10
  store i32 %conv140.i, i32* %downsampled_width.i, align 8, !tbaa !42
  %58 = load i32, i32* %image_height.i, align 4, !tbaa !20
  %conv142.i = zext i32 %58 to i64
  %59 = load i32, i32* %v_samp_factor124.i, align 4, !tbaa !35
  %conv144.i = sext i32 %59 to i64
  %mul145.i = mul nsw i64 %conv144.i, %conv142.i
  %60 = load i32, i32* %max_v_samp_factor.i, align 4, !tbaa !31
  %conv147.i = sext i32 %60 to i64
  %call148.i = tail call i64 @jdiv_round_up(i64 %mul145.i, i64 %conv147.i) #3
  %conv149.i = trunc i64 %call148.i to i32
  %downsampled_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 11
  store i32 %conv149.i, i32* %downsampled_height.i, align 4, !tbaa !43
  %component_needed.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 12
  store i32 1, i32* %component_needed.i, align 8, !tbaa !44
  %inc151.i = add nuw nsw i32 %ci.1.i, 1
  %incdec.ptr152.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 1
  %.pre254.i = load i32, i32* %num_components49.i, align 4, !tbaa !22
  br label %for.cond108.i, !llvm.loop !45

looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %conv160.i, i32* %total_iMCU_rows.i, align 8, !tbaa !46
Attempting Group:
  %call159.i = tail call i64 @jdiv_round_up(i64 %conv155.i, i64 %conv158.i) #3
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 17, i32* %msg_code.i54, align 8, !tbaa !25
  store i32 0, i32* %arrayidx.i55, align 4, !tbaa !28
Creating Node
  store i32 17, i32* %msg_code.i54, align 8, !tbaa !25
  store i32 0, i32* %arrayidx.i55, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 17
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 17
Int Seq
Creating Node
  %msg_code.i54 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %67, i64 0, i32 5
  %arrayidx.i55 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %67, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code.i54 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %67, i64 0, i32 5
  %arrayidx.i55 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %67, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code.i54 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %67, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 17, i32* %msg_code.i54, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 0, i32* %arrayidx.i55, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 17, i32* %msg_code.i54, align 8, !tbaa !25
}
Count: 1
Start:   store i32 17, i32* %msg_code.i54, align 8, !tbaa !25
Processing:   store i32 17, i32* %msg_code.i54, align 8, !tbaa !25
Count: 1
Found:   store i32 17, i32* %msg_code.i54, align 8, !tbaa !25
ScheduleNode: {
  store i32 0, i32* %arrayidx.i55, align 4, !tbaa !28
}
Non-memory:   %arrayidx.i55 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %67, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 0, i32* %arrayidx.i55, align 4, !tbaa !28
Count: 1
Found:   store i32 0, i32* %arrayidx.i55, align 4, !tbaa !28
I:   %68 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err84.i, align 8, !tbaa !24
Last:   br label %if.end.i58
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 17, i32* %msg_code.i54, align 8, !tbaa !25
  store i32 0, i32* %arrayidx.i55, align 4, !tbaa !28
Generating INTSEQ
Gen:   %171 = add i32 %170, 17
Generating ALTSEQ
Values:
  %msg_code.i54 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %67, i64 0, i32 5
  %arrayidx.i55 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %67, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %172 = icmp eq i8 %168, 0
  %173 = select i1 %172, i32* %msg_code.i54, i32* %arrayidx.i55
Operands done!
Generated:   store i32 %171, i32* %173, align 1
Gen:   store i32 %171, i32* %173, align 1
Graph code generated!
Root:
  store i32 17, i32* %msg_code.i54, align 8, !tbaa !25
  store i32 0, i32* %arrayidx.i55, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="17..0, -17", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code.i54, %arrayidx.i55", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
  %70 = phi %struct.jpeg_scan_info* [ %.pre, %if.then.i57 ], [ %63, %if.then ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %progressive_mode.i, align 4, !tbaa !52
  %ci.0.i61 = phi i32 [ 0, %if.then7.i ], [ %inc15.i, %for.inc14.i ]
  %last_bitpos_ptr.0.i = phi i32* [ %arrayidx9.i, %if.then7.i ], [ %last_bitpos_ptr.1.i.lcssa, %for.inc14.i ]
looking for reduction
  %coefi.0.i = phi i32 [ %inc.i64, %for.body13.i ], [ 0, %for.cond11.i.preheader ]
  %last_bitpos_ptr.1.i = phi i32* [ %incdec.ptr.i63, %for.body13.i ], [ %last_bitpos_ptr.0.i, %for.cond11.i.preheader ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 -1, i32* %last_bitpos_ptr.1.i, align 4, !tbaa !53
  %last_bitpos_ptr.1.i.lcssa = phi i32* [ %last_bitpos_ptr.1.i, %for.cond11.i ]
looking for reduction
Attempting Group:
  store i32 0, i32* %progressive_mode17.i, align 4, !tbaa !52
  %indvars.iv488.i = phi i64 [ %indvars.iv.next489.i, %for.body21.i ], [ 0, %if.else.i ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %arrayidx22.i, align 4, !tbaa !53
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
  %scanptr.0.i = phi %struct.jpeg_scan_info* [ %70, %if.end26.i ], [ %incdec.ptr253.i, %for.inc252.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 4, i32* %arrayidx44.i, align 4, !tbaa !28
Attempting Group:
  store i32 24, i32* %msg_code36.i, align 8, !tbaa !25
  store i32 %77, i32* %arrayidx40.i, align 4, !tbaa !28
Creating Node
  store i32 24, i32* %msg_code36.i, align 8, !tbaa !25
  store i32 %77, i32* %arrayidx40.i, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 24
  %77 = load i32, i32* %comps_in_scan.i, align 4, !tbaa !57
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 24
Alt Seq
Creating Node
  %msg_code36.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %79, i64 0, i32 5
  %arrayidx40.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %79, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code36.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %79, i64 0, i32 5
  %arrayidx40.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %79, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code36.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %79, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 24, i32* %msg_code36.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %77, i32* %arrayidx40.i, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 24, i32* %msg_code36.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 24, i32* %msg_code36.i, align 8, !tbaa !25
Processing:   store i32 24, i32* %msg_code36.i, align 8, !tbaa !25
Count: 1
Found:   store i32 24, i32* %msg_code36.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 %77, i32* %arrayidx40.i, align 4, !tbaa !28
}
Non-memory:   %arrayidx40.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %79, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %77, i32* %arrayidx40.i, align 4, !tbaa !28
Count: 1
Found:   store i32 %77, i32* %arrayidx40.i, align 4, !tbaa !28
I:   %80 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err84.i, align 8, !tbaa !24
Last:   br label %if.end47.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 24, i32* %msg_code36.i, align 8, !tbaa !25
  store i32 %77, i32* %arrayidx40.i, align 4, !tbaa !28
Generating ALTSEQ
Values:
i32 24
  %77 = load i32, i32* %comps_in_scan.i, align 4, !tbaa !57
Generated Version 4:
  %169 = icmp eq i8 %168, 0
  %170 = select i1 %169, i32 24, i32 %77
Generating ALTSEQ
Values:
  %msg_code36.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %79, i64 0, i32 5
  %arrayidx40.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %79, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %171 = select i1 %169, i32* %msg_code36.i, i32* %arrayidx40.i
Operands done!
Generated:   store i32 %170, i32* %171, align 1
Gen:   store i32 %170, i32* %171, align 1
Graph code generated!
Root:
  store i32 24, i32* %msg_code36.i, align 8, !tbaa !25
  store i32 %77, i32* %arrayidx40.i, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 24, %77", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code36.i, %arrayidx40.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
  %indvars.iv474.i = phi i64 [ %indvars.iv.next475.i, %for.inc82.i ], [ 0, %if.end47.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 17, i32* %msg_code59.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx63.i66, align 4, !tbaa !28
Creating Node
  store i32 17, i32* %msg_code59.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx63.i66, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 17
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 17
Alt Seq
Creating Node
  %msg_code59.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %87, i64 0, i32 5
  %arrayidx63.i66 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %87, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code59.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %87, i64 0, i32 5
  %arrayidx63.i66 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %87, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code59.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %87, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 17, i32* %msg_code59.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx63.i66, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 17, i32* %msg_code59.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 17, i32* %msg_code59.i, align 8, !tbaa !25
Processing:   store i32 17, i32* %msg_code59.i, align 8, !tbaa !25
Count: 1
Found:   store i32 17, i32* %msg_code59.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx63.i66, align 4, !tbaa !28
}
Non-memory:   %arrayidx63.i66 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %87, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0.i, i32* %arrayidx63.i66, align 4, !tbaa !28
Count: 1
Found:   store i32 %scanno.0.i, i32* %arrayidx63.i66, align 4, !tbaa !28
I:   %88 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err84.i, align 8, !tbaa !24
Last:   br label %if.end66.i68
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 17, i32* %msg_code59.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx63.i66, align 4, !tbaa !28
Generating ALTSEQ
Values:
i32 17
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Generated Version 4:
  %169 = icmp eq i8 %168, 0
  %170 = select i1 %169, i32 17, i32 %scanno.0.i
Generating ALTSEQ
Values:
  %msg_code59.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %87, i64 0, i32 5
  %arrayidx63.i66 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %87, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %171 = select i1 %169, i32* %msg_code59.i, i32* %arrayidx63.i66
Operands done!
Generated:   store i32 %170, i32* %171, align 1
Gen:   store i32 %170, i32* %171, align 1
Graph code generated!
Root:
  store i32 17, i32* %msg_code59.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx63.i66, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 17, %scanno.0.i", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code59.i, %arrayidx63.i66", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 17, i32* %msg_code74.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx78.i, align 4, !tbaa !28
Creating Node
  store i32 17, i32* %msg_code74.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx78.i, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 17
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 17
Alt Seq
Creating Node
  %msg_code74.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %93, i64 0, i32 5
  %arrayidx78.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %93, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code74.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %93, i64 0, i32 5
  %arrayidx78.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %93, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code74.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %93, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 17, i32* %msg_code74.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx78.i, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 17, i32* %msg_code74.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 17, i32* %msg_code74.i, align 8, !tbaa !25
Processing:   store i32 17, i32* %msg_code74.i, align 8, !tbaa !25
Count: 1
Found:   store i32 17, i32* %msg_code74.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx78.i, align 4, !tbaa !28
}
Non-memory:   %arrayidx78.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %93, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0.i, i32* %arrayidx78.i, align 4, !tbaa !28
Count: 1
Found:   store i32 %scanno.0.i, i32* %arrayidx78.i, align 4, !tbaa !28
I:   %94 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err84.i, align 8, !tbaa !24
Last:   br label %for.inc82.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 17, i32* %msg_code74.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx78.i, align 4, !tbaa !28
Generating ALTSEQ
Values:
i32 17
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Generated Version 4:
  %169 = icmp eq i8 %168, 0
  %170 = select i1 %169, i32 17, i32 %scanno.0.i
Generating ALTSEQ
Values:
  %msg_code74.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %93, i64 0, i32 5
  %arrayidx78.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %93, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %171 = select i1 %169, i32* %msg_code74.i, i32* %arrayidx78.i
Operands done!
Generated:   store i32 %170, i32* %171, align 1
Gen:   store i32 %170, i32* %171, align 1
Graph code generated!
Root:
  store i32 17, i32* %msg_code74.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx78.i, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 17, %scanno.0.i", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code74.i, %arrayidx78.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
  %105 = or i1 %104, %103
Found
Building reduction
  br i1 %105, label %if.then106.i, label %if.end115.i
  %105 = or i1 %104, %103
BOs:
  %105 = or i1 %104, %103
  %103 = or i1 %102, %or.cond295.i
  %or.cond295.i = or i1 %cmp95.i, %cmp97.i
Operands:
  %104 = icmp ugt i32 %99, 13
  %102 = icmp ugt i32 %98, 13
  %cmp95.i = icmp slt i32 %97, %96
  %cmp97.i = icmp sgt i32 %97, 63
Operands:
  %104 = icmp ugt i32 %99, 13
  %102 = icmp ugt i32 %98, 13
  %cmp97.i = icmp sgt i32 %97, 63
  %cmp95.i = icmp slt i32 %97, %96
ReductionNode
Creating Node
  %104 = icmp ugt i32 %99, 13
  %102 = icmp ugt i32 %98, 13
  %cmp97.i = icmp sgt i32 %97, 63
  %cmp95.i = icmp slt i32 %97, %96
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %99 = load i32, i32* %Al88.i, align 4, !tbaa !60
  %98 = load i32, i32* %Ah87.i, align 4, !tbaa !59
  %97 = load i32, i32* %Se86.i, align 4, !tbaa !51
  %97 = load i32, i32* %Se86.i, align 4, !tbaa !51
Match: 0
3 x 4
Final Match: 0
GEPSeq2
BinOP?
  %99 = load i32, i32* %Al88.i, align 4, !tbaa !60
Mismatching
Creating Node
i32 13
i32 13
i32 63
  %96 = load i32, i32* %Ss85.i, align 4, !tbaa !49
Match: 0
3 x 4
Final Match: 0
GEPSeq2
BinOP?
i32 13
Mismatching
Empty scheduling entries
Loop Rolling: jinit_c_master_control
Generating tree
Generating REDUCTION
Generating MATCH
Match: 
  %104 = icmp ugt i32 %99, 13
  %102 = icmp ugt i32 %98, 13
  %cmp97.i = icmp sgt i32 %97, 63
  %cmp95.i = icmp slt i32 %97, %96
Generating Mismatch
Mismatched Values:
inst:   %99 = load i32, i32* %Al88.i, align 4, !tbaa !60
inst:   %98 = load i32, i32* %Ah87.i, align 4, !tbaa !59
inst:   %97 = load i32, i32* %Se86.i, align 4, !tbaa !51
inst:   %97 = load i32, i32* %Se86.i, align 4, !tbaa !51
Non constants
Array Type: 4:i32
Created array:   %168 = alloca i32, i8 4, align 4
Gen:   %175 = load i32, i32* %174, align 4
Generating Mismatch
Mismatched Values:
int: i32 13
int: i32 13
int: i32 63
inst:   %96 = load i32, i32* %Ss85.i, align 4, !tbaa !49
Non constants
Array Type: 4:i32
Created array:   %173 = alloca i32, i8 4, align 4
Gen:   %182 = load i32, i32* %181, align 4
Operands done!
Generated:   %183 = icmp ugt i32 %180, %182
Gen:   %183 = icmp ugt i32 %180, %182
Closing REDUCTION
Found use: 0:   br i1 %105, label %if.then106.i, label %if.end115.i
Extracting:   %185 = or i1 %179, %184
Gen:   %185 = or i1 %179, %184
Graph code generated!
Root:
  %105 = or i1 %104, %103
  %103 = or i1 %102, %or.cond295.i
  %or.cond295.i = or i1 %cmp95.i, %cmp97.i
Root size: 3
digraph VTree {
0 [label="or red.", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="icmp", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->1 
3->1 
4 [label="br", style="filled" , fillcolor="#f2eb5c", shape=box];
0->4
}

Gains: 7 - 106 = -99; Width: 3; Reduction Unprofitable; jinit_c_master_control
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code108.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx112.i, align 4, !tbaa !28
Creating Node
  store i32 15, i32* %msg_code108.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx112.i, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code108.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %106, i64 0, i32 5
  %arrayidx112.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %106, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code108.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %106, i64 0, i32 5
  %arrayidx112.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %106, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code108.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %106, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code108.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx112.i, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 15, i32* %msg_code108.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 15, i32* %msg_code108.i, align 8, !tbaa !25
Processing:   store i32 15, i32* %msg_code108.i, align 8, !tbaa !25
Count: 1
Found:   store i32 15, i32* %msg_code108.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx112.i, align 4, !tbaa !28
}
Non-memory:   %arrayidx112.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %106, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0.i, i32* %arrayidx112.i, align 4, !tbaa !28
Count: 1
Found:   store i32 %scanno.0.i, i32* %arrayidx112.i, align 4, !tbaa !28
I:   %107 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err84.i, align 8, !tbaa !24
Last:   br label %if.end115.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code108.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx112.i, align 4, !tbaa !28
Generating ALTSEQ
Values:
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Generated Version 4:
  %169 = icmp eq i8 %168, 0
  %170 = select i1 %169, i32 15, i32 %scanno.0.i
Generating ALTSEQ
Values:
  %msg_code108.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %106, i64 0, i32 5
  %arrayidx112.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %106, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %171 = select i1 %169, i32* %msg_code108.i, i32* %arrayidx112.i
Operands done!
Generated:   store i32 %170, i32* %171, align 1
Gen:   store i32 %170, i32* %171, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code108.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx112.i, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0.i", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code108.i, %arrayidx112.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code121.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx125.i, align 4, !tbaa !28
Creating Node
  store i32 15, i32* %msg_code121.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx125.i, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code121.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %109, i64 0, i32 5
  %arrayidx125.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %109, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code121.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %109, i64 0, i32 5
  %arrayidx125.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %109, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code121.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %109, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code121.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx125.i, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 15, i32* %msg_code121.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 15, i32* %msg_code121.i, align 8, !tbaa !25
Processing:   store i32 15, i32* %msg_code121.i, align 8, !tbaa !25
Count: 1
Found:   store i32 15, i32* %msg_code121.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx125.i, align 4, !tbaa !28
}
Non-memory:   %arrayidx125.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %109, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0.i, i32* %arrayidx125.i, align 4, !tbaa !28
Count: 1
Found:   store i32 %scanno.0.i, i32* %arrayidx125.i, align 4, !tbaa !28
I:   %110 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err84.i, align 8, !tbaa !24
Last:   br label %if.end141.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code121.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx125.i, align 4, !tbaa !28
Generating ALTSEQ
Values:
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Generated Version 4:
  %169 = icmp eq i8 %168, 0
  %170 = select i1 %169, i32 15, i32 %scanno.0.i
Generating ALTSEQ
Values:
  %msg_code121.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %109, i64 0, i32 5
  %arrayidx125.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %109, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %171 = select i1 %169, i32* %msg_code121.i, i32* %arrayidx125.i
Operands done!
Generated:   store i32 %170, i32* %171, align 1
Gen:   store i32 %170, i32* %171, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code121.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx125.i, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0.i", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code121.i, %arrayidx125.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code133.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx137.i, align 4, !tbaa !28
Creating Node
  store i32 15, i32* %msg_code133.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx137.i, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code133.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %112, i64 0, i32 5
  %arrayidx137.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %112, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code133.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %112, i64 0, i32 5
  %arrayidx137.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %112, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code133.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %112, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code133.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx137.i, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 15, i32* %msg_code133.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 15, i32* %msg_code133.i, align 8, !tbaa !25
Processing:   store i32 15, i32* %msg_code133.i, align 8, !tbaa !25
Count: 1
Found:   store i32 15, i32* %msg_code133.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx137.i, align 4, !tbaa !28
}
Non-memory:   %arrayidx137.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %112, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0.i, i32* %arrayidx137.i, align 4, !tbaa !28
Count: 1
Found:   store i32 %scanno.0.i, i32* %arrayidx137.i, align 4, !tbaa !28
I:   %113 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err84.i, align 8, !tbaa !24
Last:   br label %if.end141.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code133.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx137.i, align 4, !tbaa !28
Generating ALTSEQ
Values:
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Generated Version 4:
  %169 = icmp eq i8 %168, 0
  %170 = select i1 %169, i32 15, i32 %scanno.0.i
Generating ALTSEQ
Values:
  %msg_code133.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %112, i64 0, i32 5
  %arrayidx137.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %112, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %171 = select i1 %169, i32* %msg_code133.i, i32* %arrayidx137.i
Operands done!
Generated:   store i32 %170, i32* %171, align 1
Gen:   store i32 %170, i32* %171, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code133.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx137.i, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0.i", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code133.i, %arrayidx137.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
  %indvars.iv479.i = phi i64 [ %indvars.iv.next480.i, %for.inc206.i ], [ 0, %if.end141.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code157.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx161.i, align 4, !tbaa !28
Creating Node
  store i32 15, i32* %msg_code157.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx161.i, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code157.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %120, i64 0, i32 5
  %arrayidx161.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %120, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code157.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %120, i64 0, i32 5
  %arrayidx161.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %120, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code157.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %120, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code157.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx161.i, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 15, i32* %msg_code157.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 15, i32* %msg_code157.i, align 8, !tbaa !25
Processing:   store i32 15, i32* %msg_code157.i, align 8, !tbaa !25
Count: 1
Found:   store i32 15, i32* %msg_code157.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx161.i, align 4, !tbaa !28
}
Non-memory:   %arrayidx161.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %120, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0.i, i32* %arrayidx161.i, align 4, !tbaa !28
Count: 1
Found:   store i32 %scanno.0.i, i32* %arrayidx161.i, align 4, !tbaa !28
I:   %121 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err84.i, align 8, !tbaa !24
Last:   br label %if.end164.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code157.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx161.i, align 4, !tbaa !28
Generating ALTSEQ
Values:
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Generated Version 4:
  %169 = icmp eq i8 %168, 0
  %170 = select i1 %169, i32 15, i32 %scanno.0.i
Generating ALTSEQ
Values:
  %msg_code157.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %120, i64 0, i32 5
  %arrayidx161.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %120, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %171 = select i1 %169, i32* %msg_code157.i, i32* %arrayidx161.i
Operands done!
Generated:   store i32 %170, i32* %171, align 1
Gen:   store i32 %170, i32* %171, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code157.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx161.i, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0.i", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code157.i, %arrayidx161.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
  %indvars.iv477.i = phi i64 [ %indvars.iv.next478.i, %if.end200.i ], [ %115, %if.end164.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code175.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx179.i, align 4, !tbaa !28
Creating Node
  store i32 15, i32* %msg_code175.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx179.i, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code175.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %124, i64 0, i32 5
  %arrayidx179.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %124, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code175.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %124, i64 0, i32 5
  %arrayidx179.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %124, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code175.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %124, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code175.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx179.i, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 15, i32* %msg_code175.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 15, i32* %msg_code175.i, align 8, !tbaa !25
Processing:   store i32 15, i32* %msg_code175.i, align 8, !tbaa !25
Count: 1
Found:   store i32 15, i32* %msg_code175.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx179.i, align 4, !tbaa !28
}
Non-memory:   %arrayidx179.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %124, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0.i, i32* %arrayidx179.i, align 4, !tbaa !28
Count: 1
Found:   store i32 %scanno.0.i, i32* %arrayidx179.i, align 4, !tbaa !28
I:   %125 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err84.i, align 8, !tbaa !24
Last:   br label %if.end200.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code175.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx179.i, align 4, !tbaa !28
Generating ALTSEQ
Values:
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Generated Version 4:
  %169 = icmp eq i8 %168, 0
  %170 = select i1 %169, i32 15, i32 %scanno.0.i
Generating ALTSEQ
Values:
  %msg_code175.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %124, i64 0, i32 5
  %arrayidx179.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %124, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %171 = select i1 %169, i32* %msg_code175.i, i32* %arrayidx179.i
Operands done!
Generated:   store i32 %170, i32* %171, align 1
Gen:   store i32 %170, i32* %171, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code175.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx179.i, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0.i", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code175.i, %arrayidx179.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
looking for reduction
  %or.cond.i = and i1 %cmp189.not.i, %cmp186.not.i
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code192.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx196.i, align 4, !tbaa !28
Creating Node
  store i32 15, i32* %msg_code192.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx196.i, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code192.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %127, i64 0, i32 5
  %arrayidx196.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %127, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code192.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %127, i64 0, i32 5
  %arrayidx196.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %127, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code192.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %127, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code192.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx196.i, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 15, i32* %msg_code192.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 15, i32* %msg_code192.i, align 8, !tbaa !25
Processing:   store i32 15, i32* %msg_code192.i, align 8, !tbaa !25
Count: 1
Found:   store i32 15, i32* %msg_code192.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx196.i, align 4, !tbaa !28
}
Non-memory:   %arrayidx196.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %127, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0.i, i32* %arrayidx196.i, align 4, !tbaa !28
Count: 1
Found:   store i32 %scanno.0.i, i32* %arrayidx196.i, align 4, !tbaa !28
I:   %128 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err84.i, align 8, !tbaa !24
Last:   br label %if.end200.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code192.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx196.i, align 4, !tbaa !28
Generating ALTSEQ
Values:
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Generated Version 4:
  %169 = icmp eq i8 %168, 0
  %170 = select i1 %169, i32 15, i32 %scanno.0.i
Generating ALTSEQ
Values:
  %msg_code192.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %127, i64 0, i32 5
  %arrayidx196.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %127, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %171 = select i1 %169, i32* %msg_code192.i, i32* %arrayidx196.i
Operands done!
Generated:   store i32 %170, i32* %171, align 1
Gen:   store i32 %170, i32* %171, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code192.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx196.i, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0.i", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code192.i, %arrayidx196.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
looking for reduction
Attempting Group:
  store i32 %99, i32* %arrayidx169.i, align 4, !tbaa !53
looking for reduction
  %133 = or i1 %cmp212.i, %132
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 15, i32* %msg_code219.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx223.i, align 4, !tbaa !28
Creating Node
  store i32 15, i32* %msg_code219.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx223.i, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 15
Alt Seq
Creating Node
  %msg_code219.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %134, i64 0, i32 5
  %arrayidx223.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %134, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code219.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %134, i64 0, i32 5
  %arrayidx223.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %134, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code219.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %134, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 15, i32* %msg_code219.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx223.i, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 15, i32* %msg_code219.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 15, i32* %msg_code219.i, align 8, !tbaa !25
Processing:   store i32 15, i32* %msg_code219.i, align 8, !tbaa !25
Count: 1
Found:   store i32 15, i32* %msg_code219.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx223.i, align 4, !tbaa !28
}
Non-memory:   %arrayidx223.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %134, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0.i, i32* %arrayidx223.i, align 4, !tbaa !28
Count: 1
Found:   store i32 %scanno.0.i, i32* %arrayidx223.i, align 4, !tbaa !28
I:   %135 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err84.i, align 8, !tbaa !24
Last:   br label %if.end226.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 15, i32* %msg_code219.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx223.i, align 4, !tbaa !28
Generating ALTSEQ
Values:
i32 15
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Generated Version 4:
  %169 = icmp eq i8 %168, 0
  %170 = select i1 %169, i32 15, i32 %scanno.0.i
Generating ALTSEQ
Values:
  %msg_code219.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %134, i64 0, i32 5
  %arrayidx223.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %134, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %171 = select i1 %169, i32* %msg_code219.i, i32* %arrayidx223.i
Operands done!
Generated:   store i32 %170, i32* %171, align 1
Gen:   store i32 %170, i32* %171, align 1
Graph code generated!
Root:
  store i32 15, i32* %msg_code219.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx223.i, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 15, %scanno.0.i", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code219.i, %arrayidx223.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
  %indvars.iv483.i = phi i64 [ %indvars.iv.next484.i, %if.end245.i ], [ 0, %if.end226.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 17, i32* %msg_code238.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx242.i, align 4, !tbaa !28
Creating Node
  store i32 17, i32* %msg_code238.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx242.i, align 4, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 17
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 17
Alt Seq
Creating Node
  %msg_code238.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %140, i64 0, i32 5
  %arrayidx242.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %140, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code238.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %140, i64 0, i32 5
  %arrayidx242.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %140, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code238.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %140, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 17, i32* %msg_code238.i, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx242.i, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 17, i32* %msg_code238.i, align 8, !tbaa !25
}
Count: 1
Start:   store i32 17, i32* %msg_code238.i, align 8, !tbaa !25
Processing:   store i32 17, i32* %msg_code238.i, align 8, !tbaa !25
Count: 1
Found:   store i32 17, i32* %msg_code238.i, align 8, !tbaa !25
ScheduleNode: {
  store i32 %scanno.0.i, i32* %arrayidx242.i, align 4, !tbaa !28
}
Non-memory:   %arrayidx242.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %140, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %scanno.0.i, i32* %arrayidx242.i, align 4, !tbaa !28
Count: 1
Found:   store i32 %scanno.0.i, i32* %arrayidx242.i, align 4, !tbaa !28
I:   %141 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err84.i, align 8, !tbaa !24
Last:   br label %if.end245.i
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 17, i32* %msg_code238.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx242.i, align 4, !tbaa !28
Generating ALTSEQ
Values:
i32 17
  %scanno.0.i = phi i32 [ 1, %if.end26.i ], [ %inc254.i, %for.inc252.i ]
Generated Version 4:
  %169 = icmp eq i8 %168, 0
  %170 = select i1 %169, i32 17, i32 %scanno.0.i
Generating ALTSEQ
Values:
  %msg_code238.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %140, i64 0, i32 5
  %arrayidx242.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %140, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %171 = select i1 %169, i32* %msg_code238.i, i32* %arrayidx242.i
Operands done!
Generated:   store i32 %170, i32* %171, align 1
Gen:   store i32 %170, i32* %171, align 1
Graph code generated!
Root:
  store i32 17, i32* %msg_code238.i, align 8, !tbaa !25
  store i32 %scanno.0.i, i32* %arrayidx242.i, align 4, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 17, %scanno.0.i", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code238.i, %arrayidx242.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
looking for reduction
Attempting Group:
  store i32 1, i32* %arrayidx234.i, align 4, !tbaa !53
looking for reduction
  %indvars.iv472.i = phi i64 [ %indvars.iv.next473.i, %for.inc273.i ], [ 0, %for.cond259.i.preheader ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 44, i32* %msg_code269.i, align 8, !tbaa !25
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.inc290.i ], [ 0, %for.cond277.i.preheader ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 44, i32* %msg_code286.i, align 8, !tbaa !25
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %progressive_mode, align 4, !tbaa !52
  store i32 1, i32* %num_scans, align 8, !tbaa !48
Creating Node
  store i32 0, i32* %progressive_mode, align 4, !tbaa !52
  store i32 1, i32* %num_scans, align 8, !tbaa !48
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 0
i32 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Int Seq
Creating Node
  %progressive_mode = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 37
  %num_scans = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 21
Match: 0
2 x 2
Final Match: 0
  %progressive_mode = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 37
  %num_scans = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 21
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %progressive_mode = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 37
Alt Seq
ScheduleNode: {
  store i32 0, i32* %progressive_mode, align 4, !tbaa !52
}
ScheduleNode: {
  store i32 1, i32* %num_scans, align 8, !tbaa !48
}
ScheduleNode: {
  store i32 0, i32* %progressive_mode, align 4, !tbaa !52
}
Count: 1
Start:   store i32 0, i32* %progressive_mode, align 4, !tbaa !52
Processing:   store i32 0, i32* %progressive_mode, align 4, !tbaa !52
Count: 1
Found:   store i32 0, i32* %progressive_mode, align 4, !tbaa !52
ScheduleNode: {
  store i32 1, i32* %num_scans, align 8, !tbaa !48
}
Non-memory:   %num_scans = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 21
Processing:   store i32 1, i32* %num_scans, align 8, !tbaa !48
Count: 1
Found:   store i32 1, i32* %num_scans, align 8, !tbaa !48
I:   br label %if.end7
Last:   br label %if.end7
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 0, i32* %progressive_mode, align 4, !tbaa !52
  store i32 1, i32* %num_scans, align 8, !tbaa !48
Generating INTSEQ
Gen:   %169 = zext i8 %168 to i32
Generating ALTSEQ
Values:
  %progressive_mode = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 37
  %num_scans = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 21
Generated Version 4:
  %170 = icmp eq i8 %168, 0
  %171 = select i1 %170, i32* %progressive_mode, i32* %num_scans
Operands done!
Generated:   store i32 %169, i32* %171, align 1
Gen:   store i32 %169, i32* %171, align 1
Graph code generated!
Root:
  store i32 0, i32* %progressive_mode, align 4, !tbaa !52
  store i32 1, i32* %num_scans, align 8, !tbaa !48
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %progressive_mode, %num_scans", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jinit_c_master_control
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %optimize_coding, align 8, !tbaa !67
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %155, align 8, !tbaa !68
  store i32 0, i32* %156, align 4, !tbaa !69
  store i32 0, i32* %157, align 4, !tbaa !70
Creating Node
  store i32 1, i32* %155, align 8, !tbaa !68
  store i32 0, i32* %156, align 4, !tbaa !69
  store i32 0, i32* %157, align 4, !tbaa !70
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
i32 1
i32 0
i32 0
Match: 0
2 x 3
Final Match: 0
GEPSeq2
BinOP?
i32 1
Mismatching
Creating Node
  %155 = bitcast i8* %pass_type to i32*
  %156 = bitcast i8* %scan_number.c to i32*
  %157 = bitcast i8* %pass_number.c to i32*
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %pass_type = getelementptr inbounds i8, i8* %call, i64 32
  %scan_number.c = getelementptr inbounds i8, i8* %call, i64 44
  %pass_number.c = getelementptr inbounds i8, i8* %call, i64 36
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
Match: 0
1 x 3
Final Match: 0
All the Same
Creating Node
i64 32
i64 44
i64 36
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 32
Mismatching
ScheduleNode: {
  store i32 1, i32* %155, align 8, !tbaa !68
}
ScheduleNode: {
  store i32 0, i32* %156, align 4, !tbaa !69
}
ScheduleNode: {
  store i32 0, i32* %157, align 4, !tbaa !70
}
ScheduleNode: {
  store i32 1, i32* %155, align 8, !tbaa !68
}
Count: 1
Start:   %pass_type = getelementptr inbounds i8, i8* %call, i64 32
Non-memory:   %pass_type = getelementptr inbounds i8, i8* %call, i64 32
Non-memory:   %155 = bitcast i8* %pass_type to i32*
Processing:   store i32 1, i32* %155, align 8, !tbaa !68
Count: 1
Found:   store i32 1, i32* %155, align 8, !tbaa !68
ScheduleNode: {
  store i32 0, i32* %156, align 4, !tbaa !69
}
Non-memory:   %scan_number.c = getelementptr inbounds i8, i8* %call, i64 44
Non-memory:   %156 = bitcast i8* %scan_number.c to i32*
Processing:   store i32 0, i32* %156, align 4, !tbaa !69
Count: 1
Found:   store i32 0, i32* %156, align 4, !tbaa !69
ScheduleNode: {
  store i32 0, i32* %157, align 4, !tbaa !70
}
Non-memory:   %pass_number.c = getelementptr inbounds i8, i8* %call, i64 36
Non-memory:   %157 = bitcast i8* %pass_number.c to i32*
Processing:   store i32 0, i32* %157, align 4, !tbaa !70
Count: 1
Found:   store i32 0, i32* %157, align 4, !tbaa !70
I:   br label %if.then21
Last:   br label %if.then21
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 1, i32* %155, align 8, !tbaa !68
  store i32 0, i32* %156, align 4, !tbaa !69
  store i32 0, i32* %157, align 4, !tbaa !70
Generating Mismatch
Mismatched Values:
int: i32 1
int: i32 0
int: i32 0
All constants
Created array: @0 = private constant [3 x i32] [i32 1, i32 0, i32 0]
Gen:   %170 = load i32, i32* %169, align 4
Generating MATCH
Match: 
  %155 = bitcast i8* %pass_type to i32*
  %156 = bitcast i8* %scan_number.c to i32*
  %157 = bitcast i8* %pass_number.c to i32*
Generating MATCH
Match: 
  %pass_type = getelementptr inbounds i8, i8* %call, i64 32
  %scan_number.c = getelementptr inbounds i8, i8* %call, i64 44
  %pass_number.c = getelementptr inbounds i8, i8* %call, i64 36
Generating IDENTICAL
Generating Mismatch
Mismatched Values:
int: i64 32
int: i64 44
int: i64 36
All constants
Created array: @1 = private constant [3 x i64] [i64 32, i64 44, i64 36]
Gen:   %172 = load i64, i64* %171, align 8
Operands done!
Generated:   %173 = getelementptr inbounds i8, i8* %call, i64 %172
Gen:   %173 = getelementptr inbounds i8, i8* %call, i64 %172
Operands done!
Generated:   %174 = bitcast i8* %173 to i32*
Gen:   %174 = bitcast i8* %173 to i32*
Operands done!
Generated:   store i32 %170, i32* %174, align 1
Gen:   store i32 %170, i32* %174, align 1
Graph code generated!
Root:
  store i32 1, i32* %155, align 8, !tbaa !68
  store i32 0, i32* %156, align 4, !tbaa !69
  store i32 0, i32* %157, align 4, !tbaa !70
Root size: 3
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="call", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
3->2 
4->3 
5->3 
}

Gains: 12 - 14 = -2; Width: 3; Unprofitable; jinit_c_master_control
Trying AGAIN
Creating Node
  store i32 1, i32* %155, align 8, !tbaa !68
  store i32 0, i32* %156, align 4, !tbaa !69
  store i32 0, i32* %157, align 4, !tbaa !70
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
i32 1
i32 0
i32 0
Match: 0
2 x 3
Final Match: 0
GEPSeq2
BinOP?
i32 1
Mismatching
Creating Node
  %155 = bitcast i8* %pass_type to i32*
  %156 = bitcast i8* %scan_number.c to i32*
  %157 = bitcast i8* %pass_number.c to i32*
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %pass_type = getelementptr inbounds i8, i8* %call, i64 32
  %scan_number.c = getelementptr inbounds i8, i8* %call, i64 44
  %pass_number.c = getelementptr inbounds i8, i8* %call, i64 36
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
Match: 0
1 x 3
Final Match: 0
All the Same
Creating Node
i64 32
i64 44
i64 36
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 32
Mismatching
ScheduleNode: {
  store i32 1, i32* %155, align 8, !tbaa !68
}
ScheduleNode: {
  store i32 0, i32* %156, align 4, !tbaa !69
}
ScheduleNode: {
  store i32 0, i32* %157, align 4, !tbaa !70
}
ScheduleNode: {
  store i32 1, i32* %155, align 8, !tbaa !68
}
Count: 1
Start:   %pass_type = getelementptr inbounds i8, i8* %call, i64 32
Non-memory:   %pass_type = getelementptr inbounds i8, i8* %call, i64 32
Non-memory:   %155 = bitcast i8* %pass_type to i32*
Processing:   store i32 1, i32* %155, align 8, !tbaa !68
Count: 1
Found:   store i32 1, i32* %155, align 8, !tbaa !68
ScheduleNode: {
  store i32 0, i32* %156, align 4, !tbaa !69
}
Non-memory:   %scan_number.c = getelementptr inbounds i8, i8* %call, i64 44
Non-memory:   %156 = bitcast i8* %scan_number.c to i32*
Processing:   store i32 0, i32* %156, align 4, !tbaa !69
Count: 1
Found:   store i32 0, i32* %156, align 4, !tbaa !69
ScheduleNode: {
  store i32 0, i32* %157, align 4, !tbaa !70
}
Non-memory:   %pass_number.c = getelementptr inbounds i8, i8* %call, i64 36
Non-memory:   %157 = bitcast i8* %pass_number.c to i32*
Processing:   store i32 0, i32* %157, align 4, !tbaa !70
Count: 1
Found:   store i32 0, i32* %157, align 4, !tbaa !70
I:   br label %if.then21
Last:   br label %if.then21
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 1, i32* %155, align 8, !tbaa !68
  store i32 0, i32* %156, align 4, !tbaa !69
  store i32 0, i32* %157, align 4, !tbaa !70
Generating Mismatch
Mismatched Values:
int: i32 1
int: i32 0
int: i32 0
All constants
Created array: @2 = private constant [3 x i32] [i32 1, i32 0, i32 0]
Gen:   %170 = load i32, i32* %169, align 4
Generating MATCH
Match: 
  %155 = bitcast i8* %pass_type to i32*
  %156 = bitcast i8* %scan_number.c to i32*
  %157 = bitcast i8* %pass_number.c to i32*
Generating MATCH
Match: 
  %pass_type = getelementptr inbounds i8, i8* %call, i64 32
  %scan_number.c = getelementptr inbounds i8, i8* %call, i64 44
  %pass_number.c = getelementptr inbounds i8, i8* %call, i64 36
Generating IDENTICAL
Generating Mismatch
Mismatched Values:
int: i64 32
int: i64 44
int: i64 36
All constants
Created array: @3 = private constant [3 x i64] [i64 32, i64 44, i64 36]
Gen:   %172 = load i64, i64* %171, align 8
Operands done!
Generated:   %173 = getelementptr inbounds i8, i8* %call, i64 %172
Gen:   %173 = getelementptr inbounds i8, i8* %call, i64 %172
Operands done!
Generated:   %174 = bitcast i8* %173 to i32*
Gen:   %174 = bitcast i8* %173 to i32*
Operands done!
Generated:   store i32 %170, i32* %174, align 1
Gen:   store i32 %170, i32* %174, align 1
Graph code generated!
Root:
  store i32 1, i32* %155, align 8, !tbaa !68
  store i32 0, i32* %156, align 4, !tbaa !69
  store i32 0, i32* %157, align 4, !tbaa !70
Root size: 3
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="call", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
3->2 
4->3 
5->3 
}

Gains: 12 - 14 = -2; Width: 3; Unprofitable; jinit_c_master_control
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 2, i32* %158, align 8, !tbaa !68
  store i32 0, i32* %159, align 4, !tbaa !69
  store i32 0, i32* %160, align 4, !tbaa !70
Creating Node
  store i32 2, i32* %158, align 8, !tbaa !68
  store i32 0, i32* %159, align 4, !tbaa !69
  store i32 0, i32* %160, align 4, !tbaa !70
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
i32 2
i32 0
i32 0
Match: 0
2 x 3
Final Match: 0
GEPSeq2
BinOP?
i32 2
Mismatching
Creating Node
  %158 = bitcast i8* %pass_type14 to i32*
  %159 = bitcast i8* %scan_number.c81 to i32*
  %160 = bitcast i8* %pass_number.c82 to i32*
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %pass_type14 = getelementptr inbounds i8, i8* %call, i64 32
  %scan_number.c81 = getelementptr inbounds i8, i8* %call, i64 44
  %pass_number.c82 = getelementptr inbounds i8, i8* %call, i64 36
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
Match: 0
1 x 3
Final Match: 0
All the Same
Creating Node
i64 32
i64 44
i64 36
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 32
Mismatching
ScheduleNode: {
  store i32 2, i32* %158, align 8, !tbaa !68
}
ScheduleNode: {
  store i32 0, i32* %159, align 4, !tbaa !69
}
ScheduleNode: {
  store i32 0, i32* %160, align 4, !tbaa !70
}
ScheduleNode: {
  store i32 2, i32* %158, align 8, !tbaa !68
}
Count: 1
Start:   %pass_type14 = getelementptr inbounds i8, i8* %call, i64 32
Non-memory:   %pass_type14 = getelementptr inbounds i8, i8* %call, i64 32
Non-memory:   %158 = bitcast i8* %pass_type14 to i32*
Processing:   store i32 2, i32* %158, align 8, !tbaa !68
Count: 1
Found:   store i32 2, i32* %158, align 8, !tbaa !68
ScheduleNode: {
  store i32 0, i32* %159, align 4, !tbaa !69
}
Non-memory:   %scan_number.c81 = getelementptr inbounds i8, i8* %call, i64 44
Non-memory:   %159 = bitcast i8* %scan_number.c81 to i32*
Processing:   store i32 0, i32* %159, align 4, !tbaa !69
Count: 1
Found:   store i32 0, i32* %159, align 4, !tbaa !69
ScheduleNode: {
  store i32 0, i32* %160, align 4, !tbaa !70
}
Non-memory:   %pass_number.c82 = getelementptr inbounds i8, i8* %call, i64 36
Non-memory:   %160 = bitcast i8* %pass_number.c82 to i32*
Processing:   store i32 0, i32* %160, align 4, !tbaa !70
Count: 1
Found:   store i32 0, i32* %160, align 4, !tbaa !70
I:   br label %if.else23
Last:   br label %if.else23
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 2, i32* %158, align 8, !tbaa !68
  store i32 0, i32* %159, align 4, !tbaa !69
  store i32 0, i32* %160, align 4, !tbaa !70
Generating Mismatch
Mismatched Values:
int: i32 2
int: i32 0
int: i32 0
All constants
Created array: @4 = private constant [3 x i32] [i32 2, i32 0, i32 0]
Gen:   %170 = load i32, i32* %169, align 4
Generating MATCH
Match: 
  %158 = bitcast i8* %pass_type14 to i32*
  %159 = bitcast i8* %scan_number.c81 to i32*
  %160 = bitcast i8* %pass_number.c82 to i32*
Generating MATCH
Match: 
  %pass_type14 = getelementptr inbounds i8, i8* %call, i64 32
  %scan_number.c81 = getelementptr inbounds i8, i8* %call, i64 44
  %pass_number.c82 = getelementptr inbounds i8, i8* %call, i64 36
Generating IDENTICAL
Generating Mismatch
Mismatched Values:
int: i64 32
int: i64 44
int: i64 36
All constants
Created array: @5 = private constant [3 x i64] [i64 32, i64 44, i64 36]
Gen:   %172 = load i64, i64* %171, align 8
Operands done!
Generated:   %173 = getelementptr inbounds i8, i8* %call, i64 %172
Gen:   %173 = getelementptr inbounds i8, i8* %call, i64 %172
Operands done!
Generated:   %174 = bitcast i8* %173 to i32*
Gen:   %174 = bitcast i8* %173 to i32*
Operands done!
Generated:   store i32 %170, i32* %174, align 1
Gen:   store i32 %170, i32* %174, align 1
Graph code generated!
Root:
  store i32 2, i32* %158, align 8, !tbaa !68
  store i32 0, i32* %159, align 4, !tbaa !69
  store i32 0, i32* %160, align 4, !tbaa !70
Root size: 3
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="call", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
3->2 
4->3 
5->3 
}

Gains: 12 - 14 = -2; Width: 3; Unprofitable; jinit_c_master_control
Trying AGAIN
Creating Node
  store i32 2, i32* %158, align 8, !tbaa !68
  store i32 0, i32* %159, align 4, !tbaa !69
  store i32 0, i32* %160, align 4, !tbaa !70
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
i32 2
i32 0
i32 0
Match: 0
2 x 3
Final Match: 0
GEPSeq2
BinOP?
i32 2
Mismatching
Creating Node
  %158 = bitcast i8* %pass_type14 to i32*
  %159 = bitcast i8* %scan_number.c81 to i32*
  %160 = bitcast i8* %pass_number.c82 to i32*
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %pass_type14 = getelementptr inbounds i8, i8* %call, i64 32
  %scan_number.c81 = getelementptr inbounds i8, i8* %call, i64 44
  %pass_number.c82 = getelementptr inbounds i8, i8* %call, i64 36
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
Match: 0
1 x 3
Final Match: 0
All the Same
Creating Node
i64 32
i64 44
i64 36
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 32
Mismatching
ScheduleNode: {
  store i32 2, i32* %158, align 8, !tbaa !68
}
ScheduleNode: {
  store i32 0, i32* %159, align 4, !tbaa !69
}
ScheduleNode: {
  store i32 0, i32* %160, align 4, !tbaa !70
}
ScheduleNode: {
  store i32 2, i32* %158, align 8, !tbaa !68
}
Count: 1
Start:   %pass_type14 = getelementptr inbounds i8, i8* %call, i64 32
Non-memory:   %pass_type14 = getelementptr inbounds i8, i8* %call, i64 32
Non-memory:   %158 = bitcast i8* %pass_type14 to i32*
Processing:   store i32 2, i32* %158, align 8, !tbaa !68
Count: 1
Found:   store i32 2, i32* %158, align 8, !tbaa !68
ScheduleNode: {
  store i32 0, i32* %159, align 4, !tbaa !69
}
Non-memory:   %scan_number.c81 = getelementptr inbounds i8, i8* %call, i64 44
Non-memory:   %159 = bitcast i8* %scan_number.c81 to i32*
Processing:   store i32 0, i32* %159, align 4, !tbaa !69
Count: 1
Found:   store i32 0, i32* %159, align 4, !tbaa !69
ScheduleNode: {
  store i32 0, i32* %160, align 4, !tbaa !70
}
Non-memory:   %pass_number.c82 = getelementptr inbounds i8, i8* %call, i64 36
Non-memory:   %160 = bitcast i8* %pass_number.c82 to i32*
Processing:   store i32 0, i32* %160, align 4, !tbaa !70
Count: 1
Found:   store i32 0, i32* %160, align 4, !tbaa !70
I:   br label %if.else23
Last:   br label %if.else23
Schedulable: 1
Loop Rolling: jinit_c_master_control
Generating tree
Generating MATCH
Match: 
  store i32 2, i32* %158, align 8, !tbaa !68
  store i32 0, i32* %159, align 4, !tbaa !69
  store i32 0, i32* %160, align 4, !tbaa !70
Generating Mismatch
Mismatched Values:
int: i32 2
int: i32 0
int: i32 0
All constants
Created array: @6 = private constant [3 x i32] [i32 2, i32 0, i32 0]
Gen:   %170 = load i32, i32* %169, align 4
Generating MATCH
Match: 
  %158 = bitcast i8* %pass_type14 to i32*
  %159 = bitcast i8* %scan_number.c81 to i32*
  %160 = bitcast i8* %pass_number.c82 to i32*
Generating MATCH
Match: 
  %pass_type14 = getelementptr inbounds i8, i8* %call, i64 32
  %scan_number.c81 = getelementptr inbounds i8, i8* %call, i64 44
  %pass_number.c82 = getelementptr inbounds i8, i8* %call, i64 36
Generating IDENTICAL
Generating Mismatch
Mismatched Values:
int: i64 32
int: i64 44
int: i64 36
All constants
Created array: @7 = private constant [3 x i64] [i64 32, i64 44, i64 36]
Gen:   %172 = load i64, i64* %171, align 8
Operands done!
Generated:   %173 = getelementptr inbounds i8, i8* %call, i64 %172
Gen:   %173 = getelementptr inbounds i8, i8* %call, i64 %172
Operands done!
Generated:   %174 = bitcast i8* %173 to i32*
Gen:   %174 = bitcast i8* %173 to i32*
Operands done!
Generated:   store i32 %170, i32* %174, align 1
Gen:   store i32 %170, i32* %174, align 1
Graph code generated!
Root:
  store i32 2, i32* %158, align 8, !tbaa !68
  store i32 0, i32* %159, align 4, !tbaa !69
  store i32 0, i32* %160, align 4, !tbaa !70
Root size: 3
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="call", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
3->2 
4->3 
5->3 
}

Gains: 12 - 14 = -2; Width: 3; Unprofitable; jinit_c_master_control
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %161, align 8, !tbaa !68
  store i32 0, i32* %162, align 4, !tbaa !69
  store i32 0, i32* %163, align 4, !tbaa !70
Creating Node
  store i32 0, i32* %161, align 8, !tbaa !68
  store i32 0, i32* %162, align 4, !tbaa !69
  store i32 0, i32* %163, align 4, !tbaa !70
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
i32 0
i32 0
i32 0
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
  %161 = bitcast i8* %pass_type17 to i32*
  %162 = bitcast i8* %scan_number to i32*
  %163 = bitcast i8* %pass_number to i32*
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %pass_type17 = getelementptr inbounds i8, i8* %call, i64 32
  %scan_number = getelementptr inbounds i8, i8* %call, i64 44
  %pass_number = getelementptr inbounds i8, i8* %call, i64 36
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
Match: 0
1 x 3
Final Match: 0
All the Same
Creating Node
i64 32
i64 44
i64 36
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 32
Mismatching
ScheduleNode: {
  store i32 0, i32* %161, align 8, !tbaa !68
}
ScheduleNode: {
  store i32 0, i32* %162, align 4, !tbaa !69
}
ScheduleNode: {
  store i32 0, i32* %163, align 4, !tbaa !70
}
ScheduleNode: {
  store i32 0, i32* %161, align 8, !tbaa !68
}
Count: 1
Start:   %pass_type17 = getelementptr inbounds i8, i8* %call, i64 32
Non-memory:   %pass_type17 = getelementptr inbounds i8, i8* %call, i64 32
Non-memory:   %161 = bitcast i8* %pass_type17 to i32*
Processing:   store i32 0, i32* %161, align 8, !tbaa !68
Count: 1
Found:   store i32 0, i32* %161, align 8, !tbaa !68
ScheduleNode: {
  store i32 0, i32* %162, align 4, !tbaa !69
}
Non-memory:   %optimize_coding19.phi.trans.insert = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
Processing:   %.pre76 = load i32, i32* %optimize_coding19.phi.trans.insert, align 8, !tbaa !67
Count: 1
Not found:   %.pre76 = load i32, i32* %optimize_coding19.phi.trans.insert, align 8, !tbaa !67
Read/Write memory
I:   %.pre76 = load i32, i32* %optimize_coding19.phi.trans.insert, align 8, !tbaa !67
Last:   br i1 %phi.cmp77, label %if.else23, label %if.then21
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="call", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
3->2 
4->3 
5->3 
}


if.else16:                                        ; preds = %if.end7
  %pass_type17 = getelementptr inbounds i8, i8* %call, i64 32
  %161 = bitcast i8* %pass_type17 to i32*
  store i32 0, i32* %161, align 8, !tbaa !68
  %optimize_coding19.phi.trans.insert = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %.pre76 = load i32, i32* %optimize_coding19.phi.trans.insert, align 8, !tbaa !67
  %phi.cmp77 = icmp eq i32 %.pre76, 0
  %scan_number = getelementptr inbounds i8, i8* %call, i64 44
  %162 = bitcast i8* %scan_number to i32*
  store i32 0, i32* %162, align 4, !tbaa !69
  %pass_number = getelementptr inbounds i8, i8* %call, i64 36
  %163 = bitcast i8* %pass_number to i32*
  store i32 0, i32* %163, align 4, !tbaa !70
  br i1 %phi.cmp77, label %if.else23, label %if.then21

Trying AGAIN
Creating Node
  store i32 0, i32* %161, align 8, !tbaa !68
  store i32 0, i32* %162, align 4, !tbaa !69
  store i32 0, i32* %163, align 4, !tbaa !70
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
i32 0
i32 0
i32 0
Match: 1
1 x 3
Final Match: 1
All the Same
Creating Node
  %161 = bitcast i8* %pass_type17 to i32*
  %162 = bitcast i8* %scan_number to i32*
  %163 = bitcast i8* %pass_number to i32*
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %pass_type17 = getelementptr inbounds i8, i8* %call, i64 32
  %scan_number = getelementptr inbounds i8, i8* %call, i64 44
  %pass_number = getelementptr inbounds i8, i8* %call, i64 36
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
  %call = tail call i8* %2(%struct.jpeg_common_struct* %3, i32 1, i64 48) #3
Match: 0
1 x 3
Final Match: 0
All the Same
Creating Node
i64 32
i64 44
i64 36
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
i64 32
Mismatching
ScheduleNode: {
  store i32 0, i32* %161, align 8, !tbaa !68
}
ScheduleNode: {
  store i32 0, i32* %162, align 4, !tbaa !69
}
ScheduleNode: {
  store i32 0, i32* %163, align 4, !tbaa !70
}
ScheduleNode: {
  store i32 0, i32* %161, align 8, !tbaa !68
}
Count: 1
Start:   %pass_type17 = getelementptr inbounds i8, i8* %call, i64 32
Non-memory:   %pass_type17 = getelementptr inbounds i8, i8* %call, i64 32
Non-memory:   %161 = bitcast i8* %pass_type17 to i32*
Processing:   store i32 0, i32* %161, align 8, !tbaa !68
Count: 1
Found:   store i32 0, i32* %161, align 8, !tbaa !68
ScheduleNode: {
  store i32 0, i32* %162, align 4, !tbaa !69
}
Non-memory:   %optimize_coding19.phi.trans.insert = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
Processing:   %.pre76 = load i32, i32* %optimize_coding19.phi.trans.insert, align 8, !tbaa !67
Count: 1
Not found:   %.pre76 = load i32, i32* %optimize_coding19.phi.trans.insert, align 8, !tbaa !67
Read/Write memory
I:   %.pre76 = load i32, i32* %optimize_coding19.phi.trans.insert, align 8, !tbaa !67
Last:   br i1 %phi.cmp77, label %if.else23, label %if.then21
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="bitcast", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="getelementptr", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="call", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
3->2 
4->3 
5->3 
}


if.else16:                                        ; preds = %if.end7
  %pass_type17 = getelementptr inbounds i8, i8* %call, i64 32
  %161 = bitcast i8* %pass_type17 to i32*
  store i32 0, i32* %161, align 8, !tbaa !68
  %optimize_coding19.phi.trans.insert = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 25
  %.pre76 = load i32, i32* %optimize_coding19.phi.trans.insert, align 8, !tbaa !67
  %phi.cmp77 = icmp eq i32 %.pre76, 0
  %scan_number = getelementptr inbounds i8, i8* %call, i64 44
  %162 = bitcast i8* %scan_number to i32*
  store i32 0, i32* %162, align 4, !tbaa !69
  %pass_number = getelementptr inbounds i8, i8* %call, i64 36
  %163 = bitcast i8* %pass_number to i32*
  store i32 0, i32* %163, align 4, !tbaa !70
  br i1 %phi.cmp77, label %if.else23, label %if.then21

looking for reduction
  %mul = shl nsw i32 %164, 1
Attempting Group:
  store i32 %mul, i32* %165, align 8, !tbaa !71
looking for reduction
Attempting Group:
  store i32 %166, i32* %167, align 8, !tbaa !71
looking for reduction
Done Loop Roller: 0/25
Optimizing: select_scan_parameters
looking for reduction
looking for reduction
Attempting Group:
  store i32 %4, i32* %comps_in_scan3, align 4, !tbaa !16
  %indvars.iv85 = phi i64 [ %indvars.iv.next86, %for.body ], [ 0, %if.then ]
looking for reduction
looking for reduction
Attempting Group:
  store %struct.jpeg_component_info* %arrayidx7, %struct.jpeg_component_info** %arrayidx9, align 8, !tbaa !19
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %8, i32* %Ss10, align 4, !tbaa !23
  store i32 %9, i32* %Se11, align 8, !tbaa !25
  store i32 %10, i32* %Ah12, align 4, !tbaa !27
  store i32 %11, i32* %Al13, align 8, !tbaa !29
Creating Node
  store i32 %8, i32* %Ss10, align 4, !tbaa !23
  store i32 %9, i32* %Se11, align 8, !tbaa !25
  store i32 %10, i32* %Ah12, align 4, !tbaa !27
  store i32 %11, i32* %Al13, align 8, !tbaa !29
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %8 = load i32, i32* %Ss, align 4, !tbaa !22
  %9 = load i32, i32* %Se, align 4, !tbaa !24
  %10 = load i32, i32* %Ah, align 4, !tbaa !26
  %11 = load i32, i32* %Al, align 4, !tbaa !28
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %Ss = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 2
  %Se = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 3
  %Ah = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 4
  %Al = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 5
Match: 0
4 x 4
Final Match: 0
  %Ss = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 2
  %Se = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 3
  %Ah = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 4
  %Al = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 5
GEPSeq2
%struct.jpeg_scan_info = type { i32, [4 x i32], i32, i32, i32, i32 }
BinOP?
  %Ss = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 2
Mismatching
Creating Node
  %Ss10 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
  %Se11 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 48
  %Ah12 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
  %Al13 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 50
Match: 0
4 x 4
Final Match: 0
  %Ss10 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
  %Se11 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 48
  %Ah12 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
  %Al13 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 50
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %Ss10 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
Mismatching
ScheduleNode: {
  %8 = load i32, i32* %Ss, align 4, !tbaa !22
}
ScheduleNode: {
  store i32 %8, i32* %Ss10, align 4, !tbaa !23
}
ScheduleNode: {
  %9 = load i32, i32* %Se, align 4, !tbaa !24
}
ScheduleNode: {
  store i32 %9, i32* %Se11, align 8, !tbaa !25
}
ScheduleNode: {
  %10 = load i32, i32* %Ah, align 4, !tbaa !26
}
ScheduleNode: {
  store i32 %10, i32* %Ah12, align 4, !tbaa !27
}
ScheduleNode: {
  %11 = load i32, i32* %Al, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 %11, i32* %Al13, align 8, !tbaa !29
}
ScheduleNode: {
  %8 = load i32, i32* %Ss, align 4, !tbaa !22
}
Count: 1
Start:   %8 = load i32, i32* %Ss, align 4, !tbaa !22
Processing:   %8 = load i32, i32* %Ss, align 4, !tbaa !22
Count: 1
Found:   %8 = load i32, i32* %Ss, align 4, !tbaa !22
ScheduleNode: {
  store i32 %8, i32* %Ss10, align 4, !tbaa !23
}
Non-memory:   %Ss10 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
Processing:   store i32 %8, i32* %Ss10, align 4, !tbaa !23
Count: 1
Found:   store i32 %8, i32* %Ss10, align 4, !tbaa !23
ScheduleNode: {
  %9 = load i32, i32* %Se, align 4, !tbaa !24
}
Non-memory:   %Se = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 3
Processing:   %9 = load i32, i32* %Se, align 4, !tbaa !24
Count: 1
Found:   %9 = load i32, i32* %Se, align 4, !tbaa !24
ScheduleNode: {
  store i32 %9, i32* %Se11, align 8, !tbaa !25
}
Non-memory:   %Se11 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 48
Processing:   store i32 %9, i32* %Se11, align 8, !tbaa !25
Count: 1
Found:   store i32 %9, i32* %Se11, align 8, !tbaa !25
ScheduleNode: {
  %10 = load i32, i32* %Ah, align 4, !tbaa !26
}
Non-memory:   %Ah = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 4
Processing:   %10 = load i32, i32* %Ah, align 4, !tbaa !26
Count: 1
Found:   %10 = load i32, i32* %Ah, align 4, !tbaa !26
ScheduleNode: {
  store i32 %10, i32* %Ah12, align 4, !tbaa !27
}
Non-memory:   %Ah12 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
Processing:   store i32 %10, i32* %Ah12, align 4, !tbaa !27
Count: 1
Found:   store i32 %10, i32* %Ah12, align 4, !tbaa !27
ScheduleNode: {
  %11 = load i32, i32* %Al, align 4, !tbaa !28
}
Non-memory:   %Al = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 5
Processing:   %11 = load i32, i32* %Al, align 4, !tbaa !28
Count: 1
Found:   %11 = load i32, i32* %Al, align 4, !tbaa !28
ScheduleNode: {
  store i32 %11, i32* %Al13, align 8, !tbaa !29
}
Non-memory:   %Al13 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 50
Processing:   store i32 %11, i32* %Al13, align 8, !tbaa !29
Count: 1
Found:   store i32 %11, i32* %Al13, align 8, !tbaa !29
I:   br label %if.end43
Last:   br label %if.end43
Schedulable: 1
Loop Rolling: select_scan_parameters
Generating tree
Generating MATCH
Match: 
  store i32 %8, i32* %Ss10, align 4, !tbaa !23
  store i32 %9, i32* %Se11, align 8, !tbaa !25
  store i32 %10, i32* %Ah12, align 4, !tbaa !27
  store i32 %11, i32* %Al13, align 8, !tbaa !29
Generating MATCH
Match: 
  %8 = load i32, i32* %Ss, align 4, !tbaa !22
  %9 = load i32, i32* %Se, align 4, !tbaa !24
  %10 = load i32, i32* %Ah, align 4, !tbaa !26
  %11 = load i32, i32* %Al, align 4, !tbaa !28
Generating Mismatch
Mismatched Values:
inst:   %Ss = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 2
inst:   %Se = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 3
inst:   %Ah = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 4
inst:   %Al = getelementptr inbounds %struct.jpeg_scan_info, %struct.jpeg_scan_info* %0, i64 %idx.ext, i32 5
Non constants
Array Type: 4:i32*
Created array:   %21 = alloca i32*, i8 4, align 8
Gen:   %28 = load i32*, i32** %27, align 8
Operands done!
Generated:   %29 = load i32, i32* %28, align 1
Gen:   %29 = load i32, i32* %28, align 1
Generating Mismatch
Mismatched Values:
inst:   %Ss10 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
inst:   %Se11 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 48
inst:   %Ah12 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
inst:   %Al13 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 50
Non constants
Array Type: 4:i32*
Created array:   %26 = alloca i32*, i8 4, align 8
Gen:   %36 = load i32*, i32** %35, align 8
Operands done!
Generated:   store i32 %34, i32* %36, align 1
Gen:   store i32 %34, i32* %36, align 1
Graph code generated!
Root:
  store i32 %8, i32* %Ss10, align 4, !tbaa !23
  store i32 %9, i32* %Se11, align 8, !tbaa !25
  store i32 %10, i32* %Ah12, align 4, !tbaa !27
  store i32 %11, i32* %Al13, align 8, !tbaa !29
Root size: 4
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
3->0 
2->1 
}

Gains: 16 - 108 = -92; Width: 4; Unprofitable; select_scan_parameters
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 4, i32* %arrayidx22, align 4, !tbaa !35
Attempting Group:
  store i32 24, i32* %msg_code, align 8, !tbaa !32
  store i32 %12, i32* %arrayidx18, align 4, !tbaa !35
Creating Node
  store i32 24, i32* %msg_code, align 8, !tbaa !32
  store i32 %12, i32* %arrayidx18, align 4, !tbaa !35
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 24
  %12 = load i32, i32* %num_components, align 4, !tbaa !30
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 24
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 5
  %arrayidx18 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 5
  %arrayidx18 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 24, i32* %msg_code, align 8, !tbaa !32
}
ScheduleNode: {
  store i32 %12, i32* %arrayidx18, align 4, !tbaa !35
}
ScheduleNode: {
  store i32 24, i32* %msg_code, align 8, !tbaa !32
}
Count: 1
Start:   store i32 24, i32* %msg_code, align 8, !tbaa !32
Processing:   store i32 24, i32* %msg_code, align 8, !tbaa !32
Count: 1
Found:   store i32 24, i32* %msg_code, align 8, !tbaa !32
ScheduleNode: {
  store i32 %12, i32* %arrayidx18, align 4, !tbaa !35
}
Non-memory:   %arrayidx18 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %12, i32* %arrayidx18, align 4, !tbaa !35
Count: 1
Found:   store i32 %12, i32* %arrayidx18, align 4, !tbaa !35
I:   %14 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !31
Last:   br label %if.end
Schedulable: 1
Loop Rolling: select_scan_parameters
Generating tree
Generating MATCH
Match: 
  store i32 24, i32* %msg_code, align 8, !tbaa !32
  store i32 %12, i32* %arrayidx18, align 4, !tbaa !35
Generating ALTSEQ
Values:
i32 24
  %12 = load i32, i32* %num_components, align 4, !tbaa !30
Generated Version 4:
  %22 = icmp eq i8 %21, 0
  %23 = select i1 %22, i32 24, i32 %12
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 5
  %arrayidx18 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %24 = select i1 %22, i32* %msg_code, i32* %arrayidx18
Operands done!
Generated:   store i32 %23, i32* %24, align 1
Gen:   store i32 %23, i32* %24, align 1
Graph code generated!
Root:
  store i32 24, i32* %msg_code, align 8, !tbaa !32
  store i32 %12, i32* %arrayidx18, align 4, !tbaa !35
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 24, %12", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx18", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; select_scan_parameters
Trying AGAIN
Trying AGAIN
  %18 = phi i32 [ %.pre, %if.then15 ], [ %12, %if.else ]
looking for reduction
Attempting Group:
  store i32 %18, i32* %comps_in_scan25, align 4, !tbaa !16
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body29 ], [ 0, %if.end ]
looking for reduction
looking for reduction
Attempting Group:
  store %struct.jpeg_component_info* %arrayidx32, %struct.jpeg_component_info** %arrayidx35, align 8, !tbaa !19
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %Ss39, align 4, !tbaa !23
  store i32 63, i32* %Se40, align 8, !tbaa !25
  store i32 0, i32* %Ah41, align 4, !tbaa !27
  store i32 0, i32* %Al42, align 8, !tbaa !29
Creating Node
  store i32 0, i32* %Ss39, align 4, !tbaa !23
  store i32 63, i32* %Se40, align 8, !tbaa !25
  store i32 0, i32* %Ah41, align 4, !tbaa !27
  store i32 0, i32* %Al42, align 8, !tbaa !29
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
i32 0
i32 63
i32 0
i32 0
Match: 0
2 x 4
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %Ss39 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
  %Se40 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 48
  %Ah41 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
  %Al42 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 50
Match: 0
4 x 4
Final Match: 0
  %Ss39 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
  %Se40 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 48
  %Ah41 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
  %Al42 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 50
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %Ss39 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
Mismatching
ScheduleNode: {
  store i32 0, i32* %Ss39, align 4, !tbaa !23
}
ScheduleNode: {
  store i32 63, i32* %Se40, align 8, !tbaa !25
}
ScheduleNode: {
  store i32 0, i32* %Ah41, align 4, !tbaa !27
}
ScheduleNode: {
  store i32 0, i32* %Al42, align 8, !tbaa !29
}
ScheduleNode: {
  store i32 0, i32* %Ss39, align 4, !tbaa !23
}
Count: 1
Start:   store i32 0, i32* %Ss39, align 4, !tbaa !23
Processing:   store i32 0, i32* %Ss39, align 4, !tbaa !23
Count: 1
Found:   store i32 0, i32* %Ss39, align 4, !tbaa !23
ScheduleNode: {
  store i32 63, i32* %Se40, align 8, !tbaa !25
}
Non-memory:   %Se40 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 48
Processing:   store i32 63, i32* %Se40, align 8, !tbaa !25
Count: 1
Found:   store i32 63, i32* %Se40, align 8, !tbaa !25
ScheduleNode: {
  store i32 0, i32* %Ah41, align 4, !tbaa !27
}
Non-memory:   %Ah41 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
Processing:   store i32 0, i32* %Ah41, align 4, !tbaa !27
Count: 1
Found:   store i32 0, i32* %Ah41, align 4, !tbaa !27
ScheduleNode: {
  store i32 0, i32* %Al42, align 8, !tbaa !29
}
Non-memory:   %Al42 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 50
Processing:   store i32 0, i32* %Al42, align 8, !tbaa !29
Count: 1
Found:   store i32 0, i32* %Al42, align 8, !tbaa !29
I:   br label %if.end43
Last:   br label %if.end43
Schedulable: 1
Loop Rolling: select_scan_parameters
Generating tree
Generating MATCH
Match: 
  store i32 0, i32* %Ss39, align 4, !tbaa !23
  store i32 63, i32* %Se40, align 8, !tbaa !25
  store i32 0, i32* %Ah41, align 4, !tbaa !27
  store i32 0, i32* %Al42, align 8, !tbaa !29
Generating Mismatch
Mismatched Values:
int: i32 0
int: i32 63
int: i32 0
int: i32 0
All constants
Created array: @8 = private constant [4 x i32] [i32 0, i32 63, i32 0, i32 0]
Gen:   %23 = load i32, i32* %22, align 4
Generating Mismatch
Mismatched Values:
inst:   %Ss39 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 47
inst:   %Se40 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 48
inst:   %Ah41 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 49
inst:   %Al42 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 50
Non constants
Array Type: 4:i32*
Created array:   %21 = alloca i32*, i8 4, align 8
Gen:   %30 = load i32*, i32** %29, align 8
Operands done!
Generated:   store i32 %28, i32* %30, align 1
Gen:   store i32 %28, i32* %30, align 1
Graph code generated!
Root:
  store i32 0, i32* %Ss39, align 4, !tbaa !23
  store i32 63, i32* %Se40, align 8, !tbaa !25
  store i32 0, i32* %Ah41, align 4, !tbaa !27
  store i32 0, i32* %Al42, align 8, !tbaa !29
Root size: 4
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="constant mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}

Gains: 8 - 59 = -51; Width: 4; Unprofitable; select_scan_parameters
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
looking for reduction
Done Loop Roller: 0/3
Optimizing: per_scan_setup
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %MCU_width, align 4, !tbaa !16
  store i32 1, i32* %MCU_height, align 8, !tbaa !17
  store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
  store i32 8, i32* %MCU_sample_width, align 8, !tbaa !19
  store i32 1, i32* %last_col_width, align 4, !tbaa !20
  store i32 %spec.select, i32* %last_row_height, align 8, !tbaa !22
Attempting Group:
  store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
  store i32 %3, i32* %MCU_rows_in_scan, align 4, !tbaa !15
  store i32 1, i32* %blocks_in_MCU, align 8, !tbaa !23
  store i32 0, i32* %arrayidx5, align 4, !tbaa !24
Creating Node
  store i32 1, i32* %MCU_width, align 4, !tbaa !16
  store i32 1, i32* %MCU_height, align 8, !tbaa !17
  store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
  store i32 8, i32* %MCU_sample_width, align 8, !tbaa !19
  store i32 1, i32* %last_col_width, align 4, !tbaa !20
  store i32 %spec.select, i32* %last_row_height, align 8, !tbaa !22
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
i32 1
i32 1
i32 1
i32 8
i32 1
  %spec.select = select i1 %cmp2, i32 %4, i32 %rem
Match: 0
3 x 6
Final Match: 0
GEPSeq2
BinOP?
i32 1
Mismatching
Creating Node
  %MCU_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
  %MCU_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
  %MCU_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
  %MCU_sample_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 16
  %last_col_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 17
  %last_row_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 18
Match: 0
6 x 6
Final Match: 0
  %MCU_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
  %MCU_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
  %MCU_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
  %MCU_sample_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 16
  %last_col_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 17
  %last_row_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 18
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %MCU_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
Mismatching
ScheduleNode: {
  store i32 1, i32* %MCU_width, align 4, !tbaa !16
}
ScheduleNode: {
  store i32 1, i32* %MCU_height, align 8, !tbaa !17
}
ScheduleNode: {
  store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
}
ScheduleNode: {
  store i32 8, i32* %MCU_sample_width, align 8, !tbaa !19
}
ScheduleNode: {
  store i32 1, i32* %last_col_width, align 4, !tbaa !20
}
ScheduleNode: {
  store i32 %spec.select, i32* %last_row_height, align 8, !tbaa !22
}
ScheduleNode: {
  store i32 1, i32* %MCU_width, align 4, !tbaa !16
}
Count: 1
Start:   store i32 1, i32* %MCU_width, align 4, !tbaa !16
Processing:   store i32 1, i32* %MCU_width, align 4, !tbaa !16
Count: 1
Found:   store i32 1, i32* %MCU_width, align 4, !tbaa !16
ScheduleNode: {
  store i32 1, i32* %MCU_height, align 8, !tbaa !17
}
Non-memory:   %MCU_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
Processing:   store i32 1, i32* %MCU_height, align 8, !tbaa !17
Count: 1
Found:   store i32 1, i32* %MCU_height, align 8, !tbaa !17
ScheduleNode: {
  store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
}
Non-memory:   %MCU_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
Processing:   store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
Count: 1
Found:   store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
ScheduleNode: {
  store i32 8, i32* %MCU_sample_width, align 8, !tbaa !19
}
Non-memory:   %MCU_sample_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 16
Processing:   store i32 8, i32* %MCU_sample_width, align 8, !tbaa !19
Count: 1
Found:   store i32 8, i32* %MCU_sample_width, align 8, !tbaa !19
ScheduleNode: {
  store i32 1, i32* %last_col_width, align 4, !tbaa !20
}
Non-memory:   %last_col_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 17
Processing:   store i32 1, i32* %last_col_width, align 4, !tbaa !20
Count: 1
Found:   store i32 1, i32* %last_col_width, align 4, !tbaa !20
ScheduleNode: {
  store i32 %spec.select, i32* %last_row_height, align 8, !tbaa !22
}
Non-memory:   %v_samp_factor = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 3
Processing:   %4 = load i32, i32* %v_samp_factor, align 4, !tbaa !21
Count: 1
Not found:   %4 = load i32, i32* %v_samp_factor, align 4, !tbaa !21
Read/Write memory
I:   %4 = load i32, i32* %v_samp_factor, align 4, !tbaa !21
Last:   br label %if.end80
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


if.then:                                          ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 42, i64 0
  %1 = load %struct.jpeg_component_info*, %struct.jpeg_component_info** %arrayidx, align 8, !tbaa !10
  %width_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 7
  %2 = load i32, i32* %width_in_blocks, align 4, !tbaa !11
  %MCUs_per_row = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 43
  store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
  %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 8
  %3 = load i32, i32* %height_in_blocks, align 8, !tbaa !14
  %MCU_rows_in_scan = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 44
  store i32 %3, i32* %MCU_rows_in_scan, align 4, !tbaa !15
  %MCU_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
  store i32 1, i32* %MCU_width, align 4, !tbaa !16
  %MCU_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
  store i32 1, i32* %MCU_height, align 8, !tbaa !17
  %MCU_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
  store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
  %MCU_sample_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 16
  store i32 8, i32* %MCU_sample_width, align 8, !tbaa !19
  %last_col_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 17
  store i32 1, i32* %last_col_width, align 4, !tbaa !20
  %v_samp_factor = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 3
  %4 = load i32, i32* %v_samp_factor, align 4, !tbaa !21
  %rem = urem i32 %3, %4
  %cmp2 = icmp eq i32 %rem, 0
  %spec.select = select i1 %cmp2, i32 %4, i32 %rem
  %last_row_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 18
  store i32 %spec.select, i32* %last_row_height, align 8, !tbaa !22
  %blocks_in_MCU = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 45
  store i32 1, i32* %blocks_in_MCU, align 8, !tbaa !23
  %arrayidx5 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 46, i64 0
  store i32 0, i32* %arrayidx5, align 4, !tbaa !24
  br label %if.end80

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Creating Node
  store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
  store i32 %3, i32* %MCU_rows_in_scan, align 4, !tbaa !15
  store i32 1, i32* %blocks_in_MCU, align 8, !tbaa !23
  store i32 0, i32* %arrayidx5, align 4, !tbaa !24
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %2 = load i32, i32* %width_in_blocks, align 4, !tbaa !11
  %3 = load i32, i32* %height_in_blocks, align 8, !tbaa !14
i32 1
i32 0
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %2 = load i32, i32* %width_in_blocks, align 4, !tbaa !11
Mismatching
Creating Node
  %MCUs_per_row = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 43
  %MCU_rows_in_scan = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 44
  %blocks_in_MCU = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 45
  %arrayidx5 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 46, i64 0
Match: 0
4 x 4
Final Match: 0
  %MCUs_per_row = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 43
  %MCU_rows_in_scan = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 44
  %blocks_in_MCU = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 45
  %arrayidx5 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 46, i64 0
GEPSeq2
BinOP?
  %MCUs_per_row = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 43
Mismatching
ScheduleNode: {
  store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
}
ScheduleNode: {
  store i32 %3, i32* %MCU_rows_in_scan, align 4, !tbaa !15
}
ScheduleNode: {
  store i32 1, i32* %blocks_in_MCU, align 8, !tbaa !23
}
ScheduleNode: {
  store i32 0, i32* %arrayidx5, align 4, !tbaa !24
}
ScheduleNode: {
  store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
}
Count: 1
Start:   store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
Processing:   store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
Count: 1
Found:   store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
ScheduleNode: {
  store i32 %3, i32* %MCU_rows_in_scan, align 4, !tbaa !15
}
Non-memory:   %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 8
Processing:   %3 = load i32, i32* %height_in_blocks, align 8, !tbaa !14
Count: 1
Not found:   %3 = load i32, i32* %height_in_blocks, align 8, !tbaa !14
Read/Write memory
I:   %3 = load i32, i32* %height_in_blocks, align 8, !tbaa !14
Last:   br label %if.end80
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


if.then:                                          ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 42, i64 0
  %1 = load %struct.jpeg_component_info*, %struct.jpeg_component_info** %arrayidx, align 8, !tbaa !10
  %width_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 7
  %2 = load i32, i32* %width_in_blocks, align 4, !tbaa !11
  %MCUs_per_row = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 43
  store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
  %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 8
  %3 = load i32, i32* %height_in_blocks, align 8, !tbaa !14
  %MCU_rows_in_scan = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 44
  store i32 %3, i32* %MCU_rows_in_scan, align 4, !tbaa !15
  %MCU_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
  store i32 1, i32* %MCU_width, align 4, !tbaa !16
  %MCU_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
  store i32 1, i32* %MCU_height, align 8, !tbaa !17
  %MCU_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
  store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
  %MCU_sample_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 16
  store i32 8, i32* %MCU_sample_width, align 8, !tbaa !19
  %last_col_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 17
  store i32 1, i32* %last_col_width, align 4, !tbaa !20
  %v_samp_factor = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 3
  %4 = load i32, i32* %v_samp_factor, align 4, !tbaa !21
  %rem = urem i32 %3, %4
  %cmp2 = icmp eq i32 %rem, 0
  %spec.select = select i1 %cmp2, i32 %4, i32 %rem
  %last_row_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 18
  store i32 %spec.select, i32* %last_row_height, align 8, !tbaa !22
  %blocks_in_MCU = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 45
  store i32 1, i32* %blocks_in_MCU, align 8, !tbaa !23
  %arrayidx5 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 46, i64 0
  store i32 0, i32* %arrayidx5, align 4, !tbaa !24
  br label %if.end80

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 4, i32* %arrayidx17, align 4, !tbaa !29
Attempting Group:
  store i32 24, i32* %msg_code, align 8, !tbaa !26
  store i32 %0, i32* %arrayidx13, align 4, !tbaa !29
Creating Node
  store i32 24, i32* %msg_code, align 8, !tbaa !26
  store i32 %0, i32* %arrayidx13, align 4, !tbaa !29
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 24
  %0 = load i32, i32* %comps_in_scan, align 4, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 24
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 5
  %arrayidx13 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 5
  %arrayidx13 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 24, i32* %msg_code, align 8, !tbaa !26
}
ScheduleNode: {
  store i32 %0, i32* %arrayidx13, align 4, !tbaa !29
}
ScheduleNode: {
  store i32 24, i32* %msg_code, align 8, !tbaa !26
}
Count: 1
Start:   store i32 24, i32* %msg_code, align 8, !tbaa !26
Processing:   store i32 24, i32* %msg_code, align 8, !tbaa !26
Count: 1
Found:   store i32 24, i32* %msg_code, align 8, !tbaa !26
ScheduleNode: {
  store i32 %0, i32* %arrayidx13, align 4, !tbaa !29
}
Non-memory:   %arrayidx13 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %0, i32* %arrayidx13, align 4, !tbaa !29
Count: 1
Found:   store i32 %0, i32* %arrayidx13, align 4, !tbaa !29
I:   %7 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !25
Last:   br label %if.end19
Schedulable: 1
Loop Rolling: per_scan_setup
Generating tree
Generating MATCH
Match: 
  store i32 24, i32* %msg_code, align 8, !tbaa !26
  store i32 %0, i32* %arrayidx13, align 4, !tbaa !29
Generating ALTSEQ
Values:
i32 24
  %0 = load i32, i32* %comps_in_scan, align 4, !tbaa !2
Generated Version 4:
  %30 = icmp eq i8 %29, 0
  %31 = select i1 %30, i32 24, i32 %0
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 5
  %arrayidx13 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %6, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %32 = select i1 %30, i32* %msg_code, i32* %arrayidx13
Operands done!
Generated:   store i32 %31, i32* %32, align 1
Gen:   store i32 %31, i32* %32, align 1
Graph code generated!
Root:
  store i32 24, i32* %msg_code, align 8, !tbaa !26
  store i32 %0, i32* %arrayidx13, align 4, !tbaa !29
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 24, %0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx13", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; per_scan_setup
Trying AGAIN
Trying AGAIN
  %.pre-phi = phi %struct.jpeg_common_struct* [ %.pre, %if.else.if.end19_crit_edge ], [ %10, %if.then10 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
  store i32 %conv27, i32* %MCU_rows_in_scan28, align 4, !tbaa !15
  store i32 0, i32* %blocks_in_MCU29, align 8, !tbaa !23
Attempting Group:
  %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
  %call26 = tail call i64 @jdiv_round_up(i64 %conv23, i64 %conv25) #3
Creating Node
  store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
  store i32 %conv27, i32* %MCU_rows_in_scan28, align 4, !tbaa !15
  store i32 0, i32* %blocks_in_MCU29, align 8, !tbaa !23
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %conv21 = trunc i64 %call to i32
  %conv27 = trunc i64 %call26 to i32
i32 0
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %conv21 = trunc i64 %call to i32
Mismatching
Creating Node
  %MCUs_per_row22 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 43
  %MCU_rows_in_scan28 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 44
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 45
Match: 0
3 x 3
Final Match: 0
  %MCUs_per_row22 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 43
  %MCU_rows_in_scan28 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 44
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 45
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %MCUs_per_row22 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 43
Mismatching
ScheduleNode: {
  store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
}
ScheduleNode: {
  store i32 %conv27, i32* %MCU_rows_in_scan28, align 4, !tbaa !15
}
ScheduleNode: {
  store i32 0, i32* %blocks_in_MCU29, align 8, !tbaa !23
}
ScheduleNode: {
  store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
}
Count: 1
Start:   store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
Processing:   store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
Count: 1
Found:   store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
ScheduleNode: {
  store i32 %conv27, i32* %MCU_rows_in_scan28, align 4, !tbaa !15
}
Non-memory:   %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
Processing:   %13 = load i32, i32* %image_height, align 4, !tbaa !33
Count: 1
Not found:   %13 = load i32, i32* %image_height, align 4, !tbaa !33
Read/Write memory
I:   %13 = load i32, i32* %image_height, align 4, !tbaa !33
Last:   br label %for.cond
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


if.end19:                                         ; preds = %if.else.if.end19_crit_edge, %if.then10
  %.pre-phi = phi %struct.jpeg_common_struct* [ %.pre, %if.else.if.end19_crit_edge ], [ %10, %if.then10 ]
  %image_width = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %11 = load i32, i32* %image_width, align 8, !tbaa !31
  %conv = zext i32 %11 to i64
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %12 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !32
  %mul = shl nsw i32 %12, 3
  %conv20 = sext i32 %mul to i64
  %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
  %conv21 = trunc i64 %call to i32
  %MCUs_per_row22 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 43
  store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
  %13 = load i32, i32* %image_height, align 4, !tbaa !33
  %conv23 = zext i32 %13 to i64
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
  %14 = load i32, i32* %max_v_samp_factor, align 4, !tbaa !34
  %mul24 = shl nsw i32 %14, 3
  %conv25 = sext i32 %mul24 to i64
  %call26 = tail call i64 @jdiv_round_up(i64 %conv23, i64 %conv25) #3
  %conv27 = trunc i64 %call26 to i32
  %MCU_rows_in_scan28 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 44
  store i32 %conv27, i32* %MCU_rows_in_scan28, align 4, !tbaa !15
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 45
  store i32 0, i32* %blocks_in_MCU29, align 8, !tbaa !23
  %err68 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 0
  br label %for.cond

Trying AGAIN
Trying AGAIN
Trying AGAIN
Creating Node
  %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
  %call26 = tail call i64 @jdiv_round_up(i64 %conv23, i64 %conv25) #3
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv = zext i32 %11 to i64
  %conv23 = zext i32 %13 to i64
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %11 = load i32, i32* %image_width, align 8, !tbaa !31
  %13 = load i32, i32* %image_height, align 4, !tbaa !33
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %image_width = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
Match: 0
2 x 2
Final Match: 0
  %image_width = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %image_width = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
Alt Seq
Creating Node
  %conv20 = sext i32 %mul to i64
  %conv25 = sext i32 %mul24 to i64
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %mul = shl nsw i32 %12, 3
  %mul24 = shl nsw i32 %14, 3
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %12 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !32
  %14 = load i32, i32* %max_v_samp_factor, align 4, !tbaa !34
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
Match: 0
2 x 2
Final Match: 0
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
Alt Seq
Creating Node
i32 3
i32 3
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
Function: jdiv_round_up
Function: jdiv_round_up
Match: 1
1 x 2
Final Match: 1
All the Same
ScheduleNode: {
  %11 = load i32, i32* %image_width, align 8, !tbaa !31
  %12 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !32
}
ScheduleNode: {
  %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
}
ScheduleNode: {
  %14 = load i32, i32* %max_v_samp_factor, align 4, !tbaa !34
  %13 = load i32, i32* %image_height, align 4, !tbaa !33
}
ScheduleNode: {
  %call26 = tail call i64 @jdiv_round_up(i64 %conv23, i64 %conv25) #3
}
ScheduleNode: {
  %11 = load i32, i32* %image_width, align 8, !tbaa !31
  %12 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !32
}
Count: 2
Start:   %11 = load i32, i32* %image_width, align 8, !tbaa !31
Processing:   %11 = load i32, i32* %image_width, align 8, !tbaa !31
Count: 2
Found:   %11 = load i32, i32* %image_width, align 8, !tbaa !31
Non-memory:   %conv = zext i32 %11 to i64
Non-memory:   %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
Processing:   %12 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !32
Count: 1
Found:   %12 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !32
ScheduleNode: {
  %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
}
Non-memory:   %mul = shl nsw i32 %12, 3
Non-memory:   %conv20 = sext i32 %mul to i64
Processing:   %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
Count: 1
Found:   %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
ScheduleNode: {
  %14 = load i32, i32* %max_v_samp_factor, align 4, !tbaa !34
  %13 = load i32, i32* %image_height, align 4, !tbaa !33
}
Non-memory:   %conv21 = trunc i64 %call to i32
Non-memory:   %MCUs_per_row22 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 43
Processing:   store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
Count: 2
Not found:   store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
Read/Write memory
I:   store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
Last:   br label %for.cond
Schedulable: 0
digraph VTree {
0 [label="call: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %image_width, %image_height", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="shl", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %max_h_samp_factor, %max_v_samp_factor", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="3", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="func: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
9->0 
2->1 
3->2 
5->4 
6->5 
8->5 
7->6 
10 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->10
11 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->11
}


if.end19:                                         ; preds = %if.else.if.end19_crit_edge, %if.then10
  %.pre-phi = phi %struct.jpeg_common_struct* [ %.pre, %if.else.if.end19_crit_edge ], [ %10, %if.then10 ]
  %image_width = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 6
  %11 = load i32, i32* %image_width, align 8, !tbaa !31
  %conv = zext i32 %11 to i64
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 38
  %12 = load i32, i32* %max_h_samp_factor, align 8, !tbaa !32
  %mul = shl nsw i32 %12, 3
  %conv20 = sext i32 %mul to i64
  %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
  %conv21 = trunc i64 %call to i32
  %MCUs_per_row22 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 43
  store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
  %13 = load i32, i32* %image_height, align 4, !tbaa !33
  %conv23 = zext i32 %13 to i64
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 39
  %14 = load i32, i32* %max_v_samp_factor, align 4, !tbaa !34
  %mul24 = shl nsw i32 %14, 3
  %conv25 = sext i32 %mul24 to i64
  %call26 = tail call i64 @jdiv_round_up(i64 %conv23, i64 %conv25) #3
  %conv27 = trunc i64 %call26 to i32
  %MCU_rows_in_scan28 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 44
  store i32 %conv27, i32* %MCU_rows_in_scan28, align 4, !tbaa !15
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 45
  store i32 0, i32* %blocks_in_MCU29, align 8, !tbaa !23
  %err68 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 0
  br label %for.cond

  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.end19 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul40 = mul nsw i32 %19, %18
looking for reduction
  %mul43 = shl nsw i32 %18, 3
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %18, i32* %MCU_width35, align 4, !tbaa !16
  store i32 %19, i32* %MCU_height37, align 8, !tbaa !17
  store i32 %mul40, i32* %MCU_blocks41, align 4, !tbaa !18
  store i32 %mul43, i32* %MCU_sample_width44, align 8, !tbaa !19
  store i32 %spec.select169, i32* %last_col_width53, align 4, !tbaa !20
  store i32 %tmp.2, i32* %last_row_height62, align 8, !tbaa !22
Creating Node
  store i32 %18, i32* %MCU_width35, align 4, !tbaa !16
  store i32 %19, i32* %MCU_height37, align 8, !tbaa !17
  store i32 %mul40, i32* %MCU_blocks41, align 4, !tbaa !18
  store i32 %mul43, i32* %MCU_sample_width44, align 8, !tbaa !19
  store i32 %spec.select169, i32* %last_col_width53, align 4, !tbaa !20
  store i32 %tmp.2, i32* %last_row_height62, align 8, !tbaa !22
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
  %18 = load i32, i32* %h_samp_factor, align 8, !tbaa !35
  %19 = load i32, i32* %v_samp_factor36, align 4, !tbaa !21
  %mul40 = mul nsw i32 %19, %18
  %mul43 = shl nsw i32 %18, 3
  %spec.select169 = select i1 %cmp48, i32 %18, i32 %rem47
  %tmp.2 = select i1 %cmp57, i32 %19, i32 %rem56
Match: 0
6 x 6
Final Match: 0
GEPSeq2
BinOP?
  %18 = load i32, i32* %h_samp_factor, align 8, !tbaa !35
BinOp Seq
Creating Node
  %18 = load i32, i32* %h_samp_factor, align 8, !tbaa !35
  %19 = load i32, i32* %v_samp_factor36, align 4, !tbaa !21
  %19 = load i32, i32* %v_samp_factor36, align 4, !tbaa !21
  %mul43 = shl nsw i32 %18, 3
  %spec.select169 = select i1 %cmp48, i32 %18, i32 %rem47
  %tmp.2 = select i1 %cmp57, i32 %19, i32 %rem56
Match: 0
5 x 6
Final Match: 0
GEPSeq2
BinOP?
  %18 = load i32, i32* %h_samp_factor, align 8, !tbaa !35
Mismatching
Creating Node
i32 1
i32 1
  %18 = load i32, i32* %h_samp_factor, align 8, !tbaa !35
i32 1
i32 1
i32 1
Match: 0
2 x 6
Final Match: 0
GEPSeq2
BinOP?
i32 1
Mismatching
Creating Node
  %MCU_width35 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 13
  %MCU_height37 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 14
  %MCU_blocks41 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 15
  %MCU_sample_width44 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 16
  %last_col_width53 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 17
  %last_row_height62 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 18
Match: 0
6 x 6
Final Match: 0
  %MCU_width35 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 13
  %MCU_height37 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 14
  %MCU_blocks41 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 15
  %MCU_sample_width44 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 16
  %last_col_width53 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 17
  %last_row_height62 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 18
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %MCU_width35 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 13
Mismatching
ScheduleNode: {
  store i32 %18, i32* %MCU_width35, align 4, !tbaa !16
}
ScheduleNode: {
  store i32 %19, i32* %MCU_height37, align 8, !tbaa !17
}
ScheduleNode: {
  store i32 %mul40, i32* %MCU_blocks41, align 4, !tbaa !18
}
ScheduleNode: {
  store i32 %mul43, i32* %MCU_sample_width44, align 8, !tbaa !19
}
ScheduleNode: {
  store i32 %spec.select169, i32* %last_col_width53, align 4, !tbaa !20
}
ScheduleNode: {
  store i32 %tmp.2, i32* %last_row_height62, align 8, !tbaa !22
}
ScheduleNode: {
  store i32 %18, i32* %MCU_width35, align 4, !tbaa !16
}
Count: 1
Start:   store i32 %18, i32* %MCU_width35, align 4, !tbaa !16
Processing:   store i32 %18, i32* %MCU_width35, align 4, !tbaa !16
Count: 1
Found:   store i32 %18, i32* %MCU_width35, align 4, !tbaa !16
ScheduleNode: {
  store i32 %19, i32* %MCU_height37, align 8, !tbaa !17
}
Non-memory:   %v_samp_factor36 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 3
Processing:   %19 = load i32, i32* %v_samp_factor36, align 4, !tbaa !21
Count: 1
Not found:   %19 = load i32, i32* %v_samp_factor36, align 4, !tbaa !21
Read/Write memory
I:   %19 = load i32, i32* %v_samp_factor36, align 4, !tbaa !21
Last:   br i1 %cmp65, label %if.then67, label %if.end72
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mul seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
4 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
4->0 
2->1 
3->1 
5 [label="add", style="filled" , fillcolor="#f2eb5c", shape=box];
1->5
}


for.body:                                         ; preds = %for.cond
  %arrayidx34 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 42, i64 %indvars.iv
  %17 = load %struct.jpeg_component_info*, %struct.jpeg_component_info** %arrayidx34, align 8, !tbaa !10
  %h_samp_factor = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 2
  %18 = load i32, i32* %h_samp_factor, align 8, !tbaa !35
  %MCU_width35 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 13
  store i32 %18, i32* %MCU_width35, align 4, !tbaa !16
  %v_samp_factor36 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 3
  %19 = load i32, i32* %v_samp_factor36, align 4, !tbaa !21
  %MCU_height37 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 14
  store i32 %19, i32* %MCU_height37, align 8, !tbaa !17
  %mul40 = mul nsw i32 %19, %18
  %MCU_blocks41 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 15
  store i32 %mul40, i32* %MCU_blocks41, align 4, !tbaa !18
  %mul43 = shl nsw i32 %18, 3
  %MCU_sample_width44 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 16
  store i32 %mul43, i32* %MCU_sample_width44, align 8, !tbaa !19
  %width_in_blocks45 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 7
  %20 = load i32, i32* %width_in_blocks45, align 4, !tbaa !11
  %rem47 = urem i32 %20, %18
  %cmp48 = icmp eq i32 %rem47, 0
  %spec.select169 = select i1 %cmp48, i32 %18, i32 %rem47
  %last_col_width53 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 17
  store i32 %spec.select169, i32* %last_col_width53, align 4, !tbaa !20
  %height_in_blocks54 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 8
  %21 = load i32, i32* %height_in_blocks54, align 8, !tbaa !14
  %rem56 = urem i32 %21, %19
  %cmp57 = icmp eq i32 %rem56, 0
  %tmp.2 = select i1 %cmp57, i32 %19, i32 %rem56
  %last_row_height62 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %17, i64 0, i32 18
  store i32 %tmp.2, i32* %last_row_height62, align 8, !tbaa !22
  %22 = load i32, i32* %blocks_in_MCU29, align 8, !tbaa !23
  %add = add nsw i32 %22, %mul40
  %cmp65 = icmp sgt i32 %add, 10
  br i1 %cmp65, label %if.then67, label %if.end72

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
Attempting Group:
  store i32 11, i32* %msg_code69, align 8, !tbaa !26
  %mcublks.0 = phi i32 [ %mul40, %if.end72 ], [ %dec, %while.body ]
looking for reduction
looking for reduction
  %inc = add nsw i32 %26, 1
looking for reduction
Attempting Group:
  store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !23
  store i32 %25, i32* %arrayidx78, align 4, !tbaa !24
Creating Node
  store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !23
  store i32 %25, i32* %arrayidx78, align 4, !tbaa !24
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %inc = add nsw i32 %26, 1
  %25 = trunc i64 %indvars.iv to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %inc = add nsw i32 %26, 1
BinOp Seq
Creating Node
  %26 = load i32, i32* %blocks_in_MCU29, align 8, !tbaa !23
  %25 = trunc i64 %indvars.iv to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %26 = load i32, i32* %blocks_in_MCU29, align 8, !tbaa !23
Alt Seq
Creating Node
i32 1
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 45
  %arrayidx78 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 46, i64 %idxprom77
Match: 0
2 x 2
Final Match: 0
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 45
  %arrayidx78 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 46, i64 %idxprom77
GEPSeq2
BinOP?
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 45
Alt Seq
ScheduleNode: {
  store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !23
}
ScheduleNode: {
  store i32 %25, i32* %arrayidx78, align 4, !tbaa !24
}
ScheduleNode: {
  store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !23
}
Count: 1
Start:   %inc = add nsw i32 %26, 1
Non-memory:   %inc = add nsw i32 %26, 1
Processing:   store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !23
Count: 1
Found:   store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !23
ScheduleNode: {
  store i32 %25, i32* %arrayidx78, align 4, !tbaa !24
}
Non-memory:   %idxprom77 = sext i32 %26 to i64
Non-memory:   %arrayidx78 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 46, i64 %idxprom77
Processing:   store i32 %25, i32* %arrayidx78, align 4, !tbaa !24
Count: 1
Found:   store i32 %25, i32* %arrayidx78, align 4, !tbaa !24
I:   br label %while.cond, !llvm.loop !36
Last:   br label %while.cond, !llvm.loop !36
Schedulable: 1
Loop Rolling: per_scan_setup
Generating tree
Generating MATCH
Match: 
  store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !23
  store i32 %25, i32* %arrayidx78, align 4, !tbaa !24
Generating BINOP
Generating ALTSEQ
Values:
  %26 = load i32, i32* %blocks_in_MCU29, align 8, !tbaa !23
  %25 = trunc i64 %indvars.iv to i32
Generated Version 4:
  %30 = icmp eq i8 %29, 0
  %31 = select i1 %30, i32 %26, i32 %25
Generating INTSEQ
Gen:   %34 = add i32 %33, 1
Closing BINOP
Gen:   %35 = add nsw i32 %31, %34
Generating ALTSEQ
Values:
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 45
  %arrayidx78 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 46, i64 %idxprom77
Generated Version 4:
  %36 = select i1 %30, i32* %blocks_in_MCU29, i32* %arrayidx78
Operands done!
Generated:   store i32 %35, i32* %36, align 1
Gen:   store i32 %35, i32* %36, align 1
Graph code generated!
Root:
  store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !23
  store i32 %25, i32* %arrayidx78, align 4, !tbaa !24
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %26, %25", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="1..0, -1", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %blocks_in_MCU29, %arrayidx78", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
}

Gains: 6 - 12 = -6; Width: 2; Unprofitable; per_scan_setup
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
Attempting Group:
  store i32 %conv91, i32* %restart_interval, align 8, !tbaa !40
looking for reduction
Done Loop Roller: 0/2
Optimizing: prepare_for_pass
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* nonnull %cinfo) #3
Attempting Group:
  tail call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* nonnull %cinfo) #3
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %call_pass_startup, align 8, !tbaa !37
looking for reduction
Attempting Group:
  store i32 1, i32* %call_pass_startup13, align 8, !tbaa !37
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* nonnull %cinfo) #3
Attempting Group:
  tail call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* nonnull %cinfo) #3
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %call_pass_startup27, align 8, !tbaa !37
looking for reduction
looking for reduction
  %inc = add nsw i32 %30, 1
Attempting Group:
  store i32 2, i32* %pass_type, align 8, !tbaa !10
  store i32 %inc, i32* %pass_number, align 4, !tbaa !41
Creating Node
  store i32 2, i32* %pass_type, align 8, !tbaa !10
  store i32 %inc, i32* %pass_number, align 4, !tbaa !41
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 2
  %inc = add nsw i32 %30, 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 2
BinOp Seq
Creating Node
i32 2
  %30 = load i32, i32* %pass_number, align 4, !tbaa !41
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 2
Alt Seq
Creating Node
i32 0
i32 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Int Seq
Creating Node
  %pass_type = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 1
  %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
Match: 0
2 x 2
Final Match: 0
  %pass_type = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 1
  %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
GEPSeq2
%struct.my_comp_master = type { %struct.jpeg_comp_master, i32, i32, i32, i32 }
BinOP?
  %pass_type = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 1
Alt Seq
ScheduleNode: {
  store i32 2, i32* %pass_type, align 8, !tbaa !10
}
ScheduleNode: {
  store i32 %inc, i32* %pass_number, align 4, !tbaa !41
}
ScheduleNode: {
  store i32 2, i32* %pass_type, align 8, !tbaa !10
}
Count: 1
Start:   store i32 2, i32* %pass_type, align 8, !tbaa !10
Processing:   store i32 2, i32* %pass_type, align 8, !tbaa !10
Count: 1
Found:   store i32 2, i32* %pass_type, align 8, !tbaa !10
ScheduleNode: {
  store i32 %inc, i32* %pass_number, align 4, !tbaa !41
}
Non-memory:   %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
Processing:   %30 = load i32, i32* %pass_number, align 4, !tbaa !41
Count: 1
Not found:   %30 = load i32, i32* %pass_number, align 4, !tbaa !41
Read/Write memory
I:   %30 = load i32, i32* %pass_number, align 4, !tbaa !41
Last:   br label %sw.bb30
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: 2, %30", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %pass_type, %pass_number", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
}


if.end28:                                         ; preds = %lor.lhs.false18
  store i32 2, i32* %pass_type, align 8, !tbaa !10
  %pass_number = getelementptr inbounds %struct.my_comp_master, %struct.my_comp_master* %1, i64 0, i32 2
  %30 = load i32, i32* %pass_number, align 4, !tbaa !41
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %pass_number, align 4, !tbaa !41
  br label %sw.bb30

Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @per_scan_setup(%struct.jpeg_compress_struct* nonnull %cinfo) #3
Attempting Group:
  tail call fastcc void @select_scan_parameters(%struct.jpeg_compress_struct* nonnull %cinfo) #3
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %call_pass_startup45, align 8, !tbaa !37
looking for reduction
looking for reduction
Attempting Group:
  store i32 47, i32* %msg_code, align 8, !tbaa !48
looking for reduction
looking for reduction
Attempting Group:
  store i32 %conv, i32* %is_last_pass, align 4, !tbaa !52
looking for reduction
looking for reduction
Attempting Group:
  store i32 %45, i32* %completed_passes, align 8, !tbaa !54
  store i32 %46, i32* %total_passes58, align 4, !tbaa !56
Creating Node
  store i32 %45, i32* %completed_passes, align 8, !tbaa !54
  store i32 %46, i32* %total_passes58, align 4, !tbaa !56
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %45 = load i32, i32* %pass_number47, align 4, !tbaa !41
  %46 = load i32, i32* %total_passes48, align 8, !tbaa !33
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %45 = load i32, i32* %pass_number47, align 4, !tbaa !41
Alt Seq
Creating Node
  %completed_passes = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %47, i64 0, i32 3
  %total_passes58 = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %47, i64 0, i32 4
Match: 0
2 x 2
Final Match: 0
  %completed_passes = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %47, i64 0, i32 3
  %total_passes58 = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %47, i64 0, i32 4
GEPSeq2
%struct.jpeg_progress_mgr = type { {}*, i64, i64, i32, i32 }
BinOP?
  %completed_passes = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %47, i64 0, i32 3
Alt Seq
ScheduleNode: {
  store i32 %45, i32* %completed_passes, align 8, !tbaa !54
}
ScheduleNode: {
  store i32 %46, i32* %total_passes58, align 4, !tbaa !56
}
ScheduleNode: {
  store i32 %45, i32* %completed_passes, align 8, !tbaa !54
}
Count: 1
Start:   store i32 %45, i32* %completed_passes, align 8, !tbaa !54
Processing:   store i32 %45, i32* %completed_passes, align 8, !tbaa !54
Count: 1
Found:   store i32 %45, i32* %completed_passes, align 8, !tbaa !54
ScheduleNode: {
  store i32 %46, i32* %total_passes58, align 4, !tbaa !56
}
Non-memory:   %total_passes58 = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %47, i64 0, i32 4
Processing:   store i32 %46, i32* %total_passes58, align 4, !tbaa !56
Count: 1
Found:   store i32 %46, i32* %total_passes58, align 4, !tbaa !56
I:   br label %if.end59
Last:   br label %if.end59
Schedulable: 1
Loop Rolling: prepare_for_pass
Generating tree
Generating MATCH
Match: 
  store i32 %45, i32* %completed_passes, align 8, !tbaa !54
  store i32 %46, i32* %total_passes58, align 4, !tbaa !56
Generating ALTSEQ
Values:
  %45 = load i32, i32* %pass_number47, align 4, !tbaa !41
  %46 = load i32, i32* %total_passes48, align 8, !tbaa !33
Generated Version 4:
  %49 = icmp eq i8 %48, 0
  %50 = select i1 %49, i32 %45, i32 %46
Generating ALTSEQ
Values:
  %completed_passes = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %47, i64 0, i32 3
  %total_passes58 = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %47, i64 0, i32 4
Generated Version 4:
  %51 = select i1 %49, i32* %completed_passes, i32* %total_passes58
Operands done!
Generated:   store i32 %50, i32* %51, align 1
Gen:   store i32 %50, i32* %51, align 1
Graph code generated!
Root:
  store i32 %45, i32* %completed_passes, align 8, !tbaa !54
  store i32 %46, i32* %total_passes58, align 4, !tbaa !56
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: %45, %46", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %completed_passes, %total_passes58", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; prepare_for_pass
Trying AGAIN
Trying AGAIN
looking for reduction
Done Loop Roller: 0/1
Optimizing: pass_startup
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %call_pass_startup, align 8, !tbaa !10
Done Loop Roller: 0/0
Nothing found in: pass_startup
Optimizing: finish_pass_master
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 2, i32* %pass_type, align 8, !tbaa !13
looking for reduction
  %inc = add nsw i32 %6, 1
Attempting Group:
  store i32 %inc, i32* %scan_number, align 4, !tbaa !17
looking for reduction
Attempting Group:
  store i32 2, i32* %pass_type, align 8, !tbaa !13
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %pass_type, align 8, !tbaa !13
looking for reduction
  %inc12 = add nsw i32 %8, 1
Attempting Group:
  store i32 %inc12, i32* %scan_number11, align 4, !tbaa !17
looking for reduction
  %inc13 = add nsw i32 %9, 1
looking for reduction
Attempting Group:
  store i32 %inc13, i32* %pass_number, align 4, !tbaa !18
Done Loop Roller: 0/0
Nothing found in: finish_pass_master
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jcphuff.c -o src/jcphuff.o   -mllvm -reroll-loops=3
Optimizing: jinit_phuff_encoder
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_compress_struct*, i32)* @start_pass_phuff, void (%struct.jpeg_compress_struct*, i32)** %start_pass, align 8, !tbaa !14
Attempting Group:
  store i8* %call, i8** %3, align 8, !tbaa !13
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store %struct.c_derived_tbl* null, %struct.c_derived_tbl** %arrayidx, align 8, !tbaa !17
looking for reduction
looking for reduction
Attempting Group:
  store i8* null, i8** %6, align 8, !tbaa !20
Done Loop Roller: 0/0
Nothing found in: jinit_phuff_encoder
Optimizing: start_pass_phuff
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store %struct.jpeg_compress_struct* %cinfo, %struct.jpeg_compress_struct** %cinfo2, align 8, !tbaa !10
looking for reduction
looking for reduction
Attempting Group:
  store i32 (%struct.jpeg_compress_struct*, [64 x i16]**)* @encode_mcu_DC_first, i32 (%struct.jpeg_compress_struct*, [64 x i16]**)** %encode_mcu, align 8, !tbaa !17
looking for reduction
Attempting Group:
  store i32 (%struct.jpeg_compress_struct*, [64 x i16]**)* @encode_mcu_AC_first, i32 (%struct.jpeg_compress_struct*, [64 x i16]**)** %encode_mcu8, align 8, !tbaa !17
looking for reduction
looking for reduction
Attempting Group:
  store i32 (%struct.jpeg_compress_struct*, [64 x i16]**)* @encode_mcu_DC_refine, i32 (%struct.jpeg_compress_struct*, [64 x i16]**)** %encode_mcu13, align 8, !tbaa !17
looking for reduction
looking for reduction
Attempting Group:
  store i32 (%struct.jpeg_compress_struct*, [64 x i16]**)* @encode_mcu_AC_refine, i32 (%struct.jpeg_compress_struct*, [64 x i16]**)** %encode_mcu16, align 8, !tbaa !17
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %call, i8** %bit_buffer, align 8, !tbaa !18
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_compress_struct*)* @finish_pass_gather_phuff, void (%struct.jpeg_compress_struct*)** %finish_pass27, align 8, !tbaa !22
looking for reduction
Attempting Group:
  store void (%struct.jpeg_compress_struct*)* @finish_pass_phuff, void (%struct.jpeg_compress_struct*)** %finish_pass31, align 8, !tbaa !22
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.end32 ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %arrayidx36, align 4, !tbaa !25
looking for reduction
looking for reduction
looking for reduction
  %or.cond118 = or i1 %tobool24, %cmp51
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 49, i32* %msg_code, align 8, !tbaa !29
  store i32 %13, i32* %arrayidx56, align 4, !tbaa !31
Creating Node
  store i32 49, i32* %msg_code, align 8, !tbaa !29
  store i32 %13, i32* %arrayidx56, align 4, !tbaa !31
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 49
  %13 = load i32, i32* %dc_tbl_no, align 4, !tbaa !26
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 49
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 5
  %arrayidx56 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 5
  %arrayidx56 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 49, i32* %msg_code, align 8, !tbaa !29
}
ScheduleNode: {
  store i32 %13, i32* %arrayidx56, align 4, !tbaa !31
}
ScheduleNode: {
  store i32 49, i32* %msg_code, align 8, !tbaa !29
}
Count: 1
Start:   store i32 49, i32* %msg_code, align 8, !tbaa !29
Processing:   store i32 49, i32* %msg_code, align 8, !tbaa !29
Count: 1
Found:   store i32 49, i32* %msg_code, align 8, !tbaa !29
ScheduleNode: {
  store i32 %13, i32* %arrayidx56, align 4, !tbaa !31
}
Non-memory:   %arrayidx56 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %13, i32* %arrayidx56, align 4, !tbaa !31
Count: 1
Found:   store i32 %13, i32* %arrayidx56, align 4, !tbaa !31
I:   %17 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err74, align 8, !tbaa !28
Last:   br label %if.end83
Schedulable: 1
Loop Rolling: start_pass_phuff
Generating tree
Generating MATCH
Match: 
  store i32 49, i32* %msg_code, align 8, !tbaa !29
  store i32 %13, i32* %arrayidx56, align 4, !tbaa !31
Generating ALTSEQ
Values:
i32 49
  %13 = load i32, i32* %dc_tbl_no, align 4, !tbaa !26
Generated Version 4:
  %35 = icmp eq i8 %34, 0
  %36 = select i1 %35, i32 49, i32 %13
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 5
  %arrayidx56 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %16, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %37 = select i1 %35, i32* %msg_code, i32* %arrayidx56
Operands done!
Generated:   store i32 %36, i32* %37, align 1
Gen:   store i32 %36, i32* %37, align 1
Graph code generated!
Root:
  store i32 49, i32* %msg_code, align 8, !tbaa !29
  store i32 %13, i32* %arrayidx56, align 4, !tbaa !31
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 49, %13", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx56", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; start_pass_phuff
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
Attempting Group:
  store i32 %19, i32* %ac_tbl_no60, align 8, !tbaa !34
looking for reduction
  %or.cond120 = or i1 %tobool24, %cmp69
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 49, i32* %msg_code75, align 8, !tbaa !29
  store i32 %19, i32* %arrayidx79, align 4, !tbaa !31
Creating Node
  store i32 49, i32* %msg_code75, align 8, !tbaa !29
  store i32 %19, i32* %arrayidx79, align 4, !tbaa !31
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 49
  %19 = load i32, i32* %ac_tbl_no, align 8, !tbaa !33
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 49
Alt Seq
Creating Node
  %msg_code75 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %22, i64 0, i32 5
  %arrayidx79 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %22, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code75 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %22, i64 0, i32 5
  %arrayidx79 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %22, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code75 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %22, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 49, i32* %msg_code75, align 8, !tbaa !29
}
ScheduleNode: {
  store i32 %19, i32* %arrayidx79, align 4, !tbaa !31
}
ScheduleNode: {
  store i32 49, i32* %msg_code75, align 8, !tbaa !29
}
Count: 1
Start:   store i32 49, i32* %msg_code75, align 8, !tbaa !29
Processing:   store i32 49, i32* %msg_code75, align 8, !tbaa !29
Count: 1
Found:   store i32 49, i32* %msg_code75, align 8, !tbaa !29
ScheduleNode: {
  store i32 %19, i32* %arrayidx79, align 4, !tbaa !31
}
Non-memory:   %arrayidx79 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %22, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %19, i32* %arrayidx79, align 4, !tbaa !31
Count: 1
Found:   store i32 %19, i32* %arrayidx79, align 4, !tbaa !31
I:   %23 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err74, align 8, !tbaa !28
Last:   br label %if.end83
Schedulable: 1
Loop Rolling: start_pass_phuff
Generating tree
Generating MATCH
Match: 
  store i32 49, i32* %msg_code75, align 8, !tbaa !29
  store i32 %19, i32* %arrayidx79, align 4, !tbaa !31
Generating ALTSEQ
Values:
i32 49
  %19 = load i32, i32* %ac_tbl_no, align 8, !tbaa !33
Generated Version 4:
  %35 = icmp eq i8 %34, 0
  %36 = select i1 %35, i32 49, i32 %19
Generating ALTSEQ
Values:
  %msg_code75 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %22, i64 0, i32 5
  %arrayidx79 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %22, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %37 = select i1 %35, i32* %msg_code75, i32* %arrayidx79
Operands done!
Generated:   store i32 %36, i32* %37, align 1
Gen:   store i32 %36, i32* %37, align 1
Graph code generated!
Root:
  store i32 49, i32* %msg_code75, align 8, !tbaa !29
  store i32 %19, i32* %arrayidx79, align 4, !tbaa !31
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 49, %19", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code75, %arrayidx79", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; start_pass_phuff
Trying AGAIN
Trying AGAIN
  %tbl.0 = phi i32 [ %13, %if.then54 ], [ %13, %lor.lhs.false48 ], [ %19, %if.then73 ], [ %19, %lor.lhs.false66 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %call93, i8** %29, align 8, !tbaa !24
  %30 = phi i8* [ %call93, %if.then90 ], [ %26, %if.then85.if.end97_crit_edge ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 1 dereferenceable(2056) %30, i8 0, i64 2056, i1 false)
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call void @jpeg_make_c_derived_tbl(%struct.jpeg_compress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %31, %struct.c_derived_tbl** nonnull %arrayidx108) #5
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call void @jpeg_make_c_derived_tbl(%struct.jpeg_compress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %32, %struct.c_derived_tbl** nonnull %arrayidx115) #5
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %EOBRUN, align 4, !tbaa !37
  store i32 0, i32* %BE, align 8, !tbaa !38
  store i32 0, i32* %put_bits, align 8, !tbaa !40
  store i32 %33, i32* %restarts_to_go, align 8, !tbaa !42
  store i32 0, i32* %next_restart_num, align 4, !tbaa !43
Creating Node
  store i32 0, i32* %EOBRUN, align 4, !tbaa !37
  store i32 0, i32* %BE, align 8, !tbaa !38
  store i32 0, i32* %put_bits, align 8, !tbaa !40
  store i32 %33, i32* %restarts_to_go, align 8, !tbaa !42
  store i32 0, i32* %next_restart_num, align 4, !tbaa !43
Match: 1
5 x 5
Final Match: 1
Matching
Creating Node
i32 0
i32 0
i32 0
  %33 = load i32, i32* %restart_interval, align 8, !tbaa !41
i32 0
Match: 0
2 x 5
Final Match: 0
GEPSeq2
BinOP?
i32 0
Mismatching
Creating Node
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 9
  %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 10
  %put_bits = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 5
  %restarts_to_go = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 12
  %next_restart_num = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
Match: 0
5 x 5
Final Match: 0
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 9
  %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 10
  %put_bits = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 5
  %restarts_to_go = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 12
  %next_restart_num = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
GEPSeq2
%struct.phuff_entropy_encoder = type { %struct.jpeg_entropy_encoder, i32, i8*, i64, i64, i32, %struct.jpeg_compress_struct*, [4 x i32], i32, i32, i32, i8*, i32, i32, [4 x %struct.c_derived_tbl*], [4 x i64*] }
BinOP?
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 9
Mismatching
ScheduleNode: {
  store i32 0, i32* %EOBRUN, align 4, !tbaa !37
}
ScheduleNode: {
  store i32 0, i32* %BE, align 8, !tbaa !38
}
ScheduleNode: {
  store i32 0, i32* %put_bits, align 8, !tbaa !40
}
ScheduleNode: {
  store i32 %33, i32* %restarts_to_go, align 8, !tbaa !42
}
ScheduleNode: {
  store i32 0, i32* %next_restart_num, align 4, !tbaa !43
}
ScheduleNode: {
  store i32 0, i32* %EOBRUN, align 4, !tbaa !37
}
Count: 1
Start:   store i32 0, i32* %EOBRUN, align 4, !tbaa !37
Processing:   store i32 0, i32* %EOBRUN, align 4, !tbaa !37
Count: 1
Found:   store i32 0, i32* %EOBRUN, align 4, !tbaa !37
ScheduleNode: {
  store i32 0, i32* %BE, align 8, !tbaa !38
}
Non-memory:   %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 10
Processing:   store i32 0, i32* %BE, align 8, !tbaa !38
Count: 1
Found:   store i32 0, i32* %BE, align 8, !tbaa !38
ScheduleNode: {
  store i32 0, i32* %put_bits, align 8, !tbaa !40
}
Non-memory:   %put_buffer = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 4
Processing:   store i64 0, i64* %put_buffer, align 8, !tbaa !39
Count: 1
Not found:   store i64 0, i64* %put_buffer, align 8, !tbaa !39
Read/Write memory
I:   store i64 0, i64* %put_buffer, align 8, !tbaa !39
Last:   ret void
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


for.end:                                          ; preds = %for.cond
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 9
  store i32 0, i32* %EOBRUN, align 4, !tbaa !37
  %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 10
  store i32 0, i32* %BE, align 8, !tbaa !38
  %put_buffer = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 4
  store i64 0, i64* %put_buffer, align 8, !tbaa !39
  %put_bits = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 5
  store i32 0, i32* %put_bits, align 8, !tbaa !40
  %restart_interval = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 29
  %33 = load i32, i32* %restart_interval, align 8, !tbaa !41
  %restarts_to_go = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 12
  store i32 %33, i32* %restarts_to_go, align 8, !tbaa !42
  %next_restart_num = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
  store i32 0, i32* %next_restart_num, align 4, !tbaa !43
  ret void

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Done Loop Roller: 0/2
Optimizing: dump_buffer
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 22, i32* %msg_code, align 8, !tbaa !17
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %7, i8** %next_output_byte7, align 8, !tbaa !21
Done Loop Roller: 0/0
Nothing found in: dump_buffer
Optimizing: emit_bits
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 39, i32* %msg_code, align 8, !tbaa !15
looking for reduction
  %put_bits.0 = phi i32 [ %add, %if.end7 ], [ %sub34, %if.end32 ]
  %put_buffer.0 = phi i64 [ %or, %if.end7 ], [ %shl33, %if.end32 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %dec = add i64 %9, -1
looking for reduction
Attempting Group:
  store i8 %conv16, i8* %8, align 1, !tbaa !21
Attempting Group:
  store i8* %incdec.ptr, i8** %next_output_byte, align 8, !tbaa !20
looking for reduction
Attempting Group:
  tail call fastcc void @dump_buffer(%struct.phuff_entropy_encoder* nonnull %entropy) #6
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %dec27 = add i64 %12, -1
looking for reduction
Attempting Group:
  store i8 0, i8* %11, align 1, !tbaa !21
Attempting Group:
  store i8* %incdec.ptr25, i8** %next_output_byte, align 8, !tbaa !20
looking for reduction
Attempting Group:
  tail call fastcc void @dump_buffer(%struct.phuff_entropy_encoder* nonnull %entropy) #6
  %put_bits.0.lcssa = phi i32 [ %put_bits.0, %while.cond ]
  %put_buffer.0.lcssa = phi i64 [ %put_buffer.0, %while.cond ]
looking for reduction
looking for reduction
Attempting Group:
  store i64 %put_buffer.0.lcssa, i64* %put_buffer11, align 8, !tbaa !19
looking for reduction
Done Loop Roller: 0/0
Nothing found in: emit_bits
Optimizing: emit_symbol
looking for reduction
looking for reduction
  %inc = add nsw i64 %2, 1
Attempting Group:
  store i64 %inc, i64* %arrayidx2, align 8, !tbaa !11
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_bits(%struct.phuff_entropy_encoder* nonnull %entropy, i32 %4, i32 %conv) #5
looking for reduction
Done Loop Roller: 0/0
Nothing found in: emit_symbol
Optimizing: emit_buffered_bits
looking for reduction
  %bufstart.addr.0 = phi i8* [ %incdec.ptr, %while.body ], [ %bufstart, %while.cond.preheader ]
  %nbits.addr.0 = phi i32 [ %dec, %while.body ], [ %nbits, %while.cond.preheader ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_bits(%struct.phuff_entropy_encoder* %entropy, i32 %conv, i32 1) #5
looking for reduction
Done Loop Roller: 0/0
Nothing found in: emit_buffered_bits
Optimizing: emit_eobrun
looking for reduction
  %temp.0 = phi i32 [ %shr, %while.cond ], [ %0, %while.cond.preheader ]
  %shr = ashr i32 %temp.0, 1
looking for reduction
  %shr = ashr i32 %temp.0, 1
  %nbits.0 = phi i32 [ %inc, %while.cond ], [ 0, %while.cond.preheader ]
  %inc = add nuw nsw i32 %nbits.0, 1
looking for reduction
  %inc = add nuw nsw i32 %nbits.0, 1
looking for reduction
  %nbits.0.lcssa = phi i32 [ %nbits.0, %while.cond ]
looking for reduction
looking for reduction
looking for reduction
  %shl = shl i32 %nbits.0.lcssa, 4
looking for reduction
Attempting Group:
  tail call fastcc void @emit_symbol(%struct.phuff_entropy_encoder* %entropy, i32 %1, i32 %shl) #5
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_bits(%struct.phuff_entropy_encoder* nonnull %entropy, i32 %2, i32 %nbits.0.lcssa) #5
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %EOBRUN, align 4, !tbaa !2
  store i32 0, i32* %BE, align 8, !tbaa !14
Attempting Group:
  tail call fastcc void @emit_buffered_bits(%struct.phuff_entropy_encoder* nonnull %entropy, i8* %3, i32 %4) #5
Creating Node
  store i32 0, i32* %EOBRUN, align 4, !tbaa !2
  store i32 0, i32* %BE, align 8, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 0
i32 0
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 9
  %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 10
Match: 0
2 x 2
Final Match: 0
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 9
  %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 10
GEPSeq2
%struct.phuff_entropy_encoder = type { %struct.jpeg_entropy_encoder, i32, i8*, i64, i64, i32, %struct.jpeg_compress_struct*, [4 x i32], i32, i32, i32, i8*, i32, i32, [4 x %struct.c_derived_tbl*], [4 x i64*] }
BinOP?
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 9
Alt Seq
ScheduleNode: {
  store i32 0, i32* %EOBRUN, align 4, !tbaa !2
}
ScheduleNode: {
  store i32 0, i32* %BE, align 8, !tbaa !14
}
ScheduleNode: {
  store i32 0, i32* %EOBRUN, align 4, !tbaa !2
}
Count: 1
Start:   store i32 0, i32* %EOBRUN, align 4, !tbaa !2
Processing:   store i32 0, i32* %EOBRUN, align 4, !tbaa !2
Count: 1
Found:   store i32 0, i32* %EOBRUN, align 4, !tbaa !2
ScheduleNode: {
  store i32 0, i32* %BE, align 8, !tbaa !14
}
Non-memory:   %bit_buffer = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 11
Processing:   %3 = load i8*, i8** %bit_buffer, align 8, !tbaa !13
Count: 1
Not found:   %3 = load i8*, i8** %bit_buffer, align 8, !tbaa !13
Read/Write memory
I:   %3 = load i8*, i8** %bit_buffer, align 8, !tbaa !13
Last:   br label %if.end7
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %EOBRUN, %BE", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}


if.end:                                           ; preds = %if.then3, %while.end
  store i32 0, i32* %EOBRUN, align 4, !tbaa !2
  %bit_buffer = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 11
  %3 = load i8*, i8** %bit_buffer, align 8, !tbaa !13
  %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 10
  %4 = load i32, i32* %BE, align 8, !tbaa !14
  tail call fastcc void @emit_buffered_bits(%struct.phuff_entropy_encoder* nonnull %entropy, i8* %3, i32 %4) #5
  store i32 0, i32* %BE, align 8, !tbaa !14
  br label %if.end7

Trying AGAIN
Trying AGAIN
looking for reduction
Done Loop Roller: 0/0
Nothing found in: emit_eobrun
Optimizing: flush_bits
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i64 0, i64* %put_buffer, align 8, !tbaa !2
Attempting Group:
  tail call fastcc void @emit_bits(%struct.phuff_entropy_encoder* %entropy, i32 127, i32 7) #5
Done Loop Roller: 0/0
Nothing found in: flush_bits
Optimizing: emit_restart
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_eobrun(%struct.phuff_entropy_encoder* %entropy) #5
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %dec = add i64 %2, -1
looking for reduction
Attempting Group:
  store i8 -1, i8* %1, align 1, !tbaa !11
Attempting Group:
  store i8* %incdec.ptr, i8** %next_output_byte, align 8, !tbaa !10
Attempting Group:
  tail call fastcc void @flush_bits(%struct.phuff_entropy_encoder* nonnull %entropy) #5
looking for reduction
Attempting Group:
  tail call fastcc void @dump_buffer(%struct.phuff_entropy_encoder* nonnull %entropy) #5
looking for reduction
looking for reduction
  %conv = add i8 %3, -48
looking for reduction
  %dec5 = add i64 %5, -1
looking for reduction
Attempting Group:
  store i8 %conv, i8* %4, align 1, !tbaa !11
Attempting Group:
  store i8* %incdec.ptr3, i8** %next_output_byte, align 8, !tbaa !10
looking for reduction
Attempting Group:
  tail call fastcc void @dump_buffer(%struct.phuff_entropy_encoder* nonnull %entropy) #5
looking for reduction
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.body ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %arrayidx, align 4, !tbaa !19
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %EOBRUN, align 4, !tbaa !22
  store i32 0, i32* %BE, align 8, !tbaa !23
Creating Node
  store i32 0, i32* %EOBRUN, align 4, !tbaa !22
  store i32 0, i32* %BE, align 8, !tbaa !23
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 0
i32 0
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 9
  %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 10
Match: 0
2 x 2
Final Match: 0
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 9
  %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 10
GEPSeq2
%struct.phuff_entropy_encoder = type { %struct.jpeg_entropy_encoder, i32, i8*, i64, i64, i32, %struct.jpeg_compress_struct*, [4 x i32], i32, i32, i32, i8*, i32, i32, [4 x %struct.c_derived_tbl*], [4 x i64*] }
BinOP?
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 9
Alt Seq
ScheduleNode: {
  store i32 0, i32* %EOBRUN, align 4, !tbaa !22
}
ScheduleNode: {
  store i32 0, i32* %BE, align 8, !tbaa !23
}
ScheduleNode: {
  store i32 0, i32* %EOBRUN, align 4, !tbaa !22
}
Count: 1
Start:   store i32 0, i32* %EOBRUN, align 4, !tbaa !22
Processing:   store i32 0, i32* %EOBRUN, align 4, !tbaa !22
Count: 1
Found:   store i32 0, i32* %EOBRUN, align 4, !tbaa !22
ScheduleNode: {
  store i32 0, i32* %BE, align 8, !tbaa !23
}
Non-memory:   %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 10
Processing:   store i32 0, i32* %BE, align 8, !tbaa !23
Count: 1
Found:   store i32 0, i32* %BE, align 8, !tbaa !23
I:   br label %if.end17
Last:   br label %if.end17
Schedulable: 1
Loop Rolling: emit_restart
Generating tree
Generating MATCH
Match: 
  store i32 0, i32* %EOBRUN, align 4, !tbaa !22
  store i32 0, i32* %BE, align 8, !tbaa !23
Generating IDENTICAL
Generating ALTSEQ
Values:
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 9
  %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %entropy, i64 0, i32 10
Generated Version 4:
  %11 = icmp eq i8 %10, 0
  %12 = select i1 %11, i32* %EOBRUN, i32* %BE
Operands done!
Generated:   store i32 0, i32* %12, align 1
Gen:   store i32 0, i32* %12, align 1
Graph code generated!
Root:
  store i32 0, i32* %EOBRUN, align 4, !tbaa !22
  store i32 0, i32* %BE, align 8, !tbaa !23
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %EOBRUN, %BE", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 5 = -1; Width: 2; Unprofitable; emit_restart
Trying AGAIN
Trying AGAIN
looking for reduction
Done Loop Roller: 0/1
Optimizing: encode_mcu_DC_first
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %4, i8** %next_output_byte3, align 8, !tbaa !15
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_restart(%struct.phuff_entropy_encoder* nonnull %1, i32 %8) #5
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.end7 ]
looking for reduction
looking for reduction
  %shr = ashr i32 %conv, %2
Attempting Group:
  store i32 %shr, i32* %arrayidx15, align 4, !tbaa !25
  %nbits.0 = phi i32 [ 0, %for.body ], [ %inc, %while.body ]
  %temp.1 = phi i32 [ %temp.0, %for.body ], [ %shr25, %while.body ]
looking for reduction
  %nbits.0.lcssa = phi i32 [ %nbits.0, %while.cond ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_symbol(%struct.phuff_entropy_encoder* %1, i32 %16, i32 %nbits.0.lcssa) #5
looking for reduction
looking for reduction
  %temp2.0 = add nsw i32 %sub.lobit, %sub
looking for reduction
Attempting Group:
  tail call fastcc void @emit_bits(%struct.phuff_entropy_encoder* %1, i32 %temp2.0, i32 %nbits.0.lcssa) #5
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %17, i8** %next_output_byte32, align 8, !tbaa !12
looking for reduction
looking for reduction
looking for reduction
  %and = and i32 %inc46, 7
Attempting Group:
  store i32 %20, i32* %restarts_to_go39, align 8, !tbaa !21
  store i32 %and, i32* %next_restart_num45, align 4, !tbaa !22
Creating Node
  store i32 %20, i32* %restarts_to_go39, align 8, !tbaa !21
  store i32 %and, i32* %next_restart_num45, align 4, !tbaa !22
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %20 = load i32, i32* %restart_interval, align 8, !tbaa !20
  %and = and i32 %inc46, 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %20 = load i32, i32* %restart_interval, align 8, !tbaa !20
BinOp Seq
Creating Node
  %20 = load i32, i32* %restart_interval, align 8, !tbaa !20
  %inc46 = add nsw i32 %22, 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %20 = load i32, i32* %restart_interval, align 8, !tbaa !20
BinOp Seq
Creating Node
  %20 = load i32, i32* %restart_interval, align 8, !tbaa !20
  %22 = load i32, i32* %next_restart_num45, align 4, !tbaa !22
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %20 = load i32, i32* %restart_interval, align 8, !tbaa !20
Alt Seq
Creating Node
i32 0
i32 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Int Seq
Creating Node
i32 1
i32 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
  %restarts_to_go39 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 12
  %next_restart_num45 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
Match: 0
2 x 2
Final Match: 0
  %restarts_to_go39 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 12
  %next_restart_num45 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
GEPSeq2
%struct.phuff_entropy_encoder = type { %struct.jpeg_entropy_encoder, i32, i8*, i64, i64, i32, %struct.jpeg_compress_struct*, [4 x i32], i32, i32, i32, i8*, i32, i32, [4 x %struct.c_derived_tbl*], [4 x i64*] }
BinOP?
  %restarts_to_go39 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 12
Alt Seq
ScheduleNode: {
  store i32 %20, i32* %restarts_to_go39, align 8, !tbaa !21
}
ScheduleNode: {
  store i32 %and, i32* %next_restart_num45, align 4, !tbaa !22
}
ScheduleNode: {
  store i32 %20, i32* %restarts_to_go39, align 8, !tbaa !21
}
Count: 1
Start:   store i32 %20, i32* %restarts_to_go39, align 8, !tbaa !21
Processing:   store i32 %20, i32* %restarts_to_go39, align 8, !tbaa !21
Count: 1
Found:   store i32 %20, i32* %restarts_to_go39, align 8, !tbaa !21
ScheduleNode: {
  store i32 %and, i32* %next_restart_num45, align 4, !tbaa !22
}
Non-memory:   %next_restart_num45 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
Processing:   %22 = load i32, i32* %next_restart_num45, align 4, !tbaa !22
Count: 1
Not found:   %22 = load i32, i32* %next_restart_num45, align 4, !tbaa !22
Read/Write memory
I:   %22 = load i32, i32* %next_restart_num45, align 4, !tbaa !22
Last:   br label %if.end48
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="and seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %20, %22", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="1..7, 6", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="alt: %restarts_to_go39, %next_restart_num45", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
6->0 
2->1 
5->1 
3->2 
4->2 
}


if.then42:                                        ; preds = %if.then38
  store i32 %20, i32* %restarts_to_go39, align 8, !tbaa !21
  %next_restart_num45 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
  %22 = load i32, i32* %next_restart_num45, align 4, !tbaa !22
  %inc46 = add nsw i32 %22, 1
  %and = and i32 %inc46, 7
  store i32 %and, i32* %next_restart_num45, align 4, !tbaa !22
  br label %if.end48

Trying AGAIN
Trying AGAIN
  %23 = phi i32 [ %20, %if.then42 ], [ %21, %if.then38 ]
looking for reduction
  %dec50 = add i32 %23, -1
Attempting Group:
  store i32 %dec50, i32* %restarts_to_go39, align 8, !tbaa !21
looking for reduction
Done Loop Roller: 0/0
Nothing found in: encode_mcu_DC_first
Optimizing: encode_mcu_AC_first
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %5, i8** %next_output_byte4, align 8, !tbaa !16
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_restart(%struct.phuff_entropy_encoder* nonnull %1, i32 %9) #5
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ %12, %if.end8 ]
  %r.0 = phi i32 [ %r.2, %for.inc ], [ 0, %if.end8 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_eobrun(%struct.phuff_entropy_encoder* nonnull %1) #5
  %r.1 = phi i32 [ %r.0, %if.end30 ], [ %sub33, %while.body ]
looking for reduction
  %r.1.lcssa = phi i32 [ %r.1, %while.cond ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_symbol(%struct.phuff_entropy_encoder* nonnull %1, i32 %17, i32 240) #5
  %nbits.0 = phi i32 [ %inc38, %while.cond34 ], [ 1, %while.cond34.preheader ]
  %inc38 = add nuw nsw i32 %nbits.0, 1
looking for reduction
  %inc38 = add nuw nsw i32 %nbits.0, 1
  %temp.1 = phi i32 [ %shr35, %while.cond34 ], [ %temp.0, %while.cond34.preheader ]
  %shr35 = ashr i32 %temp.1, 1
looking for reduction
  %shr35 = ashr i32 %temp.1, 1
looking for reduction
  %nbits.0.lcssa = phi i32 [ %nbits.0, %while.cond34 ]
looking for reduction
looking for reduction
looking for reduction
  %add = add nsw i32 %nbits.0.lcssa, %shl
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_bits(%struct.phuff_entropy_encoder* %1, i32 %temp2.0, i32 %nbits.0.lcssa) #5
Attempting Group:
  tail call fastcc void @emit_symbol(%struct.phuff_entropy_encoder* %1, i32 %18, i32 %add) #5
  %r.2 = phi i32 [ %inc, %if.then15 ], [ %inc25, %if.then24 ], [ 0, %while.end39 ]
  %r.0.lcssa = phi i32 [ %r.0, %for.cond ]
looking for reduction
looking for reduction
  %inc46 = add i32 %19, 1
looking for reduction
Attempting Group:
  store i32 %inc46, i32* %EOBRUN, align 4, !tbaa !28
looking for reduction
Attempting Group:
  tail call fastcc void @emit_eobrun(%struct.phuff_entropy_encoder* nonnull %1) #5
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %20, i8** %next_output_byte55, align 8, !tbaa !13
looking for reduction
looking for reduction
looking for reduction
  %and = and i32 %inc69, 7
Attempting Group:
  store i32 %23, i32* %restarts_to_go62, align 8, !tbaa !22
  store i32 %and, i32* %next_restart_num68, align 4, !tbaa !23
Creating Node
  store i32 %23, i32* %restarts_to_go62, align 8, !tbaa !22
  store i32 %and, i32* %next_restart_num68, align 4, !tbaa !23
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %23 = load i32, i32* %restart_interval, align 8, !tbaa !21
  %and = and i32 %inc69, 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %23 = load i32, i32* %restart_interval, align 8, !tbaa !21
BinOp Seq
Creating Node
  %23 = load i32, i32* %restart_interval, align 8, !tbaa !21
  %inc69 = add nsw i32 %25, 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %23 = load i32, i32* %restart_interval, align 8, !tbaa !21
BinOp Seq
Creating Node
  %23 = load i32, i32* %restart_interval, align 8, !tbaa !21
  %25 = load i32, i32* %next_restart_num68, align 4, !tbaa !23
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %23 = load i32, i32* %restart_interval, align 8, !tbaa !21
Alt Seq
Creating Node
i32 0
i32 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Int Seq
Creating Node
i32 1
i32 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
  %restarts_to_go62 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 12
  %next_restart_num68 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
Match: 0
2 x 2
Final Match: 0
  %restarts_to_go62 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 12
  %next_restart_num68 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
GEPSeq2
%struct.phuff_entropy_encoder = type { %struct.jpeg_entropy_encoder, i32, i8*, i64, i64, i32, %struct.jpeg_compress_struct*, [4 x i32], i32, i32, i32, i8*, i32, i32, [4 x %struct.c_derived_tbl*], [4 x i64*] }
BinOP?
  %restarts_to_go62 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 12
Alt Seq
ScheduleNode: {
  store i32 %23, i32* %restarts_to_go62, align 8, !tbaa !22
}
ScheduleNode: {
  store i32 %and, i32* %next_restart_num68, align 4, !tbaa !23
}
ScheduleNode: {
  store i32 %23, i32* %restarts_to_go62, align 8, !tbaa !22
}
Count: 1
Start:   store i32 %23, i32* %restarts_to_go62, align 8, !tbaa !22
Processing:   store i32 %23, i32* %restarts_to_go62, align 8, !tbaa !22
Count: 1
Found:   store i32 %23, i32* %restarts_to_go62, align 8, !tbaa !22
ScheduleNode: {
  store i32 %and, i32* %next_restart_num68, align 4, !tbaa !23
}
Non-memory:   %next_restart_num68 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
Processing:   %25 = load i32, i32* %next_restart_num68, align 4, !tbaa !23
Count: 1
Not found:   %25 = load i32, i32* %next_restart_num68, align 4, !tbaa !23
Read/Write memory
I:   %25 = load i32, i32* %next_restart_num68, align 4, !tbaa !23
Last:   br label %if.end71
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="and seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %23, %25", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="1..7, 6", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="alt: %restarts_to_go62, %next_restart_num68", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
6->0 
2->1 
5->1 
3->2 
4->2 
}


if.then65:                                        ; preds = %if.then61
  store i32 %23, i32* %restarts_to_go62, align 8, !tbaa !22
  %next_restart_num68 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
  %25 = load i32, i32* %next_restart_num68, align 4, !tbaa !23
  %inc69 = add nsw i32 %25, 1
  %and = and i32 %inc69, 7
  store i32 %and, i32* %next_restart_num68, align 4, !tbaa !23
  br label %if.end71

Trying AGAIN
Trying AGAIN
  %26 = phi i32 [ %23, %if.then65 ], [ %24, %if.then61 ]
looking for reduction
  %dec = add i32 %26, -1
Attempting Group:
  store i32 %dec, i32* %restarts_to_go62, align 8, !tbaa !22
looking for reduction
Done Loop Roller: 0/0
Nothing found in: encode_mcu_AC_first
Optimizing: encode_mcu_DC_refine
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %4, i8** %next_output_byte3, align 8, !tbaa !15
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_restart(%struct.phuff_entropy_encoder* nonnull %1, i32 %8) #5
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %if.end7 ]
looking for reduction
looking for reduction
looking for reduction
  %shr = ashr i32 %conv, %2
looking for reduction
Attempting Group:
  tail call fastcc void @emit_bits(%struct.phuff_entropy_encoder* %1, i32 %shr, i32 1) #5
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %13, i8** %next_output_byte12, align 8, !tbaa !12
looking for reduction
looking for reduction
looking for reduction
  %and = and i32 %inc26, 7
Attempting Group:
  store i32 %16, i32* %restarts_to_go19, align 8, !tbaa !21
  store i32 %and, i32* %next_restart_num25, align 4, !tbaa !22
Creating Node
  store i32 %16, i32* %restarts_to_go19, align 8, !tbaa !21
  store i32 %and, i32* %next_restart_num25, align 4, !tbaa !22
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %16 = load i32, i32* %restart_interval, align 8, !tbaa !20
  %and = and i32 %inc26, 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %16 = load i32, i32* %restart_interval, align 8, !tbaa !20
BinOp Seq
Creating Node
  %16 = load i32, i32* %restart_interval, align 8, !tbaa !20
  %inc26 = add nsw i32 %18, 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %16 = load i32, i32* %restart_interval, align 8, !tbaa !20
BinOp Seq
Creating Node
  %16 = load i32, i32* %restart_interval, align 8, !tbaa !20
  %18 = load i32, i32* %next_restart_num25, align 4, !tbaa !22
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %16 = load i32, i32* %restart_interval, align 8, !tbaa !20
Alt Seq
Creating Node
i32 0
i32 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Int Seq
Creating Node
i32 1
i32 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
  %restarts_to_go19 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 12
  %next_restart_num25 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
Match: 0
2 x 2
Final Match: 0
  %restarts_to_go19 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 12
  %next_restart_num25 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
GEPSeq2
%struct.phuff_entropy_encoder = type { %struct.jpeg_entropy_encoder, i32, i8*, i64, i64, i32, %struct.jpeg_compress_struct*, [4 x i32], i32, i32, i32, i8*, i32, i32, [4 x %struct.c_derived_tbl*], [4 x i64*] }
BinOP?
  %restarts_to_go19 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 12
Alt Seq
ScheduleNode: {
  store i32 %16, i32* %restarts_to_go19, align 8, !tbaa !21
}
ScheduleNode: {
  store i32 %and, i32* %next_restart_num25, align 4, !tbaa !22
}
ScheduleNode: {
  store i32 %16, i32* %restarts_to_go19, align 8, !tbaa !21
}
Count: 1
Start:   store i32 %16, i32* %restarts_to_go19, align 8, !tbaa !21
Processing:   store i32 %16, i32* %restarts_to_go19, align 8, !tbaa !21
Count: 1
Found:   store i32 %16, i32* %restarts_to_go19, align 8, !tbaa !21
ScheduleNode: {
  store i32 %and, i32* %next_restart_num25, align 4, !tbaa !22
}
Non-memory:   %next_restart_num25 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
Processing:   %18 = load i32, i32* %next_restart_num25, align 4, !tbaa !22
Count: 1
Not found:   %18 = load i32, i32* %next_restart_num25, align 4, !tbaa !22
Read/Write memory
I:   %18 = load i32, i32* %next_restart_num25, align 4, !tbaa !22
Last:   br label %if.end28
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="and seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %16, %18", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="1..7, 6", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="alt: %restarts_to_go19, %next_restart_num25", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
6->0 
2->1 
5->1 
3->2 
4->2 
}


if.then22:                                        ; preds = %if.then18
  store i32 %16, i32* %restarts_to_go19, align 8, !tbaa !21
  %next_restart_num25 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 13
  %18 = load i32, i32* %next_restart_num25, align 4, !tbaa !22
  %inc26 = add nsw i32 %18, 1
  %and = and i32 %inc26, 7
  store i32 %and, i32* %next_restart_num25, align 4, !tbaa !22
  br label %if.end28

Trying AGAIN
Trying AGAIN
  %19 = phi i32 [ %16, %if.then22 ], [ %17, %if.then18 ]
looking for reduction
  %dec = add i32 %19, -1
Attempting Group:
  store i32 %dec, i32* %restarts_to_go19, align 8, !tbaa !21
looking for reduction
Done Loop Roller: 0/0
Nothing found in: encode_mcu_DC_refine
Optimizing: encode_mcu_AC_refine
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %6, i8** %next_output_byte4, align 8, !tbaa !16
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_restart(%struct.phuff_entropy_encoder* nonnull %1, i32 %10) #6
  %indvars.iv182 = phi i64 [ %indvars.iv.next183, %for.body ], [ %13, %if.end8 ]
  %EOB.0 = phi i32 [ %EOB.1, %for.body ], [ 0, %if.end8 ]
looking for reduction
looking for reduction
  %shr = lshr i32 %spec.select, %3
Attempting Group:
  store i32 %shr, i32* %arrayidx18, align 4, !tbaa !26
  %EOB.0.lcssa = phi i32 [ %EOB.0, %for.cond ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc58 ], [ %13, %for.end ]
  %BR_buffer.0 = phi i8* [ %BR_buffer.2, %for.inc58 ], [ %add.ptr, %for.end ]
  %BR.0 = phi i32 [ %BR.2, %for.inc58 ], [ 0, %for.end ]
  %r.0 = phi i32 [ %r.2, %for.inc58 ], [ 0, %for.end ]
looking for reduction
looking for reduction
  %BR_buffer.1 = phi i8* [ %24, %while.body ], [ %BR_buffer.0, %while.cond.preheader ]
  %BR.1 = phi i32 [ 0, %while.body ], [ %BR.0, %while.cond.preheader ]
  %r.1 = phi i32 [ %sub39, %while.body ], [ %r.0, %while.cond.preheader ]
looking for reduction
  %22 = and i1 %cmp37, %cmp35
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_buffered_bits(%struct.phuff_entropy_encoder* %1, i8* %BR_buffer.1, i32 %BR.1) #6
Attempting Group:
  tail call fastcc void @emit_eobrun(%struct.phuff_entropy_encoder* %1) #6
Attempting Group:
  tail call fastcc void @emit_symbol(%struct.phuff_entropy_encoder* %1, i32 %23, i32 240) #6
  %BR_buffer.1.lcssa = phi i8* [ %BR_buffer.1, %while.cond ]
  %BR.1.lcssa = phi i32 [ %BR.1, %while.cond ]
  %r.1.lcssa = phi i32 [ %r.1, %while.cond ]
looking for reduction
looking for reduction
  %conv44 = and i8 %25, 1
Attempting Group:
  store i8 %conv44, i8* %arrayidx47, align 1, !tbaa !34
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add = or i32 %shl, 1
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call fastcc void @emit_buffered_bits(%struct.phuff_entropy_encoder* %1, i8* %BR_buffer.1.lcssa, i32 %BR.1.lcssa) #6
Attempting Group:
  tail call fastcc void @emit_bits(%struct.phuff_entropy_encoder* %1, i32 %.not, i32 1) #6
Attempting Group:
  tail call fastcc void @emit_symbol(%struct.phuff_entropy_encoder* %1, i32 %26, i32 %add) #6
Attempting Group:
  tail call fastcc void @emit_eobrun(%struct.phuff_entropy_encoder* %1) #6
  %BR_buffer.2 = phi i8* [ %BR_buffer.0, %if.then32 ], [ %BR_buffer.1.lcssa, %if.then43 ], [ %31, %if.end48 ]
  %BR.2 = phi i32 [ %BR.0, %if.then32 ], [ %inc45, %if.then43 ], [ 0, %if.end48 ]
  %r.2 = phi i32 [ %inc33, %if.then32 ], [ %r.1.lcssa, %if.then43 ], [ 0, %if.end48 ]
  %BR.0.lcssa = phi i32 [ %BR.0, %for.cond24 ]
  %r.0.lcssa = phi i32 [ %r.0, %for.cond24 ]
looking for reduction
  %or.cond = or i1 %cmp63, %cmp61
looking for reduction
  %inc66 = add i32 %32, 1
looking for reduction
  %add68 = add i32 %33, %BR.0.lcssa
looking for reduction
  %or.cond181 = or i1 %cmp70, %cmp74
Attempting Group:
  store i32 %inc66, i32* %EOBRUN, align 4, !tbaa !36
  store i32 %add68, i32* %BE, align 8, !tbaa !31
Creating Node
  store i32 %inc66, i32* %EOBRUN, align 4, !tbaa !36
  store i32 %add68, i32* %BE, align 8, !tbaa !31
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %inc66 = add i32 %32, 1
  %add68 = add i32 %33, %BR.0.lcssa
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %32 = load i32, i32* %EOBRUN, align 4, !tbaa !36
  %33 = load i32, i32* %BE, align 8, !tbaa !31
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 9
  %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 10
Match: 0
2 x 2
Final Match: 0
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 9
  %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 10
GEPSeq2
%struct.phuff_entropy_encoder = type { %struct.jpeg_entropy_encoder, i32, i8*, i64, i64, i32, %struct.jpeg_compress_struct*, [4 x i32], i32, i32, i32, i8*, i32, i32, [4 x %struct.c_derived_tbl*], [4 x i64*] }
BinOP?
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 9
Alt Seq
Creating Node
i32 1
  %BR.0.lcssa = phi i32 [ %BR.0, %for.cond24 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Alt Seq
ScheduleNode: {
  %32 = load i32, i32* %EOBRUN, align 4, !tbaa !36
}
ScheduleNode: {
  store i32 %inc66, i32* %EOBRUN, align 4, !tbaa !36
}
ScheduleNode: {
  %33 = load i32, i32* %BE, align 8, !tbaa !31
}
ScheduleNode: {
  store i32 %add68, i32* %BE, align 8, !tbaa !31
}
ScheduleNode: {
  %32 = load i32, i32* %EOBRUN, align 4, !tbaa !36
}
Count: 1
Start:   %32 = load i32, i32* %EOBRUN, align 4, !tbaa !36
Processing:   %32 = load i32, i32* %EOBRUN, align 4, !tbaa !36
Count: 1
Found:   %32 = load i32, i32* %EOBRUN, align 4, !tbaa !36
ScheduleNode: {
  store i32 %inc66, i32* %EOBRUN, align 4, !tbaa !36
}
Non-memory:   %inc66 = add i32 %32, 1
Processing:   store i32 %inc66, i32* %EOBRUN, align 4, !tbaa !36
Count: 1
Found:   store i32 %inc66, i32* %EOBRUN, align 4, !tbaa !36
ScheduleNode: {
  %33 = load i32, i32* %BE, align 8, !tbaa !31
}
Processing:   %33 = load i32, i32* %BE, align 8, !tbaa !31
Count: 1
Found:   %33 = load i32, i32* %BE, align 8, !tbaa !31
ScheduleNode: {
  store i32 %add68, i32* %BE, align 8, !tbaa !31
}
Non-memory:   %add68 = add i32 %33, %BR.0.lcssa
Processing:   store i32 %add68, i32* %BE, align 8, !tbaa !31
Count: 1
Found:   store i32 %add68, i32* %BE, align 8, !tbaa !31
I:   %cmp70 = icmp eq i32 %inc66, 32767
Last:   br i1 %or.cond181, label %if.then76, label %if.end78
Schedulable: 1
Loop Rolling: encode_mcu_AC_refine
Generating tree
Generating MATCH
Match: 
  store i32 %inc66, i32* %EOBRUN, align 4, !tbaa !36
  store i32 %add68, i32* %BE, align 8, !tbaa !31
Generating MATCH
Match: 
  %inc66 = add i32 %32, 1
  %add68 = add i32 %33, %BR.0.lcssa
Generating MATCH
Match: 
  %32 = load i32, i32* %EOBRUN, align 4, !tbaa !36
  %33 = load i32, i32* %BE, align 8, !tbaa !31
Generating ALTSEQ
Values:
  %EOBRUN = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 9
  %BE = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %1, i64 0, i32 10
Generated Version 4:
  %42 = icmp eq i8 %41, 0
  %43 = select i1 %42, i32* %EOBRUN, i32* %BE
Operands done!
Generated:   %44 = load i32, i32* %43, align 1
Gen:   %44 = load i32, i32* %43, align 1
Generating ALTSEQ
Values:
i32 1
  %BR.0.lcssa = phi i32 [ %BR.0, %for.cond24 ]
Generated Version 4:
  %45 = select i1 %42, i32 1, i32 %BR.0.lcssa
Operands done!
Generated:   %46 = add i32 %44, %45
Found use: 0:   %cmp70 = icmp eq i32 %inc66, 32767
Found use: 1:   %cmp74 = icmp ugt i32 %add68, 937
Extracting:   %46 = add i32 %44, %45
Gen:   %47 = add i32 %45, %46
Operands done!
Generated:   store i32 %47, i32* %44, align 1
Gen:   store i32 %47, i32* %44, align 1
Graph code generated!
Root:
  store i32 %inc66, i32* %EOBRUN, align 4, !tbaa !36
  store i32 %add68, i32* %BE, align 8, !tbaa !31
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %EOBRUN, %BE", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: 1, %BR.0.lcssa", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
3->0 
2->1 
4->1 
3->2 
5 [label="icmp", style="filled" , fillcolor="#f2eb5c", shape=box];
1->5
6 [label="icmp", style="filled" , fillcolor="#f2eb5c", shape=box];
1->6
}

Gains: 11 - 24 = -13; Width: 2; Unprofitable; encode_mcu_AC_refine
Trying AGAIN
Trying AGAIN
looking for reduction
Attempting Group:
  tail call fastcc void @emit_eobrun(%struct.phuff_entropy_encoder* nonnull %2) #6
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %35, i8** %next_output_byte81, align 8, !tbaa !13
looking for reduction
looking for reduction
looking for reduction
  %and97 = and i32 %inc95, 7
Attempting Group:
  store i32 %38, i32* %restarts_to_go88, align 8, !tbaa !22
  store i32 %and97, i32* %next_restart_num94, align 4, !tbaa !23
Creating Node
  store i32 %38, i32* %restarts_to_go88, align 8, !tbaa !22
  store i32 %and97, i32* %next_restart_num94, align 4, !tbaa !23
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %38 = load i32, i32* %restart_interval, align 8, !tbaa !21
  %and97 = and i32 %inc95, 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %38 = load i32, i32* %restart_interval, align 8, !tbaa !21
BinOp Seq
Creating Node
  %38 = load i32, i32* %restart_interval, align 8, !tbaa !21
  %inc95 = add nsw i32 %40, 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %38 = load i32, i32* %restart_interval, align 8, !tbaa !21
BinOp Seq
Creating Node
  %38 = load i32, i32* %restart_interval, align 8, !tbaa !21
  %40 = load i32, i32* %next_restart_num94, align 4, !tbaa !23
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %38 = load i32, i32* %restart_interval, align 8, !tbaa !21
Alt Seq
Creating Node
i32 0
i32 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Int Seq
Creating Node
i32 1
i32 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
  %restarts_to_go88 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %2, i64 0, i32 12
  %next_restart_num94 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %2, i64 0, i32 13
Match: 0
2 x 2
Final Match: 0
  %restarts_to_go88 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %2, i64 0, i32 12
  %next_restart_num94 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %2, i64 0, i32 13
GEPSeq2
%struct.phuff_entropy_encoder = type { %struct.jpeg_entropy_encoder, i32, i8*, i64, i64, i32, %struct.jpeg_compress_struct*, [4 x i32], i32, i32, i32, i8*, i32, i32, [4 x %struct.c_derived_tbl*], [4 x i64*] }
BinOP?
  %restarts_to_go88 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %2, i64 0, i32 12
Alt Seq
ScheduleNode: {
  store i32 %38, i32* %restarts_to_go88, align 8, !tbaa !22
}
ScheduleNode: {
  store i32 %and97, i32* %next_restart_num94, align 4, !tbaa !23
}
ScheduleNode: {
  store i32 %38, i32* %restarts_to_go88, align 8, !tbaa !22
}
Count: 1
Start:   store i32 %38, i32* %restarts_to_go88, align 8, !tbaa !22
Processing:   store i32 %38, i32* %restarts_to_go88, align 8, !tbaa !22
Count: 1
Found:   store i32 %38, i32* %restarts_to_go88, align 8, !tbaa !22
ScheduleNode: {
  store i32 %and97, i32* %next_restart_num94, align 4, !tbaa !23
}
Non-memory:   %next_restart_num94 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %2, i64 0, i32 13
Processing:   %40 = load i32, i32* %next_restart_num94, align 4, !tbaa !23
Count: 1
Not found:   %40 = load i32, i32* %next_restart_num94, align 4, !tbaa !23
Read/Write memory
I:   %40 = load i32, i32* %next_restart_num94, align 4, !tbaa !23
Last:   br label %if.end98
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="and seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %38, %40", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="1..7, 6", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="alt: %restarts_to_go88, %next_restart_num94", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
6->0 
2->1 
5->1 
3->2 
4->2 
}


if.then91:                                        ; preds = %if.then87
  store i32 %38, i32* %restarts_to_go88, align 8, !tbaa !22
  %next_restart_num94 = getelementptr inbounds %struct.phuff_entropy_encoder, %struct.phuff_entropy_encoder* %2, i64 0, i32 13
  %40 = load i32, i32* %next_restart_num94, align 4, !tbaa !23
  %inc95 = add nsw i32 %40, 1
  %and97 = and i32 %inc95, 7
  store i32 %and97, i32* %next_restart_num94, align 4, !tbaa !23
  br label %if.end98

Trying AGAIN
Trying AGAIN
  %41 = phi i32 [ %38, %if.then91 ], [ %39, %if.then87 ]
looking for reduction
  %dec = add i32 %41, -1
Attempting Group:
  store i32 %dec, i32* %restarts_to_go88, align 8, !tbaa !22
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 0/1
Optimizing: finish_pass_gather_phuff
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 dereferenceable(16) %2, i8 0, i64 16, i1 false)
Attempting Group:
  tail call fastcc void @emit_eobrun(%struct.phuff_entropy_encoder* %1) #6
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
looking for reduction
looking for reduction
looking for reduction
  %tbl.0.in = phi i32* [ %dc_tbl_no, %if.end ], [ %ac_tbl_no, %if.else ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store %struct.JHUFF_TBL* %call, %struct.JHUFF_TBL** %htblptr.0, align 8, !tbaa !12
Attempting Group:
  %call = tail call %struct.JHUFF_TBL* @jpeg_alloc_huff_table(%struct.jpeg_common_struct* nonnull %4) #7
  %11 = phi %struct.JHUFF_TBL* [ %call, %if.then22 ], [ %10, %if.then11 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %arrayidx9, align 4, !tbaa !14
Attempting Group:
  tail call void @jpeg_gen_optimal_table(%struct.jpeg_compress_struct* nonnull %cinfo, %struct.JHUFF_TBL* %11, i64* %12) #7
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 0/0
Nothing found in: finish_pass_gather_phuff
Optimizing: finish_pass_phuff
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %5, i8** %next_output_byte7, align 8, !tbaa !11
Attempting Group:
  store i8* %3, i8** %next_output_byte2, align 8, !tbaa !14
Attempting Group:
  tail call fastcc void @flush_bits(%struct.phuff_entropy_encoder* %1) #5
Attempting Group:
  tail call fastcc void @emit_eobrun(%struct.phuff_entropy_encoder* %1) #5
Done Loop Roller: 0/0
Nothing found in: finish_pass_phuff
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jddctmgr.c -o src/jddctmgr.o   -mllvm -reroll-loops=3
Optimizing: jinit_inverse_dct
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*)* @start_pass, void (%struct.jpeg_decompress_struct*)** %start_pass2, align 8, !tbaa !14
Attempting Group:
  store i8* %call, i8** %3, align 8, !tbaa !13
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %incdec.ptr, %for.body ], [ %4, %entry ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 -1, i32* %arrayidx, align 4, !tbaa !21
Attempting Group:
  store i8* %call5, i8** %dct_table, align 8, !tbaa !19
Attempting Group:
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 1 dereferenceable(256) %call5, i8 0, i64 256, i1 false)
looking for reduction
Done Loop Roller: 0/0
Nothing found in: jinit_inverse_dct
Optimizing: start_pass
  %indvars.iv167 = phi i64 [ %indvars.iv.next168, %for.inc91 ], [ 0, %entry ]
  %method_ptr.0 = phi void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i16*, i8**, i32)* [ %method_ptr.1, %for.inc91 ], [ null, %entry ]
  %method.0 = phi i32 [ %method.1, %for.inc91 ], [ 0, %entry ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %incdec.ptr, %for.inc91 ], [ %2, %entry ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 47, i32* %msg_code, align 8, !tbaa !16
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 6, i32* %msg_code11, align 8, !tbaa !16
  store i32 %6, i32* %arrayidx, align 4, !tbaa !20
Creating Node
  store i32 6, i32* %msg_code11, align 8, !tbaa !16
  store i32 %6, i32* %arrayidx, align 4, !tbaa !20
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 6
  %6 = load i32, i32* %DCT_scaled_size, align 4, !tbaa !12
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 6
Alt Seq
Creating Node
  %msg_code11 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code11 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code11 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 6, i32* %msg_code11, align 8, !tbaa !16
}
ScheduleNode: {
  store i32 %6, i32* %arrayidx, align 4, !tbaa !20
}
ScheduleNode: {
  store i32 6, i32* %msg_code11, align 8, !tbaa !16
}
Count: 1
Start:   store i32 6, i32* %msg_code11, align 8, !tbaa !16
Processing:   store i32 6, i32* %msg_code11, align 8, !tbaa !16
Count: 1
Found:   store i32 6, i32* %msg_code11, align 8, !tbaa !16
ScheduleNode: {
  store i32 %6, i32* %arrayidx, align 4, !tbaa !20
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %6, i32* %arrayidx, align 4, !tbaa !20
Count: 1
Found:   store i32 %6, i32* %arrayidx, align 4, !tbaa !20
I:   %11 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !15
Last:   br label %sw.epilog17
Schedulable: 1
Loop Rolling: start_pass
Generating tree
Generating MATCH
Match: 
  store i32 6, i32* %msg_code11, align 8, !tbaa !16
  store i32 %6, i32* %arrayidx, align 4, !tbaa !20
Generating ALTSEQ
Values:
i32 6
  %6 = load i32, i32* %DCT_scaled_size, align 4, !tbaa !12
Generated Version 4:
  %32 = icmp eq i8 %31, 0
  %33 = select i1 %32, i32 6, i32 %6
Generating ALTSEQ
Values:
  %msg_code11 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %10, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %34 = select i1 %32, i32* %msg_code11, i32* %arrayidx
Operands done!
Generated:   store i32 %33, i32* %34, align 1
Gen:   store i32 %33, i32* %34, align 1
Graph code generated!
Root:
  store i32 6, i32* %msg_code11, align 8, !tbaa !16
  store i32 %6, i32* %arrayidx, align 4, !tbaa !20
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 6, %6", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code11, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; start_pass
Trying AGAIN
Trying AGAIN
  %method_ptr.1 = phi void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i16*, i8**, i32)* [ %method_ptr.0, %sw.default9 ], [ %method_ptr.0, %sw.default ], [ @jpeg_idct_float, %sw.bb7 ], [ @jpeg_idct_ifast, %sw.bb6 ], [ @jpeg_idct_4x4, %sw.bb3 ], [ @jpeg_idct_2x2, %sw.bb2 ], [ @jpeg_idct_1x1, %for.body ], [ @jpeg_idct_islow, %sw.bb4 ]
  %method.1 = phi i32 [ %method.0, %sw.default9 ], [ %method.0, %sw.default ], [ 2, %sw.bb7 ], [ 1, %sw.bb6 ], [ 0, %sw.bb3 ], [ 0, %sw.bb2 ], [ 0, %for.body ], [ 0, %sw.bb4 ]
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i16*, i8**, i32)* %method_ptr.1, void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i16*, i8**, i32)** %arrayidx18, align 8, !tbaa !21
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %method.1, i32* %arrayidx20, align 4, !tbaa !23
  %indvars.iv164 = phi i64 [ %indvars.iv.next165, %for.body31 ], [ 0, %sw.bb28 ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 %conv, i32* %arrayidx35, align 4, !tbaa !23
  %indvars.iv161 = phi i64 [ %indvars.iv.next162, %for.body41 ], [ 0, %sw.bb36 ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 %conv49, i32* %arrayidx51, align 4, !tbaa !23
  %indvars.iv158 = phi i64 [ %indvars.iv.next159, %for.inc82 ], [ 0, %sw.bb55 ]
  %i.2 = phi i64 [ %indvars.iv.lcssa, %for.inc82 ], [ 0, %sw.bb55 ]
looking for reduction
  %indvars.iv156 = phi i64 [ 0, %for.cond61.preheader ], [ %indvars.iv.next157, %for.body64 ]
  %indvars.iv = phi i64 [ %26, %for.cond61.preheader ], [ %indvars.iv.next, %for.body64 ]
looking for reduction
looking for reduction
Attempting Group:
  store float %conv75, float* %arrayidx77, align 4, !tbaa !31
  %indvars.iv.lcssa = phi i64 [ %indvars.iv, %for.cond61 ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 47, i32* %msg_code87, align 8, !tbaa !16
looking for reduction
Done Loop Roller: 0/1
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jdinput.c -o src/jdinput.o   -mllvm -reroll-loops=3
Optimizing: jinit_input_controller
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 (%struct.jpeg_decompress_struct*)* @consume_markers, i32 (%struct.jpeg_decompress_struct*)** %consume_input, align 8, !tbaa !14
Attempting Group:
  store i8* %call, i8** %3, align 8, !tbaa !13
Done Loop Roller: 0/0
Nothing found in: jinit_input_controller
Optimizing: initial_setup
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 40, i32* %msg_code, align 8, !tbaa !12
  store i32 65500, i32* %arrayidx, align 4, !tbaa !15
Creating Node
  store i32 40, i32* %msg_code, align 8, !tbaa !12
  store i32 65500, i32* %arrayidx, align 4, !tbaa !15
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 40
i32 65500
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 40
Int Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 40, i32* %msg_code, align 8, !tbaa !12
}
ScheduleNode: {
  store i32 65500, i32* %arrayidx, align 4, !tbaa !15
}
ScheduleNode: {
  store i32 40, i32* %msg_code, align 8, !tbaa !12
}
Count: 1
Start:   store i32 40, i32* %msg_code, align 8, !tbaa !12
Processing:   store i32 40, i32* %msg_code, align 8, !tbaa !12
Count: 1
Found:   store i32 40, i32* %msg_code, align 8, !tbaa !12
ScheduleNode: {
  store i32 65500, i32* %arrayidx, align 4, !tbaa !15
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 65500, i32* %arrayidx, align 4, !tbaa !15
Count: 1
Found:   store i32 65500, i32* %arrayidx, align 4, !tbaa !15
I:   %3 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !11
Last:   br label %if.end
Schedulable: 1
Loop Rolling: initial_setup
Generating tree
Generating MATCH
Match: 
  store i32 40, i32* %msg_code, align 8, !tbaa !12
  store i32 65500, i32* %arrayidx, align 4, !tbaa !15
Generating INTSEQ
Gen:   %55 = add i32 %54, 40
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %56 = icmp eq i8 %52, 0
  %57 = select i1 %56, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %55, i32* %57, align 1
Gen:   store i32 %55, i32* %57, align 1
Graph code generated!
Root:
  store i32 40, i32* %msg_code, align 8, !tbaa !12
  store i32 65500, i32* %arrayidx, align 4, !tbaa !15
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="40..65500, 65460", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; initial_setup
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 13, i32* %msg_code11, align 8, !tbaa !12
  store i32 %6, i32* %arrayidx16, align 4, !tbaa !15
Creating Node
  store i32 13, i32* %msg_code11, align 8, !tbaa !12
  store i32 %6, i32* %arrayidx16, align 4, !tbaa !15
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 13
  %6 = load i32, i32* %data_precision, align 8, !tbaa !17
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 13
Alt Seq
Creating Node
  %msg_code11 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 5
  %arrayidx16 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code11 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 5
  %arrayidx16 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code11 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 13, i32* %msg_code11, align 8, !tbaa !12
}
ScheduleNode: {
  store i32 %6, i32* %arrayidx16, align 4, !tbaa !15
}
ScheduleNode: {
  store i32 13, i32* %msg_code11, align 8, !tbaa !12
}
Count: 1
Start:   store i32 13, i32* %msg_code11, align 8, !tbaa !12
Processing:   store i32 13, i32* %msg_code11, align 8, !tbaa !12
Count: 1
Found:   store i32 13, i32* %msg_code11, align 8, !tbaa !12
ScheduleNode: {
  store i32 %6, i32* %arrayidx16, align 4, !tbaa !15
}
Non-memory:   %arrayidx16 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %6, i32* %arrayidx16, align 4, !tbaa !15
Count: 1
Found:   store i32 %6, i32* %arrayidx16, align 4, !tbaa !15
I:   %8 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err10, align 8, !tbaa !11
Last:   br label %if.end19
Schedulable: 1
Loop Rolling: initial_setup
Generating tree
Generating MATCH
Match: 
  store i32 13, i32* %msg_code11, align 8, !tbaa !12
  store i32 %6, i32* %arrayidx16, align 4, !tbaa !15
Generating ALTSEQ
Values:
i32 13
  %6 = load i32, i32* %data_precision, align 8, !tbaa !17
Generated Version 4:
  %53 = icmp eq i8 %52, 0
  %54 = select i1 %53, i32 13, i32 %6
Generating ALTSEQ
Values:
  %msg_code11 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 5
  %arrayidx16 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %55 = select i1 %53, i32* %msg_code11, i32* %arrayidx16
Operands done!
Generated:   store i32 %54, i32* %55, align 1
Gen:   store i32 %54, i32* %55, align 1
Graph code generated!
Root:
  store i32 13, i32* %msg_code11, align 8, !tbaa !12
  store i32 %6, i32* %arrayidx16, align 4, !tbaa !15
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 13, %6", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code11, %arrayidx16", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; initial_setup
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 10, i32* %arrayidx33, align 4, !tbaa !15
Attempting Group:
  store i32 24, i32* %msg_code24, align 8, !tbaa !12
  store i32 %11, i32* %arrayidx29, align 4, !tbaa !15
Creating Node
  store i32 24, i32* %msg_code24, align 8, !tbaa !12
  store i32 %11, i32* %arrayidx29, align 4, !tbaa !15
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 24
  %11 = load i32, i32* %num_components, align 8, !tbaa !18
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 24
Alt Seq
Creating Node
  %msg_code24 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %12, i64 0, i32 5
  %arrayidx29 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %12, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code24 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %12, i64 0, i32 5
  %arrayidx29 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %12, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code24 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %12, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 24, i32* %msg_code24, align 8, !tbaa !12
}
ScheduleNode: {
  store i32 %11, i32* %arrayidx29, align 4, !tbaa !15
}
ScheduleNode: {
  store i32 24, i32* %msg_code24, align 8, !tbaa !12
}
Count: 1
Start:   store i32 24, i32* %msg_code24, align 8, !tbaa !12
Processing:   store i32 24, i32* %msg_code24, align 8, !tbaa !12
Count: 1
Found:   store i32 24, i32* %msg_code24, align 8, !tbaa !12
ScheduleNode: {
  store i32 %11, i32* %arrayidx29, align 4, !tbaa !15
}
Non-memory:   %arrayidx29 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %12, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %11, i32* %arrayidx29, align 4, !tbaa !15
Count: 1
Found:   store i32 %11, i32* %arrayidx29, align 4, !tbaa !15
I:   %13 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err23, align 8, !tbaa !11
Last:   br label %if.end36
Schedulable: 1
Loop Rolling: initial_setup
Generating tree
Generating MATCH
Match: 
  store i32 24, i32* %msg_code24, align 8, !tbaa !12
  store i32 %11, i32* %arrayidx29, align 4, !tbaa !15
Generating ALTSEQ
Values:
i32 24
  %11 = load i32, i32* %num_components, align 8, !tbaa !18
Generated Version 4:
  %53 = icmp eq i8 %52, 0
  %54 = select i1 %53, i32 24, i32 %11
Generating ALTSEQ
Values:
  %msg_code24 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %12, i64 0, i32 5
  %arrayidx29 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %12, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %55 = select i1 %53, i32* %msg_code24, i32* %arrayidx29
Operands done!
Generated:   store i32 %54, i32* %55, align 1
Gen:   store i32 %54, i32* %55, align 1
Graph code generated!
Root:
  store i32 24, i32* %msg_code24, align 8, !tbaa !12
  store i32 %11, i32* %arrayidx29, align 4, !tbaa !15
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 24, %11", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code24, %arrayidx29", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; initial_setup
Trying AGAIN
Trying AGAIN
  %.pre-phi = phi %struct.jpeg_common_struct* [ %.pre224, %if.end19.if.end36_crit_edge ], [ %16, %if.then22 ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %max_h_samp_factor, align 4, !tbaa !19
  store i32 1, i32* %max_v_samp_factor, align 8, !tbaa !20
Creating Node
  store i32 1, i32* %max_h_samp_factor, align 4, !tbaa !19
  store i32 1, i32* %max_v_samp_factor, align 8, !tbaa !20
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 1
i32 1
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
Match: 0
2 x 2
Final Match: 0
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
Alt Seq
ScheduleNode: {
  store i32 1, i32* %max_h_samp_factor, align 4, !tbaa !19
}
ScheduleNode: {
  store i32 1, i32* %max_v_samp_factor, align 8, !tbaa !20
}
ScheduleNode: {
  store i32 1, i32* %max_h_samp_factor, align 4, !tbaa !19
}
Count: 1
Start:   store i32 1, i32* %max_h_samp_factor, align 4, !tbaa !19
Processing:   store i32 1, i32* %max_h_samp_factor, align 4, !tbaa !19
Count: 1
Found:   store i32 1, i32* %max_h_samp_factor, align 4, !tbaa !19
ScheduleNode: {
  store i32 1, i32* %max_v_samp_factor, align 8, !tbaa !20
}
Non-memory:   %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
Processing:   store i32 1, i32* %max_v_samp_factor, align 8, !tbaa !20
Count: 1
Found:   store i32 1, i32* %max_v_samp_factor, align 8, !tbaa !20
I:   %comp_info = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 43
Last:   br label %for.cond
Schedulable: 1
Loop Rolling: initial_setup
Generating tree
Generating MATCH
Match: 
  store i32 1, i32* %max_h_samp_factor, align 4, !tbaa !19
  store i32 1, i32* %max_v_samp_factor, align 8, !tbaa !20
Generating IDENTICAL
Generating ALTSEQ
Values:
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
Generated Version 4:
  %53 = icmp eq i8 %52, 0
  %54 = select i1 %53, i32* %max_h_samp_factor, i32* %max_v_samp_factor
Operands done!
Generated:   store i32 1, i32* %54, align 1
Gen:   store i32 1, i32* %54, align 1
Graph code generated!
Root:
  store i32 1, i32* %max_h_samp_factor, align 4, !tbaa !19
  store i32 1, i32* %max_v_samp_factor, align 8, !tbaa !20
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="1", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %max_h_samp_factor, %max_v_samp_factor", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 5 = -1; Width: 2; Unprofitable; initial_setup
Trying AGAIN
Trying AGAIN
  %18 = phi i32 [ 1, %if.end36 ], [ %cond75, %if.end58 ]
  %19 = phi i32 [ 1, %if.end36 ], [ %cond, %if.end58 ]
  %ci.0 = phi i32 [ 0, %if.end36 ], [ %inc, %if.end58 ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %17, %if.end36 ], [ %incdec.ptr, %if.end58 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 16, i32* %msg_code55, align 8, !tbaa !12
  %27 = phi i32 [ %23, %lor.lhs.false46 ], [ %.pre223, %if.then53 ]
  %28 = phi i32 [ %18, %lor.lhs.false46 ], [ %.pre222, %if.then53 ]
  %29 = phi i32 [ %21, %lor.lhs.false46 ], [ %.pre221, %if.then53 ]
  %30 = phi i32 [ %19, %lor.lhs.false46 ], [ %.pre220, %if.then53 ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 %cond, i32* %max_h_samp_factor, align 4, !tbaa !19
  store i32 %cond75, i32* %max_v_samp_factor, align 8, !tbaa !20
Creating Node
  store i32 %cond, i32* %max_h_samp_factor, align 4, !tbaa !19
  store i32 %cond75, i32* %max_v_samp_factor, align 8, !tbaa !20
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %cond = select i1 %cmp61, i32 %30, i32 %29
  %cond75 = select i1 %cmp68, i32 %28, i32 %27
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %cmp61 = icmp sgt i32 %30, %29
  %cmp68 = icmp sgt i32 %28, %27
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %30 = phi i32 [ %19, %lor.lhs.false46 ], [ %.pre220, %if.then53 ]
  %28 = phi i32 [ %18, %lor.lhs.false46 ], [ %.pre222, %if.then53 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %30 = phi i32 [ %19, %lor.lhs.false46 ], [ %.pre220, %if.then53 ]
Alt Seq
Creating Node
  %29 = phi i32 [ %21, %lor.lhs.false46 ], [ %.pre221, %if.then53 ]
  %27 = phi i32 [ %23, %lor.lhs.false46 ], [ %.pre223, %if.then53 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %29 = phi i32 [ %21, %lor.lhs.false46 ], [ %.pre221, %if.then53 ]
Alt Seq
Creating Node
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
Match: 0
2 x 2
Final Match: 0
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
Alt Seq
ScheduleNode: {
  store i32 %cond, i32* %max_h_samp_factor, align 4, !tbaa !19
}
ScheduleNode: {
  store i32 %cond75, i32* %max_v_samp_factor, align 8, !tbaa !20
}
ScheduleNode: {
  store i32 %cond, i32* %max_h_samp_factor, align 4, !tbaa !19
}
Count: 1
Start:   %cmp61 = icmp sgt i32 %30, %29
Non-memory:   %cmp61 = icmp sgt i32 %30, %29
Non-memory:   %cond = select i1 %cmp61, i32 %30, i32 %29
Processing:   store i32 %cond, i32* %max_h_samp_factor, align 4, !tbaa !19
Count: 1
Found:   store i32 %cond, i32* %max_h_samp_factor, align 4, !tbaa !19
ScheduleNode: {
  store i32 %cond75, i32* %max_v_samp_factor, align 8, !tbaa !20
}
Non-memory:   %cmp68 = icmp sgt i32 %28, %27
Non-memory:   %cond75 = select i1 %cmp68, i32 %28, i32 %27
Processing:   store i32 %cond75, i32* %max_v_samp_factor, align 8, !tbaa !20
Count: 1
Found:   store i32 %cond75, i32* %max_v_samp_factor, align 8, !tbaa !20
I:   %inc = add nuw nsw i32 %ci.0, 1
Last:   br label %for.cond, !llvm.loop !25
Schedulable: 1
Loop Rolling: initial_setup
Generating tree
Generating MATCH
Match: 
  store i32 %cond, i32* %max_h_samp_factor, align 4, !tbaa !19
  store i32 %cond75, i32* %max_v_samp_factor, align 8, !tbaa !20
Generating MATCH
Match: 
  %cond = select i1 %cmp61, i32 %30, i32 %29
  %cond75 = select i1 %cmp68, i32 %28, i32 %27
Generating MATCH
Match: 
  %cmp61 = icmp sgt i32 %30, %29
  %cmp68 = icmp sgt i32 %28, %27
Generating ALTSEQ
Values:
  %30 = phi i32 [ %19, %lor.lhs.false46 ], [ %.pre220, %if.then53 ]
  %28 = phi i32 [ %18, %lor.lhs.false46 ], [ %.pre222, %if.then53 ]
Generated Version 4:
  %53 = icmp eq i8 %52, 0
  %54 = select i1 %53, i32 %30, i32 %28
Generating ALTSEQ
Values:
  %29 = phi i32 [ %21, %lor.lhs.false46 ], [ %.pre221, %if.then53 ]
  %27 = phi i32 [ %23, %lor.lhs.false46 ], [ %.pre223, %if.then53 ]
Generated Version 4:
  %55 = select i1 %53, i32 %29, i32 %27
Operands done!
Generated:   %56 = icmp sgt i32 %54, %55
Gen:   %56 = icmp sgt i32 %54, %55
Operands done!
Generated:   %57 = select i1 %56, i32 %54, i32 %55
Found use: 0:   %19 = phi i32 [ 1, %if.end36 ], [ %cond, %if.end58 ]
Found use: 1:   %18 = phi i32 [ 1, %if.end36 ], [ %cond75, %if.end58 ]
Extracting:   %57 = select i1 %56, i32 %54, i32 %55
Gen:   %58 = select i1 %57, i32 %55, i32 %56
Generating ALTSEQ
Values:
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
Generated Version 4:
  %60 = select i1 %54, i32* %max_h_samp_factor, i32* %max_v_samp_factor
Operands done!
Generated:   store i32 %58, i32* %60, align 1
Gen:   store i32 %58, i32* %60, align 1
Graph code generated!
Root:
  store i32 %cond, i32* %max_h_samp_factor, align 4, !tbaa !19
  store i32 %cond75, i32* %max_v_samp_factor, align 8, !tbaa !20
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="select", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="icmp", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %31, %29", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %30, %28", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="alt: %max_h_samp_factor, %max_v_samp_factor", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
5->0 
2->1 
3->1 
4->1 
3->2 
4->2 
6 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
1->6
7 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
1->7
}

Gains: 8 - 24 = -16; Width: 2; Unprofitable; initial_setup
Trying AGAIN
Trying AGAIN
  %.lcssa = phi i32 [ %21, %for.cond ]
looking for reduction
Attempting Group:
  store i32 8, i32* %min_DCT_scaled_size, align 4, !tbaa !27
  %33 = phi i32 [ %.lcssa, %for.end ], [ %.pre, %for.body82 ]
  %ci.1 = phi i32 [ 0, %for.end ], [ %inc120, %for.body82 ]
  %compptr.1 = phi %struct.jpeg_component_info* [ %32, %for.end ], [ %incdec.ptr121, %for.body82 ]
looking for reduction
looking for reduction
looking for reduction
  %mul = mul nsw i64 %conv86, %conv84
looking for reduction
looking for reduction
looking for reduction
  %mul95 = mul nsw i64 %conv94, %conv92
looking for reduction
looking for reduction
looking for reduction
  %mul105 = mul nsw i64 %conv104, %conv102
looking for reduction
looking for reduction
looking for reduction
  %mul114 = mul nsw i64 %conv113, %conv111
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !28
  store i32 %conv90, i32* %width_in_blocks, align 4, !tbaa !29
  store i32 %conv100, i32* %height_in_blocks, align 8, !tbaa !30
  store i32 %conv109, i32* %downsampled_width, align 8, !tbaa !31
  store i32 %conv118, i32* %downsampled_height, align 4, !tbaa !32
  store i32 1, i32* %component_needed, align 8, !tbaa !33
Attempting Group:
  %call = tail call i64 @jdiv_round_up(i64 %mul, i64 %conv89) #3
  %call99 = tail call i64 @jdiv_round_up(i64 %mul95, i64 %conv98) #3
  %call108 = tail call i64 @jdiv_round_up(i64 %mul105, i64 %conv107) #3
  %call117 = tail call i64 @jdiv_round_up(i64 %mul114, i64 %conv116) #3
Creating Node
  store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !28
  store i32 %conv90, i32* %width_in_blocks, align 4, !tbaa !29
  store i32 %conv100, i32* %height_in_blocks, align 8, !tbaa !30
  store i32 %conv109, i32* %downsampled_width, align 8, !tbaa !31
  store i32 %conv118, i32* %downsampled_height, align 4, !tbaa !32
  store i32 1, i32* %component_needed, align 8, !tbaa !33
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
i32 8
  %conv90 = trunc i64 %call to i32
  %conv100 = trunc i64 %call99 to i32
  %conv109 = trunc i64 %call108 to i32
  %conv118 = trunc i64 %call117 to i32
i32 1
Match: 0
6 x 6
Final Match: 0
GEPSeq2
BinOP?
i32 8
Mismatching
Creating Node
  %DCT_scaled_size = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 9
  %width_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 7
  %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 8
  %downsampled_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 10
  %downsampled_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 11
  %component_needed = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 12
Match: 0
6 x 6
Final Match: 0
  %DCT_scaled_size = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 9
  %width_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 7
  %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 8
  %downsampled_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 10
  %downsampled_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 11
  %component_needed = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 12
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %DCT_scaled_size = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 9
Mismatching
ScheduleNode: {
  store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !28
}
ScheduleNode: {
  store i32 %conv90, i32* %width_in_blocks, align 4, !tbaa !29
}
ScheduleNode: {
  store i32 %conv100, i32* %height_in_blocks, align 8, !tbaa !30
}
ScheduleNode: {
  store i32 %conv109, i32* %downsampled_width, align 8, !tbaa !31
}
ScheduleNode: {
  store i32 %conv118, i32* %downsampled_height, align 4, !tbaa !32
}
ScheduleNode: {
  store i32 1, i32* %component_needed, align 8, !tbaa !33
}
ScheduleNode: {
  store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !28
}
Count: 1
Start:   store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !28
Processing:   store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !28
Count: 1
Found:   store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !28
ScheduleNode: {
  store i32 %conv90, i32* %width_in_blocks, align 4, !tbaa !29
}
Processing:   %34 = load i32, i32* %image_width83, align 8, !tbaa !10
Count: 1
Not found:   %34 = load i32, i32* %image_width83, align 8, !tbaa !10
Read/Write memory
I:   %34 = load i32, i32* %image_width83, align 8, !tbaa !10
Last:   br label %for.cond78, !llvm.loop !35
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


for.body82:                                       ; preds = %for.cond78
  %DCT_scaled_size = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 9
  store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !28
  %34 = load i32, i32* %image_width83, align 8, !tbaa !10
  %conv84 = zext i32 %34 to i64
  %h_samp_factor85 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
  %35 = load i32, i32* %h_samp_factor85, align 8, !tbaa !22
  %conv86 = sext i32 %35 to i64
  %mul = mul nsw i64 %conv86, %conv84
  %36 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !19
  %mul88 = shl nsw i32 %36, 3
  %conv89 = sext i32 %mul88 to i64
  %call = tail call i64 @jdiv_round_up(i64 %mul, i64 %conv89) #3
  %conv90 = trunc i64 %call to i32
  %width_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 7
  store i32 %conv90, i32* %width_in_blocks, align 4, !tbaa !29
  %37 = load i32, i32* %image_height, align 4, !tbaa !2
  %conv92 = zext i32 %37 to i64
  %v_samp_factor93 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 3
  %38 = load i32, i32* %v_samp_factor93, align 4, !tbaa !24
  %conv94 = sext i32 %38 to i64
  %mul95 = mul nsw i64 %conv94, %conv92
  %39 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !20
  %mul97 = shl nsw i32 %39, 3
  %conv98 = sext i32 %mul97 to i64
  %call99 = tail call i64 @jdiv_round_up(i64 %mul95, i64 %conv98) #3
  %conv100 = trunc i64 %call99 to i32
  %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 8
  store i32 %conv100, i32* %height_in_blocks, align 8, !tbaa !30
  %40 = load i32, i32* %image_width83, align 8, !tbaa !10
  %conv102 = zext i32 %40 to i64
  %41 = load i32, i32* %h_samp_factor85, align 8, !tbaa !22
  %conv104 = sext i32 %41 to i64
  %mul105 = mul nsw i64 %conv104, %conv102
  %42 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !19
  %conv107 = sext i32 %42 to i64
  %call108 = tail call i64 @jdiv_round_up(i64 %mul105, i64 %conv107) #3
  %conv109 = trunc i64 %call108 to i32
  %downsampled_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 10
  store i32 %conv109, i32* %downsampled_width, align 8, !tbaa !31
  %43 = load i32, i32* %image_height, align 4, !tbaa !2
  %conv111 = zext i32 %43 to i64
  %44 = load i32, i32* %v_samp_factor93, align 4, !tbaa !24
  %conv113 = sext i32 %44 to i64
  %mul114 = mul nsw i64 %conv113, %conv111
  %45 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !20
  %conv116 = sext i32 %45 to i64
  %call117 = tail call i64 @jdiv_round_up(i64 %mul114, i64 %conv116) #3
  %conv118 = trunc i64 %call117 to i32
  %downsampled_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 11
  store i32 %conv118, i32* %downsampled_height, align 4, !tbaa !32
  %component_needed = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 12
  store i32 1, i32* %component_needed, align 8, !tbaa !33
  %quant_table = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 19
  store %struct.JQUANT_TBL* null, %struct.JQUANT_TBL** %quant_table, align 8, !tbaa !34
  %inc120 = add nuw nsw i32 %ci.1, 1
  %incdec.ptr121 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 1
  %.pre = load i32, i32* %num_components, align 8, !tbaa !18
  br label %for.cond78, !llvm.loop !35

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Creating Node
  %call = tail call i64 @jdiv_round_up(i64 %mul, i64 %conv89) #3
  %call99 = tail call i64 @jdiv_round_up(i64 %mul95, i64 %conv98) #3
  %call108 = tail call i64 @jdiv_round_up(i64 %mul105, i64 %conv107) #3
  %call117 = tail call i64 @jdiv_round_up(i64 %mul114, i64 %conv116) #3
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %mul = mul nsw i64 %conv86, %conv84
  %mul95 = mul nsw i64 %conv94, %conv92
  %mul105 = mul nsw i64 %conv104, %conv102
  %mul114 = mul nsw i64 %conv113, %conv111
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %conv86 = sext i32 %35 to i64
  %conv94 = sext i32 %38 to i64
  %conv104 = sext i32 %41 to i64
  %conv113 = sext i32 %44 to i64
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %35 = load i32, i32* %h_samp_factor85, align 8, !tbaa !22
  %38 = load i32, i32* %v_samp_factor93, align 4, !tbaa !24
  %41 = load i32, i32* %h_samp_factor85, align 8, !tbaa !22
  %44 = load i32, i32* %v_samp_factor93, align 4, !tbaa !24
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %h_samp_factor85 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
  %v_samp_factor93 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 3
  %h_samp_factor85 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
  %v_samp_factor93 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 3
Match: 0
2 x 4
Final Match: 0
  %h_samp_factor85 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
  %v_samp_factor93 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 3
  %h_samp_factor85 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
  %v_samp_factor93 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 3
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %h_samp_factor85 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
Alt Seq
Creating Node
  %conv84 = zext i32 %34 to i64
  %conv92 = zext i32 %37 to i64
  %conv102 = zext i32 %40 to i64
  %conv111 = zext i32 %43 to i64
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %34 = load i32, i32* %image_width83, align 8, !tbaa !10
  %37 = load i32, i32* %image_height, align 4, !tbaa !2
  %40 = load i32, i32* %image_width83, align 8, !tbaa !10
  %43 = load i32, i32* %image_height, align 4, !tbaa !2
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %image_width83 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
  %image_width83 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
Match: 0
2 x 4
Final Match: 0
  %image_width83 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
  %image_width83 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %image_width83 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
Alt Seq
Creating Node
  %conv89 = sext i32 %mul88 to i64
  %conv98 = sext i32 %mul97 to i64
  %conv107 = sext i32 %42 to i64
  %conv116 = sext i32 %45 to i64
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %mul88 = shl nsw i32 %36, 3
  %mul97 = shl nsw i32 %39, 3
  %42 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !19
  %45 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !20
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %mul88 = shl nsw i32 %36, 3
Mismatching
Creating Node
Function: jdiv_round_up
Function: jdiv_round_up
Function: jdiv_round_up
Function: jdiv_round_up
Match: 1
1 x 4
Final Match: 1
All the Same
ScheduleNode: {
  %34 = load i32, i32* %image_width83, align 8, !tbaa !10
  %35 = load i32, i32* %h_samp_factor85, align 8, !tbaa !22
}
ScheduleNode: {
  %call = tail call i64 @jdiv_round_up(i64 %mul, i64 %conv89) #3
}
ScheduleNode: {
  %37 = load i32, i32* %image_height, align 4, !tbaa !2
  %38 = load i32, i32* %v_samp_factor93, align 4, !tbaa !24
}
ScheduleNode: {
  %call99 = tail call i64 @jdiv_round_up(i64 %mul95, i64 %conv98) #3
}
ScheduleNode: {
  %40 = load i32, i32* %image_width83, align 8, !tbaa !10
  %41 = load i32, i32* %h_samp_factor85, align 8, !tbaa !22
}
ScheduleNode: {
  %call108 = tail call i64 @jdiv_round_up(i64 %mul105, i64 %conv107) #3
}
ScheduleNode: {
  %43 = load i32, i32* %image_height, align 4, !tbaa !2
  %44 = load i32, i32* %v_samp_factor93, align 4, !tbaa !24
}
ScheduleNode: {
  %call117 = tail call i64 @jdiv_round_up(i64 %mul114, i64 %conv116) #3
}
ScheduleNode: {
  %34 = load i32, i32* %image_width83, align 8, !tbaa !10
  %35 = load i32, i32* %h_samp_factor85, align 8, !tbaa !22
}
Count: 2
Start:   %34 = load i32, i32* %image_width83, align 8, !tbaa !10
Processing:   %34 = load i32, i32* %image_width83, align 8, !tbaa !10
Count: 2
Found:   %34 = load i32, i32* %image_width83, align 8, !tbaa !10
Non-memory:   %conv84 = zext i32 %34 to i64
Non-memory:   %h_samp_factor85 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
Processing:   %35 = load i32, i32* %h_samp_factor85, align 8, !tbaa !22
Count: 1
Found:   %35 = load i32, i32* %h_samp_factor85, align 8, !tbaa !22
ScheduleNode: {
  %call = tail call i64 @jdiv_round_up(i64 %mul, i64 %conv89) #3
}
Non-memory:   %conv86 = sext i32 %35 to i64
Non-memory:   %mul = mul nsw i64 %conv86, %conv84
Processing:   %36 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !19
Count: 1
Not found:   %36 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !19
Read/Write memory
I:   %36 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !19
Last:   br label %for.cond78, !llvm.loop !35
Schedulable: 0
digraph VTree {
0 [label="call: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mul", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %h_samp_factor85, %v_samp_factor93", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %image_width83, %image_height", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
10 [label="func: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
8->0 
10->0 
2->1 
5->1 
3->2 
4->3 
6->5 
7->6 
9->8 
11 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->11
12 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->12
13 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->13
14 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->14
}


for.body82:                                       ; preds = %for.cond78
  %DCT_scaled_size = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 9
  store i32 8, i32* %DCT_scaled_size, align 4, !tbaa !28
  %34 = load i32, i32* %image_width83, align 8, !tbaa !10
  %conv84 = zext i32 %34 to i64
  %h_samp_factor85 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 2
  %35 = load i32, i32* %h_samp_factor85, align 8, !tbaa !22
  %conv86 = sext i32 %35 to i64
  %mul = mul nsw i64 %conv86, %conv84
  %36 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !19
  %mul88 = shl nsw i32 %36, 3
  %conv89 = sext i32 %mul88 to i64
  %call = tail call i64 @jdiv_round_up(i64 %mul, i64 %conv89) #3
  %conv90 = trunc i64 %call to i32
  %width_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 7
  store i32 %conv90, i32* %width_in_blocks, align 4, !tbaa !29
  %37 = load i32, i32* %image_height, align 4, !tbaa !2
  %conv92 = zext i32 %37 to i64
  %v_samp_factor93 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 3
  %38 = load i32, i32* %v_samp_factor93, align 4, !tbaa !24
  %conv94 = sext i32 %38 to i64
  %mul95 = mul nsw i64 %conv94, %conv92
  %39 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !20
  %mul97 = shl nsw i32 %39, 3
  %conv98 = sext i32 %mul97 to i64
  %call99 = tail call i64 @jdiv_round_up(i64 %mul95, i64 %conv98) #3
  %conv100 = trunc i64 %call99 to i32
  %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 8
  store i32 %conv100, i32* %height_in_blocks, align 8, !tbaa !30
  %40 = load i32, i32* %image_width83, align 8, !tbaa !10
  %conv102 = zext i32 %40 to i64
  %41 = load i32, i32* %h_samp_factor85, align 8, !tbaa !22
  %conv104 = sext i32 %41 to i64
  %mul105 = mul nsw i64 %conv104, %conv102
  %42 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !19
  %conv107 = sext i32 %42 to i64
  %call108 = tail call i64 @jdiv_round_up(i64 %mul105, i64 %conv107) #3
  %conv109 = trunc i64 %call108 to i32
  %downsampled_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 10
  store i32 %conv109, i32* %downsampled_width, align 8, !tbaa !31
  %43 = load i32, i32* %image_height, align 4, !tbaa !2
  %conv111 = zext i32 %43 to i64
  %44 = load i32, i32* %v_samp_factor93, align 4, !tbaa !24
  %conv113 = sext i32 %44 to i64
  %mul114 = mul nsw i64 %conv113, %conv111
  %45 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !20
  %conv116 = sext i32 %45 to i64
  %call117 = tail call i64 @jdiv_round_up(i64 %mul114, i64 %conv116) #3
  %conv118 = trunc i64 %call117 to i32
  %downsampled_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 11
  store i32 %conv118, i32* %downsampled_height, align 4, !tbaa !32
  %component_needed = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 12
  store i32 1, i32* %component_needed, align 8, !tbaa !33
  %quant_table = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 0, i32 19
  store %struct.JQUANT_TBL* null, %struct.JQUANT_TBL** %quant_table, align 8, !tbaa !34
  %inc120 = add nuw nsw i32 %ci.1, 1
  %incdec.ptr121 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1, i64 1
  %.pre = load i32, i32* %num_components, align 8, !tbaa !18
  br label %for.cond78, !llvm.loop !35

looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %conv129, i32* %total_iMCU_rows, align 8, !tbaa !36
Attempting Group:
  %call128 = tail call i64 @jdiv_round_up(i64 %conv124, i64 %conv127) #3
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %has_multiple_scans, align 8, !tbaa !40
looking for reduction
Attempting Group:
  store i32 0, i32* %has_multiple_scans136, align 8, !tbaa !40
looking for reduction
Done Loop Roller: 0/5
Optimizing: per_scan_setup
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %MCU_width, align 4, !tbaa !16
  store i32 1, i32* %MCU_height, align 8, !tbaa !17
  store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
  store i32 %4, i32* %MCU_sample_width, align 8, !tbaa !20
  store i32 1, i32* %last_col_width, align 4, !tbaa !21
  store i32 %spec.select, i32* %last_row_height, align 8, !tbaa !23
Attempting Group:
  store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
  store i32 %3, i32* %MCU_rows_in_scan, align 4, !tbaa !15
  store i32 1, i32* %blocks_in_MCU, align 8, !tbaa !24
  store i32 0, i32* %arrayidx5, align 4, !tbaa !25
Creating Node
  store i32 1, i32* %MCU_width, align 4, !tbaa !16
  store i32 1, i32* %MCU_height, align 8, !tbaa !17
  store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
  store i32 %4, i32* %MCU_sample_width, align 8, !tbaa !20
  store i32 1, i32* %last_col_width, align 4, !tbaa !21
  store i32 %spec.select, i32* %last_row_height, align 8, !tbaa !23
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
i32 1
i32 1
i32 1
  %4 = load i32, i32* %DCT_scaled_size, align 4, !tbaa !19
i32 1
  %spec.select = select i1 %cmp2, i32 %5, i32 %rem
Match: 0
3 x 6
Final Match: 0
GEPSeq2
BinOP?
i32 1
Mismatching
Creating Node
  %MCU_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
  %MCU_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
  %MCU_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
  %MCU_sample_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 16
  %last_col_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 17
  %last_row_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 18
Match: 0
6 x 6
Final Match: 0
  %MCU_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
  %MCU_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
  %MCU_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
  %MCU_sample_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 16
  %last_col_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 17
  %last_row_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 18
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %MCU_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
Mismatching
ScheduleNode: {
  store i32 1, i32* %MCU_width, align 4, !tbaa !16
}
ScheduleNode: {
  store i32 1, i32* %MCU_height, align 8, !tbaa !17
}
ScheduleNode: {
  store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
}
ScheduleNode: {
  store i32 %4, i32* %MCU_sample_width, align 8, !tbaa !20
}
ScheduleNode: {
  store i32 1, i32* %last_col_width, align 4, !tbaa !21
}
ScheduleNode: {
  store i32 %spec.select, i32* %last_row_height, align 8, !tbaa !23
}
ScheduleNode: {
  store i32 1, i32* %MCU_width, align 4, !tbaa !16
}
Count: 1
Start:   store i32 1, i32* %MCU_width, align 4, !tbaa !16
Processing:   store i32 1, i32* %MCU_width, align 4, !tbaa !16
Count: 1
Found:   store i32 1, i32* %MCU_width, align 4, !tbaa !16
ScheduleNode: {
  store i32 1, i32* %MCU_height, align 8, !tbaa !17
}
Non-memory:   %MCU_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
Processing:   store i32 1, i32* %MCU_height, align 8, !tbaa !17
Count: 1
Found:   store i32 1, i32* %MCU_height, align 8, !tbaa !17
ScheduleNode: {
  store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
}
Non-memory:   %MCU_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
Processing:   store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
Count: 1
Found:   store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
ScheduleNode: {
  store i32 %4, i32* %MCU_sample_width, align 8, !tbaa !20
}
Non-memory:   %DCT_scaled_size = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 9
Processing:   %4 = load i32, i32* %DCT_scaled_size, align 4, !tbaa !19
Count: 1
Not found:   %4 = load i32, i32* %DCT_scaled_size, align 4, !tbaa !19
Read/Write memory
I:   %4 = load i32, i32* %DCT_scaled_size, align 4, !tbaa !19
Last:   br label %if.end81
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


if.then:                                          ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 63, i64 0
  %1 = load %struct.jpeg_component_info*, %struct.jpeg_component_info** %arrayidx, align 8, !tbaa !10
  %width_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 7
  %2 = load i32, i32* %width_in_blocks, align 4, !tbaa !11
  %MCUs_per_row = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
  %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 8
  %3 = load i32, i32* %height_in_blocks, align 8, !tbaa !14
  %MCU_rows_in_scan = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  store i32 %3, i32* %MCU_rows_in_scan, align 4, !tbaa !15
  %MCU_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
  store i32 1, i32* %MCU_width, align 4, !tbaa !16
  %MCU_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
  store i32 1, i32* %MCU_height, align 8, !tbaa !17
  %MCU_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
  store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
  %DCT_scaled_size = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 9
  %4 = load i32, i32* %DCT_scaled_size, align 4, !tbaa !19
  %MCU_sample_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 16
  store i32 %4, i32* %MCU_sample_width, align 8, !tbaa !20
  %last_col_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 17
  store i32 1, i32* %last_col_width, align 4, !tbaa !21
  %v_samp_factor = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 3
  %5 = load i32, i32* %v_samp_factor, align 4, !tbaa !22
  %rem = urem i32 %3, %5
  %cmp2 = icmp eq i32 %rem, 0
  %spec.select = select i1 %cmp2, i32 %5, i32 %rem
  %last_row_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 18
  store i32 %spec.select, i32* %last_row_height, align 8, !tbaa !23
  %blocks_in_MCU = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  store i32 1, i32* %blocks_in_MCU, align 8, !tbaa !24
  %arrayidx5 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 0
  store i32 0, i32* %arrayidx5, align 4, !tbaa !25
  br label %if.end81

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Creating Node
  store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
  store i32 %3, i32* %MCU_rows_in_scan, align 4, !tbaa !15
  store i32 1, i32* %blocks_in_MCU, align 8, !tbaa !24
  store i32 0, i32* %arrayidx5, align 4, !tbaa !25
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %2 = load i32, i32* %width_in_blocks, align 4, !tbaa !11
  %3 = load i32, i32* %height_in_blocks, align 8, !tbaa !14
i32 1
i32 0
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %2 = load i32, i32* %width_in_blocks, align 4, !tbaa !11
Mismatching
Creating Node
  %MCUs_per_row = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  %MCU_rows_in_scan = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  %blocks_in_MCU = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  %arrayidx5 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 0
Match: 0
4 x 4
Final Match: 0
  %MCUs_per_row = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  %MCU_rows_in_scan = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  %blocks_in_MCU = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  %arrayidx5 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 0
GEPSeq2
BinOP?
  %MCUs_per_row = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
Mismatching
ScheduleNode: {
  store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
}
ScheduleNode: {
  store i32 %3, i32* %MCU_rows_in_scan, align 4, !tbaa !15
}
ScheduleNode: {
  store i32 1, i32* %blocks_in_MCU, align 8, !tbaa !24
}
ScheduleNode: {
  store i32 0, i32* %arrayidx5, align 4, !tbaa !25
}
ScheduleNode: {
  store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
}
Count: 1
Start:   store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
Processing:   store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
Count: 1
Found:   store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
ScheduleNode: {
  store i32 %3, i32* %MCU_rows_in_scan, align 4, !tbaa !15
}
Non-memory:   %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 8
Processing:   %3 = load i32, i32* %height_in_blocks, align 8, !tbaa !14
Count: 1
Not found:   %3 = load i32, i32* %height_in_blocks, align 8, !tbaa !14
Read/Write memory
I:   %3 = load i32, i32* %height_in_blocks, align 8, !tbaa !14
Last:   br label %if.end81
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


if.then:                                          ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 63, i64 0
  %1 = load %struct.jpeg_component_info*, %struct.jpeg_component_info** %arrayidx, align 8, !tbaa !10
  %width_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 7
  %2 = load i32, i32* %width_in_blocks, align 4, !tbaa !11
  %MCUs_per_row = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  store i32 %2, i32* %MCUs_per_row, align 8, !tbaa !13
  %height_in_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 8
  %3 = load i32, i32* %height_in_blocks, align 8, !tbaa !14
  %MCU_rows_in_scan = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  store i32 %3, i32* %MCU_rows_in_scan, align 4, !tbaa !15
  %MCU_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
  store i32 1, i32* %MCU_width, align 4, !tbaa !16
  %MCU_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
  store i32 1, i32* %MCU_height, align 8, !tbaa !17
  %MCU_blocks = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
  store i32 1, i32* %MCU_blocks, align 4, !tbaa !18
  %DCT_scaled_size = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 9
  %4 = load i32, i32* %DCT_scaled_size, align 4, !tbaa !19
  %MCU_sample_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 16
  store i32 %4, i32* %MCU_sample_width, align 8, !tbaa !20
  %last_col_width = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 17
  store i32 1, i32* %last_col_width, align 4, !tbaa !21
  %v_samp_factor = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 3
  %5 = load i32, i32* %v_samp_factor, align 4, !tbaa !22
  %rem = urem i32 %3, %5
  %cmp2 = icmp eq i32 %rem, 0
  %spec.select = select i1 %cmp2, i32 %5, i32 %rem
  %last_row_height = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 18
  store i32 %spec.select, i32* %last_row_height, align 8, !tbaa !23
  %blocks_in_MCU = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  store i32 1, i32* %blocks_in_MCU, align 8, !tbaa !24
  %arrayidx5 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 0
  store i32 0, i32* %arrayidx5, align 4, !tbaa !25
  br label %if.end81

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 4, i32* %arrayidx17, align 4, !tbaa !30
Attempting Group:
  store i32 24, i32* %msg_code, align 8, !tbaa !27
  store i32 %0, i32* %arrayidx13, align 4, !tbaa !30
Creating Node
  store i32 24, i32* %msg_code, align 8, !tbaa !27
  store i32 %0, i32* %arrayidx13, align 4, !tbaa !30
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 24
  %0 = load i32, i32* %comps_in_scan, align 8, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 24
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 5
  %arrayidx13 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 5
  %arrayidx13 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 24, i32* %msg_code, align 8, !tbaa !27
}
ScheduleNode: {
  store i32 %0, i32* %arrayidx13, align 4, !tbaa !30
}
ScheduleNode: {
  store i32 24, i32* %msg_code, align 8, !tbaa !27
}
Count: 1
Start:   store i32 24, i32* %msg_code, align 8, !tbaa !27
Processing:   store i32 24, i32* %msg_code, align 8, !tbaa !27
Count: 1
Found:   store i32 24, i32* %msg_code, align 8, !tbaa !27
ScheduleNode: {
  store i32 %0, i32* %arrayidx13, align 4, !tbaa !30
}
Non-memory:   %arrayidx13 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %0, i32* %arrayidx13, align 4, !tbaa !30
Count: 1
Found:   store i32 %0, i32* %arrayidx13, align 4, !tbaa !30
I:   %8 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !26
Last:   br label %if.end19
Schedulable: 1
Loop Rolling: per_scan_setup
Generating tree
Generating MATCH
Match: 
  store i32 24, i32* %msg_code, align 8, !tbaa !27
  store i32 %0, i32* %arrayidx13, align 4, !tbaa !30
Generating ALTSEQ
Values:
i32 24
  %0 = load i32, i32* %comps_in_scan, align 8, !tbaa !2
Generated Version 4:
  %30 = icmp eq i8 %29, 0
  %31 = select i1 %30, i32 24, i32 %0
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 5
  %arrayidx13 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %32 = select i1 %30, i32* %msg_code, i32* %arrayidx13
Operands done!
Generated:   store i32 %31, i32* %32, align 1
Gen:   store i32 %31, i32* %32, align 1
Graph code generated!
Root:
  store i32 24, i32* %msg_code, align 8, !tbaa !27
  store i32 %0, i32* %arrayidx13, align 4, !tbaa !30
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 24, %0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx13", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; per_scan_setup
Trying AGAIN
Trying AGAIN
  %.pre-phi = phi %struct.jpeg_common_struct* [ %.pre, %if.else.if.end19_crit_edge ], [ %11, %if.then10 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
  store i32 %conv27, i32* %MCU_rows_in_scan28, align 4, !tbaa !15
  store i32 0, i32* %blocks_in_MCU29, align 8, !tbaa !24
Attempting Group:
  %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
  %call26 = tail call i64 @jdiv_round_up(i64 %conv23, i64 %conv25) #3
Creating Node
  store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
  store i32 %conv27, i32* %MCU_rows_in_scan28, align 4, !tbaa !15
  store i32 0, i32* %blocks_in_MCU29, align 8, !tbaa !24
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %conv21 = trunc i64 %call to i32
  %conv27 = trunc i64 %call26 to i32
i32 0
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %conv21 = trunc i64 %call to i32
Mismatching
Creating Node
  %MCUs_per_row22 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  %MCU_rows_in_scan28 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
Match: 0
3 x 3
Final Match: 0
  %MCUs_per_row22 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  %MCU_rows_in_scan28 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %MCUs_per_row22 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
Mismatching
ScheduleNode: {
  store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
}
ScheduleNode: {
  store i32 %conv27, i32* %MCU_rows_in_scan28, align 4, !tbaa !15
}
ScheduleNode: {
  store i32 0, i32* %blocks_in_MCU29, align 8, !tbaa !24
}
ScheduleNode: {
  store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
}
Count: 1
Start:   store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
Processing:   store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
Count: 1
Found:   store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
ScheduleNode: {
  store i32 %conv27, i32* %MCU_rows_in_scan28, align 4, !tbaa !15
}
Non-memory:   %image_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
Processing:   %14 = load i32, i32* %image_height, align 4, !tbaa !34
Count: 1
Not found:   %14 = load i32, i32* %image_height, align 4, !tbaa !34
Read/Write memory
I:   %14 = load i32, i32* %image_height, align 4, !tbaa !34
Last:   br label %for.cond
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


if.end19:                                         ; preds = %if.else.if.end19_crit_edge, %if.then10
  %.pre-phi = phi %struct.jpeg_common_struct* [ %.pre, %if.else.if.end19_crit_edge ], [ %11, %if.then10 ]
  %image_width = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %12 = load i32, i32* %image_width, align 8, !tbaa !32
  %conv = zext i32 %12 to i64
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %13 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !33
  %mul = shl nsw i32 %13, 3
  %conv20 = sext i32 %mul to i64
  %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
  %conv21 = trunc i64 %call to i32
  %MCUs_per_row22 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
  %image_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
  %14 = load i32, i32* %image_height, align 4, !tbaa !34
  %conv23 = zext i32 %14 to i64
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
  %15 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !35
  %mul24 = shl nsw i32 %15, 3
  %conv25 = sext i32 %mul24 to i64
  %call26 = tail call i64 @jdiv_round_up(i64 %conv23, i64 %conv25) #3
  %conv27 = trunc i64 %call26 to i32
  %MCU_rows_in_scan28 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  store i32 %conv27, i32* %MCU_rows_in_scan28, align 4, !tbaa !15
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  store i32 0, i32* %blocks_in_MCU29, align 8, !tbaa !24
  %err69 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 0
  br label %for.cond

Trying AGAIN
Trying AGAIN
Trying AGAIN
Creating Node
  %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
  %call26 = tail call i64 @jdiv_round_up(i64 %conv23, i64 %conv25) #3
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv = zext i32 %12 to i64
  %conv23 = zext i32 %14 to i64
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %12 = load i32, i32* %image_width, align 8, !tbaa !32
  %14 = load i32, i32* %image_height, align 4, !tbaa !34
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %image_width = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
Match: 0
2 x 2
Final Match: 0
  %image_width = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %image_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %image_width = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
Alt Seq
Creating Node
  %conv20 = sext i32 %mul to i64
  %conv25 = sext i32 %mul24 to i64
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %mul = shl nsw i32 %13, 3
  %mul24 = shl nsw i32 %15, 3
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %13 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !33
  %15 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !35
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
Match: 0
2 x 2
Final Match: 0
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
Alt Seq
Creating Node
i32 3
i32 3
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
Function: jdiv_round_up
Function: jdiv_round_up
Match: 1
1 x 2
Final Match: 1
All the Same
ScheduleNode: {
  %12 = load i32, i32* %image_width, align 8, !tbaa !32
  %13 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !33
}
ScheduleNode: {
  %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
}
ScheduleNode: {
  %14 = load i32, i32* %image_height, align 4, !tbaa !34
  %15 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !35
}
ScheduleNode: {
  %call26 = tail call i64 @jdiv_round_up(i64 %conv23, i64 %conv25) #3
}
ScheduleNode: {
  %12 = load i32, i32* %image_width, align 8, !tbaa !32
  %13 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !33
}
Count: 2
Start:   %12 = load i32, i32* %image_width, align 8, !tbaa !32
Processing:   %12 = load i32, i32* %image_width, align 8, !tbaa !32
Count: 2
Found:   %12 = load i32, i32* %image_width, align 8, !tbaa !32
Non-memory:   %conv = zext i32 %12 to i64
Non-memory:   %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
Processing:   %13 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !33
Count: 1
Found:   %13 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !33
ScheduleNode: {
  %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
}
Non-memory:   %mul = shl nsw i32 %13, 3
Non-memory:   %conv20 = sext i32 %mul to i64
Processing:   %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
Count: 1
Found:   %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
ScheduleNode: {
  %14 = load i32, i32* %image_height, align 4, !tbaa !34
  %15 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !35
}
Non-memory:   %conv21 = trunc i64 %call to i32
Non-memory:   %MCUs_per_row22 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
Processing:   store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
Count: 2
Not found:   store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
Read/Write memory
I:   store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
Last:   br label %for.cond
Schedulable: 0
digraph VTree {
0 [label="call: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %image_width, %image_height", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="shl", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %max_h_samp_factor, %max_v_samp_factor", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="3", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="func: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
9->0 
2->1 
3->2 
5->4 
6->5 
8->5 
7->6 
10 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->10
11 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->11
}


if.end19:                                         ; preds = %if.else.if.end19_crit_edge, %if.then10
  %.pre-phi = phi %struct.jpeg_common_struct* [ %.pre, %if.else.if.end19_crit_edge ], [ %11, %if.then10 ]
  %image_width = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %12 = load i32, i32* %image_width, align 8, !tbaa !32
  %conv = zext i32 %12 to i64
  %max_h_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %13 = load i32, i32* %max_h_samp_factor, align 4, !tbaa !33
  %mul = shl nsw i32 %13, 3
  %conv20 = sext i32 %mul to i64
  %call = tail call i64 @jdiv_round_up(i64 %conv, i64 %conv20) #3
  %conv21 = trunc i64 %call to i32
  %MCUs_per_row22 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  store i32 %conv21, i32* %MCUs_per_row22, align 8, !tbaa !13
  %image_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
  %14 = load i32, i32* %image_height, align 4, !tbaa !34
  %conv23 = zext i32 %14 to i64
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
  %15 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !35
  %mul24 = shl nsw i32 %15, 3
  %conv25 = sext i32 %mul24 to i64
  %call26 = tail call i64 @jdiv_round_up(i64 %conv23, i64 %conv25) #3
  %conv27 = trunc i64 %call26 to i32
  %MCU_rows_in_scan28 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  store i32 %conv27, i32* %MCU_rows_in_scan28, align 4, !tbaa !15
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  store i32 0, i32* %blocks_in_MCU29, align 8, !tbaa !24
  %err69 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 0
  br label %for.cond

  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.end19 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul40 = mul nsw i32 %20, %19
looking for reduction
  %mul44 = mul nsw i32 %21, %19
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %19, i32* %MCU_width35, align 4, !tbaa !16
  store i32 %20, i32* %MCU_height37, align 8, !tbaa !17
  store i32 %mul40, i32* %MCU_blocks41, align 4, !tbaa !18
  store i32 %mul44, i32* %MCU_sample_width45, align 8, !tbaa !20
  store i32 %spec.select153, i32* %last_col_width54, align 4, !tbaa !21
  store i32 %tmp.2, i32* %last_row_height63, align 8, !tbaa !23
Creating Node
  store i32 %19, i32* %MCU_width35, align 4, !tbaa !16
  store i32 %20, i32* %MCU_height37, align 8, !tbaa !17
  store i32 %mul40, i32* %MCU_blocks41, align 4, !tbaa !18
  store i32 %mul44, i32* %MCU_sample_width45, align 8, !tbaa !20
  store i32 %spec.select153, i32* %last_col_width54, align 4, !tbaa !21
  store i32 %tmp.2, i32* %last_row_height63, align 8, !tbaa !23
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
  %19 = load i32, i32* %h_samp_factor, align 8, !tbaa !36
  %20 = load i32, i32* %v_samp_factor36, align 4, !tbaa !22
  %mul40 = mul nsw i32 %20, %19
  %mul44 = mul nsw i32 %21, %19
  %spec.select153 = select i1 %cmp49, i32 %19, i32 %rem48
  %tmp.2 = select i1 %cmp58, i32 %20, i32 %rem57
Match: 0
6 x 6
Final Match: 0
GEPSeq2
BinOP?
  %19 = load i32, i32* %h_samp_factor, align 8, !tbaa !36
BinOp Seq
Creating Node
  %19 = load i32, i32* %h_samp_factor, align 8, !tbaa !36
  %20 = load i32, i32* %v_samp_factor36, align 4, !tbaa !22
  %20 = load i32, i32* %v_samp_factor36, align 4, !tbaa !22
  %21 = load i32, i32* %DCT_scaled_size43, align 4, !tbaa !19
  %spec.select153 = select i1 %cmp49, i32 %19, i32 %rem48
  %tmp.2 = select i1 %cmp58, i32 %20, i32 %rem57
Match: 0
5 x 6
Final Match: 0
GEPSeq2
BinOP?
  %19 = load i32, i32* %h_samp_factor, align 8, !tbaa !36
Mismatching
Creating Node
i32 1
i32 1
  %19 = load i32, i32* %h_samp_factor, align 8, !tbaa !36
  %19 = load i32, i32* %h_samp_factor, align 8, !tbaa !36
i32 1
i32 1
Match: 0
2 x 6
Final Match: 0
GEPSeq2
BinOP?
i32 1
Mismatching
Creating Node
  %MCU_width35 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 13
  %MCU_height37 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 14
  %MCU_blocks41 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 15
  %MCU_sample_width45 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 16
  %last_col_width54 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 17
  %last_row_height63 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 18
Match: 0
6 x 6
Final Match: 0
  %MCU_width35 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 13
  %MCU_height37 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 14
  %MCU_blocks41 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 15
  %MCU_sample_width45 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 16
  %last_col_width54 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 17
  %last_row_height63 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 18
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %MCU_width35 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 13
Mismatching
ScheduleNode: {
  store i32 %19, i32* %MCU_width35, align 4, !tbaa !16
}
ScheduleNode: {
  store i32 %20, i32* %MCU_height37, align 8, !tbaa !17
}
ScheduleNode: {
  store i32 %mul40, i32* %MCU_blocks41, align 4, !tbaa !18
}
ScheduleNode: {
  store i32 %mul44, i32* %MCU_sample_width45, align 8, !tbaa !20
}
ScheduleNode: {
  store i32 %spec.select153, i32* %last_col_width54, align 4, !tbaa !21
}
ScheduleNode: {
  store i32 %tmp.2, i32* %last_row_height63, align 8, !tbaa !23
}
ScheduleNode: {
  store i32 %19, i32* %MCU_width35, align 4, !tbaa !16
}
Count: 1
Start:   store i32 %19, i32* %MCU_width35, align 4, !tbaa !16
Processing:   store i32 %19, i32* %MCU_width35, align 4, !tbaa !16
Count: 1
Found:   store i32 %19, i32* %MCU_width35, align 4, !tbaa !16
ScheduleNode: {
  store i32 %20, i32* %MCU_height37, align 8, !tbaa !17
}
Non-memory:   %v_samp_factor36 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 3
Processing:   %20 = load i32, i32* %v_samp_factor36, align 4, !tbaa !22
Count: 1
Not found:   %20 = load i32, i32* %v_samp_factor36, align 4, !tbaa !22
Read/Write memory
I:   %20 = load i32, i32* %v_samp_factor36, align 4, !tbaa !22
Last:   br i1 %cmp66, label %if.then68, label %if.end73
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mul seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
4 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
4->0 
2->1 
3->1 
5 [label="add", style="filled" , fillcolor="#f2eb5c", shape=box];
1->5
}


for.body:                                         ; preds = %for.cond
  %arrayidx34 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 63, i64 %indvars.iv
  %18 = load %struct.jpeg_component_info*, %struct.jpeg_component_info** %arrayidx34, align 8, !tbaa !10
  %h_samp_factor = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 2
  %19 = load i32, i32* %h_samp_factor, align 8, !tbaa !36
  %MCU_width35 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 13
  store i32 %19, i32* %MCU_width35, align 4, !tbaa !16
  %v_samp_factor36 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 3
  %20 = load i32, i32* %v_samp_factor36, align 4, !tbaa !22
  %MCU_height37 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 14
  store i32 %20, i32* %MCU_height37, align 8, !tbaa !17
  %mul40 = mul nsw i32 %20, %19
  %MCU_blocks41 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 15
  store i32 %mul40, i32* %MCU_blocks41, align 4, !tbaa !18
  %DCT_scaled_size43 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 9
  %21 = load i32, i32* %DCT_scaled_size43, align 4, !tbaa !19
  %mul44 = mul nsw i32 %21, %19
  %MCU_sample_width45 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 16
  store i32 %mul44, i32* %MCU_sample_width45, align 8, !tbaa !20
  %width_in_blocks46 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 7
  %22 = load i32, i32* %width_in_blocks46, align 4, !tbaa !11
  %rem48 = urem i32 %22, %19
  %cmp49 = icmp eq i32 %rem48, 0
  %spec.select153 = select i1 %cmp49, i32 %19, i32 %rem48
  %last_col_width54 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 17
  store i32 %spec.select153, i32* %last_col_width54, align 4, !tbaa !21
  %height_in_blocks55 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 8
  %23 = load i32, i32* %height_in_blocks55, align 8, !tbaa !14
  %rem57 = urem i32 %23, %20
  %cmp58 = icmp eq i32 %rem57, 0
  %tmp.2 = select i1 %cmp58, i32 %20, i32 %rem57
  %last_row_height63 = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 18
  store i32 %tmp.2, i32* %last_row_height63, align 8, !tbaa !23
  %24 = load i32, i32* %blocks_in_MCU29, align 8, !tbaa !24
  %add = add nsw i32 %24, %mul40
  %cmp66 = icmp sgt i32 %add, 10
  br i1 %cmp66, label %if.then68, label %if.end73

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
Attempting Group:
  store i32 11, i32* %msg_code70, align 8, !tbaa !27
  %mcublks.0 = phi i32 [ %mul40, %if.end73 ], [ %dec, %while.body ]
looking for reduction
looking for reduction
  %inc = add nsw i32 %28, 1
looking for reduction
Attempting Group:
  store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !24
  store i32 %27, i32* %arrayidx79, align 4, !tbaa !25
Creating Node
  store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !24
  store i32 %27, i32* %arrayidx79, align 4, !tbaa !25
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %inc = add nsw i32 %28, 1
  %27 = trunc i64 %indvars.iv to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %inc = add nsw i32 %28, 1
BinOp Seq
Creating Node
  %28 = load i32, i32* %blocks_in_MCU29, align 8, !tbaa !24
  %27 = trunc i64 %indvars.iv to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %28 = load i32, i32* %blocks_in_MCU29, align 8, !tbaa !24
Alt Seq
Creating Node
i32 1
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  %arrayidx79 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 %idxprom78
Match: 0
2 x 2
Final Match: 0
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  %arrayidx79 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 %idxprom78
GEPSeq2
BinOP?
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
Alt Seq
ScheduleNode: {
  store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !24
}
ScheduleNode: {
  store i32 %27, i32* %arrayidx79, align 4, !tbaa !25
}
ScheduleNode: {
  store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !24
}
Count: 1
Start:   %inc = add nsw i32 %28, 1
Non-memory:   %inc = add nsw i32 %28, 1
Processing:   store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !24
Count: 1
Found:   store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !24
ScheduleNode: {
  store i32 %27, i32* %arrayidx79, align 4, !tbaa !25
}
Non-memory:   %idxprom78 = sext i32 %28 to i64
Non-memory:   %arrayidx79 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 %idxprom78
Processing:   store i32 %27, i32* %arrayidx79, align 4, !tbaa !25
Count: 1
Found:   store i32 %27, i32* %arrayidx79, align 4, !tbaa !25
I:   br label %while.cond, !llvm.loop !37
Last:   br label %while.cond, !llvm.loop !37
Schedulable: 1
Loop Rolling: per_scan_setup
Generating tree
Generating MATCH
Match: 
  store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !24
  store i32 %27, i32* %arrayidx79, align 4, !tbaa !25
Generating BINOP
Generating ALTSEQ
Values:
  %28 = load i32, i32* %blocks_in_MCU29, align 8, !tbaa !24
  %27 = trunc i64 %indvars.iv to i32
Generated Version 4:
  %30 = icmp eq i8 %29, 0
  %31 = select i1 %30, i32 %28, i32 %27
Generating INTSEQ
Gen:   %34 = add i32 %33, 1
Closing BINOP
Gen:   %35 = add nsw i32 %31, %34
Generating ALTSEQ
Values:
  %blocks_in_MCU29 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  %arrayidx79 = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 %idxprom78
Generated Version 4:
  %36 = select i1 %30, i32* %blocks_in_MCU29, i32* %arrayidx79
Operands done!
Generated:   store i32 %35, i32* %36, align 1
Gen:   store i32 %35, i32* %36, align 1
Graph code generated!
Root:
  store i32 %inc, i32* %blocks_in_MCU29, align 8, !tbaa !24
  store i32 %27, i32* %arrayidx79, align 4, !tbaa !25
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %28, %27", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="1..0, -1", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %blocks_in_MCU29, %arrayidx79", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
}

Gains: 6 - 12 = -6; Width: 2; Unprofitable; per_scan_setup
Trying AGAIN
Trying AGAIN
looking for reduction
Done Loop Roller: 0/2
Optimizing: latch_quant_tables
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 51, i32* %msg_code, align 8, !tbaa !15
  store i32 %5, i32* %arrayidx10, align 4, !tbaa !18
Creating Node
  store i32 51, i32* %msg_code, align 8, !tbaa !15
  store i32 %5, i32* %arrayidx10, align 4, !tbaa !18
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 51
  %5 = load i32, i32* %quant_tbl_no, align 8, !tbaa !13
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 51
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 5
  %arrayidx10 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 5
  %arrayidx10 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 51, i32* %msg_code, align 8, !tbaa !15
}
ScheduleNode: {
  store i32 %5, i32* %arrayidx10, align 4, !tbaa !18
}
ScheduleNode: {
  store i32 51, i32* %msg_code, align 8, !tbaa !15
}
Count: 1
Start:   store i32 51, i32* %msg_code, align 8, !tbaa !15
Processing:   store i32 51, i32* %msg_code, align 8, !tbaa !15
Count: 1
Found:   store i32 51, i32* %msg_code, align 8, !tbaa !15
ScheduleNode: {
  store i32 %5, i32* %arrayidx10, align 4, !tbaa !18
}
Non-memory:   %arrayidx10 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %5, i32* %arrayidx10, align 4, !tbaa !18
Count: 1
Found:   store i32 %5, i32* %arrayidx10, align 4, !tbaa !18
I:   %9 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !14
Last:   br label %if.end12
Schedulable: 1
Loop Rolling: latch_quant_tables
Generating tree
Generating MATCH
Match: 
  store i32 51, i32* %msg_code, align 8, !tbaa !15
  store i32 %5, i32* %arrayidx10, align 4, !tbaa !18
Generating ALTSEQ
Values:
i32 51
  %5 = load i32, i32* %quant_tbl_no, align 8, !tbaa !13
Generated Version 4:
  %17 = icmp eq i8 %16, 0
  %18 = select i1 %17, i32 51, i32 %5
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 5
  %arrayidx10 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %19 = select i1 %17, i32* %msg_code, i32* %arrayidx10
Operands done!
Generated:   store i32 %18, i32* %19, align 1
Gen:   store i32 %18, i32* %19, align 1
Graph code generated!
Root:
  store i32 51, i32* %msg_code, align 8, !tbaa !15
  store i32 %5, i32* %arrayidx10, align 4, !tbaa !18
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 51, %5", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx10", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; latch_quant_tables
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %call, i8** %15, align 8, !tbaa !11
Attempting Group:
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 dereferenceable(132) %call, i8* nonnull align 1 dereferenceable(132) %14, i64 132, i1 false)
looking for reduction
Done Loop Roller: 0/1
Optimizing: start_input_pass
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %MCU_width.i, align 4, !tbaa !16
  store i32 1, i32* %MCU_height.i, align 8, !tbaa !17
  store i32 1, i32* %MCU_blocks.i, align 4, !tbaa !18
  store i32 %4, i32* %MCU_sample_width.i, align 8, !tbaa !20
  store i32 1, i32* %last_col_width.i, align 4, !tbaa !21
  store i32 %spec.select.i, i32* %last_row_height.i, align 8, !tbaa !23
Attempting Group:
  store i32 %2, i32* %MCUs_per_row.i, align 8, !tbaa !13
  store i32 %3, i32* %MCU_rows_in_scan.i, align 4, !tbaa !15
  store i32 1, i32* %blocks_in_MCU.i, align 8, !tbaa !24
  store i32 0, i32* %arrayidx5.i, align 4, !tbaa !25
Creating Node
  store i32 1, i32* %MCU_width.i, align 4, !tbaa !16
  store i32 1, i32* %MCU_height.i, align 8, !tbaa !17
  store i32 1, i32* %MCU_blocks.i, align 4, !tbaa !18
  store i32 %4, i32* %MCU_sample_width.i, align 8, !tbaa !20
  store i32 1, i32* %last_col_width.i, align 4, !tbaa !21
  store i32 %spec.select.i, i32* %last_row_height.i, align 8, !tbaa !23
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
i32 1
i32 1
i32 1
  %4 = load i32, i32* %DCT_scaled_size.i, align 4, !tbaa !19
i32 1
  %spec.select.i = select i1 %cmp2.i, i32 %5, i32 %rem.i
Match: 0
3 x 6
Final Match: 0
GEPSeq2
BinOP?
i32 1
Mismatching
Creating Node
  %MCU_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
  %MCU_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
  %MCU_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
  %MCU_sample_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 16
  %last_col_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 17
  %last_row_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 18
Match: 0
6 x 6
Final Match: 0
  %MCU_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
  %MCU_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
  %MCU_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
  %MCU_sample_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 16
  %last_col_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 17
  %last_row_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 18
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %MCU_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
Mismatching
ScheduleNode: {
  store i32 1, i32* %MCU_width.i, align 4, !tbaa !16
}
ScheduleNode: {
  store i32 1, i32* %MCU_height.i, align 8, !tbaa !17
}
ScheduleNode: {
  store i32 1, i32* %MCU_blocks.i, align 4, !tbaa !18
}
ScheduleNode: {
  store i32 %4, i32* %MCU_sample_width.i, align 8, !tbaa !20
}
ScheduleNode: {
  store i32 1, i32* %last_col_width.i, align 4, !tbaa !21
}
ScheduleNode: {
  store i32 %spec.select.i, i32* %last_row_height.i, align 8, !tbaa !23
}
ScheduleNode: {
  store i32 1, i32* %MCU_width.i, align 4, !tbaa !16
}
Count: 1
Start:   store i32 1, i32* %MCU_width.i, align 4, !tbaa !16
Processing:   store i32 1, i32* %MCU_width.i, align 4, !tbaa !16
Count: 1
Found:   store i32 1, i32* %MCU_width.i, align 4, !tbaa !16
ScheduleNode: {
  store i32 1, i32* %MCU_height.i, align 8, !tbaa !17
}
Non-memory:   %MCU_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
Processing:   store i32 1, i32* %MCU_height.i, align 8, !tbaa !17
Count: 1
Found:   store i32 1, i32* %MCU_height.i, align 8, !tbaa !17
ScheduleNode: {
  store i32 1, i32* %MCU_blocks.i, align 4, !tbaa !18
}
Non-memory:   %MCU_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
Processing:   store i32 1, i32* %MCU_blocks.i, align 4, !tbaa !18
Count: 1
Found:   store i32 1, i32* %MCU_blocks.i, align 4, !tbaa !18
ScheduleNode: {
  store i32 %4, i32* %MCU_sample_width.i, align 8, !tbaa !20
}
Non-memory:   %DCT_scaled_size.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 9
Processing:   %4 = load i32, i32* %DCT_scaled_size.i, align 4, !tbaa !19
Count: 1
Not found:   %4 = load i32, i32* %DCT_scaled_size.i, align 4, !tbaa !19
Read/Write memory
I:   %4 = load i32, i32* %DCT_scaled_size.i, align 4, !tbaa !19
Last:   br label %per_scan_setup.exit
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


if.then.i:                                        ; preds = %entry
  %arrayidx.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 63, i64 0
  %1 = load %struct.jpeg_component_info*, %struct.jpeg_component_info** %arrayidx.i, align 8, !tbaa !10
  %width_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 7
  %2 = load i32, i32* %width_in_blocks.i, align 4, !tbaa !11
  %MCUs_per_row.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  store i32 %2, i32* %MCUs_per_row.i, align 8, !tbaa !13
  %height_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 8
  %3 = load i32, i32* %height_in_blocks.i, align 8, !tbaa !14
  %MCU_rows_in_scan.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  store i32 %3, i32* %MCU_rows_in_scan.i, align 4, !tbaa !15
  %MCU_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
  store i32 1, i32* %MCU_width.i, align 4, !tbaa !16
  %MCU_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
  store i32 1, i32* %MCU_height.i, align 8, !tbaa !17
  %MCU_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
  store i32 1, i32* %MCU_blocks.i, align 4, !tbaa !18
  %DCT_scaled_size.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 9
  %4 = load i32, i32* %DCT_scaled_size.i, align 4, !tbaa !19
  %MCU_sample_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 16
  store i32 %4, i32* %MCU_sample_width.i, align 8, !tbaa !20
  %last_col_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 17
  store i32 1, i32* %last_col_width.i, align 4, !tbaa !21
  %v_samp_factor.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 3
  %5 = load i32, i32* %v_samp_factor.i, align 4, !tbaa !22
  %rem.i = urem i32 %3, %5
  %cmp2.i = icmp eq i32 %rem.i, 0
  %spec.select.i = select i1 %cmp2.i, i32 %5, i32 %rem.i
  %last_row_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 18
  store i32 %spec.select.i, i32* %last_row_height.i, align 8, !tbaa !23
  %blocks_in_MCU.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  store i32 1, i32* %blocks_in_MCU.i, align 8, !tbaa !24
  %arrayidx5.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 0
  store i32 0, i32* %arrayidx5.i, align 4, !tbaa !25
  br label %per_scan_setup.exit

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Creating Node
  store i32 %2, i32* %MCUs_per_row.i, align 8, !tbaa !13
  store i32 %3, i32* %MCU_rows_in_scan.i, align 4, !tbaa !15
  store i32 1, i32* %blocks_in_MCU.i, align 8, !tbaa !24
  store i32 0, i32* %arrayidx5.i, align 4, !tbaa !25
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %2 = load i32, i32* %width_in_blocks.i, align 4, !tbaa !11
  %3 = load i32, i32* %height_in_blocks.i, align 8, !tbaa !14
i32 1
i32 0
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %2 = load i32, i32* %width_in_blocks.i, align 4, !tbaa !11
Mismatching
Creating Node
  %MCUs_per_row.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  %MCU_rows_in_scan.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  %blocks_in_MCU.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  %arrayidx5.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 0
Match: 0
4 x 4
Final Match: 0
  %MCUs_per_row.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  %MCU_rows_in_scan.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  %blocks_in_MCU.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  %arrayidx5.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 0
GEPSeq2
BinOP?
  %MCUs_per_row.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
Mismatching
ScheduleNode: {
  store i32 %2, i32* %MCUs_per_row.i, align 8, !tbaa !13
}
ScheduleNode: {
  store i32 %3, i32* %MCU_rows_in_scan.i, align 4, !tbaa !15
}
ScheduleNode: {
  store i32 1, i32* %blocks_in_MCU.i, align 8, !tbaa !24
}
ScheduleNode: {
  store i32 0, i32* %arrayidx5.i, align 4, !tbaa !25
}
ScheduleNode: {
  store i32 %2, i32* %MCUs_per_row.i, align 8, !tbaa !13
}
Count: 1
Start:   store i32 %2, i32* %MCUs_per_row.i, align 8, !tbaa !13
Processing:   store i32 %2, i32* %MCUs_per_row.i, align 8, !tbaa !13
Count: 1
Found:   store i32 %2, i32* %MCUs_per_row.i, align 8, !tbaa !13
ScheduleNode: {
  store i32 %3, i32* %MCU_rows_in_scan.i, align 4, !tbaa !15
}
Non-memory:   %height_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 8
Processing:   %3 = load i32, i32* %height_in_blocks.i, align 8, !tbaa !14
Count: 1
Not found:   %3 = load i32, i32* %height_in_blocks.i, align 8, !tbaa !14
Read/Write memory
I:   %3 = load i32, i32* %height_in_blocks.i, align 8, !tbaa !14
Last:   br label %per_scan_setup.exit
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


if.then.i:                                        ; preds = %entry
  %arrayidx.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 63, i64 0
  %1 = load %struct.jpeg_component_info*, %struct.jpeg_component_info** %arrayidx.i, align 8, !tbaa !10
  %width_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 7
  %2 = load i32, i32* %width_in_blocks.i, align 4, !tbaa !11
  %MCUs_per_row.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  store i32 %2, i32* %MCUs_per_row.i, align 8, !tbaa !13
  %height_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 8
  %3 = load i32, i32* %height_in_blocks.i, align 8, !tbaa !14
  %MCU_rows_in_scan.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  store i32 %3, i32* %MCU_rows_in_scan.i, align 4, !tbaa !15
  %MCU_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 13
  store i32 1, i32* %MCU_width.i, align 4, !tbaa !16
  %MCU_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 14
  store i32 1, i32* %MCU_height.i, align 8, !tbaa !17
  %MCU_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 15
  store i32 1, i32* %MCU_blocks.i, align 4, !tbaa !18
  %DCT_scaled_size.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 9
  %4 = load i32, i32* %DCT_scaled_size.i, align 4, !tbaa !19
  %MCU_sample_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 16
  store i32 %4, i32* %MCU_sample_width.i, align 8, !tbaa !20
  %last_col_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 17
  store i32 1, i32* %last_col_width.i, align 4, !tbaa !21
  %v_samp_factor.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 3
  %5 = load i32, i32* %v_samp_factor.i, align 4, !tbaa !22
  %rem.i = urem i32 %3, %5
  %cmp2.i = icmp eq i32 %rem.i, 0
  %spec.select.i = select i1 %cmp2.i, i32 %5, i32 %rem.i
  %last_row_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %1, i64 0, i32 18
  store i32 %spec.select.i, i32* %last_row_height.i, align 8, !tbaa !23
  %blocks_in_MCU.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  store i32 1, i32* %blocks_in_MCU.i, align 8, !tbaa !24
  %arrayidx5.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 0
  store i32 0, i32* %arrayidx5.i, align 4, !tbaa !25
  br label %per_scan_setup.exit

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 4, i32* %arrayidx17.i, align 4, !tbaa !30
Attempting Group:
  store i32 24, i32* %msg_code.i, align 8, !tbaa !27
  store i32 %0, i32* %arrayidx13.i, align 4, !tbaa !30
Creating Node
  store i32 24, i32* %msg_code.i, align 8, !tbaa !27
  store i32 %0, i32* %arrayidx13.i, align 4, !tbaa !30
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 24
  %0 = load i32, i32* %comps_in_scan.i, align 8, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 24
Alt Seq
Creating Node
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 5
  %arrayidx13.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 5
  %arrayidx13.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 24, i32* %msg_code.i, align 8, !tbaa !27
}
ScheduleNode: {
  store i32 %0, i32* %arrayidx13.i, align 4, !tbaa !30
}
ScheduleNode: {
  store i32 24, i32* %msg_code.i, align 8, !tbaa !27
}
Count: 1
Start:   store i32 24, i32* %msg_code.i, align 8, !tbaa !27
Processing:   store i32 24, i32* %msg_code.i, align 8, !tbaa !27
Count: 1
Found:   store i32 24, i32* %msg_code.i, align 8, !tbaa !27
ScheduleNode: {
  store i32 %0, i32* %arrayidx13.i, align 4, !tbaa !30
}
Non-memory:   %arrayidx13.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %0, i32* %arrayidx13.i, align 4, !tbaa !30
Count: 1
Found:   store i32 %0, i32* %arrayidx13.i, align 4, !tbaa !30
I:   %8 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i, align 8, !tbaa !26
Last:   br label %if.end19.i
Schedulable: 1
Loop Rolling: start_input_pass
Generating tree
Generating MATCH
Match: 
  store i32 24, i32* %msg_code.i, align 8, !tbaa !27
  store i32 %0, i32* %arrayidx13.i, align 4, !tbaa !30
Generating ALTSEQ
Values:
i32 24
  %0 = load i32, i32* %comps_in_scan.i, align 8, !tbaa !2
Generated Version 4:
  %56 = icmp eq i8 %55, 0
  %57 = select i1 %56, i32 24, i32 %0
Generating ALTSEQ
Values:
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 5
  %arrayidx13.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %7, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %58 = select i1 %56, i32* %msg_code.i, i32* %arrayidx13.i
Operands done!
Generated:   store i32 %57, i32* %58, align 1
Gen:   store i32 %57, i32* %58, align 1
Graph code generated!
Root:
  store i32 24, i32* %msg_code.i, align 8, !tbaa !27
  store i32 %0, i32* %arrayidx13.i, align 4, !tbaa !30
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 24, %0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code.i, %arrayidx13.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; start_input_pass
Trying AGAIN
Trying AGAIN
  %.pre-phi.i = phi %struct.jpeg_common_struct* [ %.pre.i, %if.else.if.end19_crit_edge.i ], [ %11, %if.then10.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %conv21.i, i32* %MCUs_per_row22.i, align 8, !tbaa !13
  store i32 %conv27.i, i32* %MCU_rows_in_scan28.i, align 4, !tbaa !15
  store i32 0, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
Attempting Group:
  %call.i = tail call i64 @jdiv_round_up(i64 %conv.i, i64 %conv20.i) #3
  %call26.i = tail call i64 @jdiv_round_up(i64 %conv23.i, i64 %conv25.i) #3
Creating Node
  store i32 %conv21.i, i32* %MCUs_per_row22.i, align 8, !tbaa !13
  store i32 %conv27.i, i32* %MCU_rows_in_scan28.i, align 4, !tbaa !15
  store i32 0, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
Match: 1
3 x 3
Final Match: 1
Matching
Creating Node
  %conv21.i = trunc i64 %call.i to i32
  %conv27.i = trunc i64 %call26.i to i32
i32 0
Match: 0
3 x 3
Final Match: 0
GEPSeq2
BinOP?
  %conv21.i = trunc i64 %call.i to i32
Mismatching
Creating Node
  %MCUs_per_row22.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  %MCU_rows_in_scan28.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  %blocks_in_MCU29.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
Match: 0
3 x 3
Final Match: 0
  %MCUs_per_row22.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  %MCU_rows_in_scan28.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  %blocks_in_MCU29.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %MCUs_per_row22.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
Mismatching
ScheduleNode: {
  store i32 %conv21.i, i32* %MCUs_per_row22.i, align 8, !tbaa !13
}
ScheduleNode: {
  store i32 %conv27.i, i32* %MCU_rows_in_scan28.i, align 4, !tbaa !15
}
ScheduleNode: {
  store i32 0, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
}
ScheduleNode: {
  store i32 %conv21.i, i32* %MCUs_per_row22.i, align 8, !tbaa !13
}
Count: 1
Start:   store i32 %conv21.i, i32* %MCUs_per_row22.i, align 8, !tbaa !13
Processing:   store i32 %conv21.i, i32* %MCUs_per_row22.i, align 8, !tbaa !13
Count: 1
Found:   store i32 %conv21.i, i32* %MCUs_per_row22.i, align 8, !tbaa !13
ScheduleNode: {
  store i32 %conv27.i, i32* %MCU_rows_in_scan28.i, align 4, !tbaa !15
}
Non-memory:   %image_height.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
Processing:   %14 = load i32, i32* %image_height.i, align 4, !tbaa !34
Count: 1
Not found:   %14 = load i32, i32* %image_height.i, align 4, !tbaa !34
Read/Write memory
I:   %14 = load i32, i32* %image_height.i, align 4, !tbaa !34
Last:   br label %for.cond.i
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


if.end19.i:                                       ; preds = %if.then10.i, %if.else.if.end19_crit_edge.i
  %.pre-phi.i = phi %struct.jpeg_common_struct* [ %.pre.i, %if.else.if.end19_crit_edge.i ], [ %11, %if.then10.i ]
  %image_width.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %12 = load i32, i32* %image_width.i, align 8, !tbaa !32
  %conv.i = zext i32 %12 to i64
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %13 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !33
  %mul.i = shl nsw i32 %13, 3
  %conv20.i = sext i32 %mul.i to i64
  %call.i = tail call i64 @jdiv_round_up(i64 %conv.i, i64 %conv20.i) #3
  %conv21.i = trunc i64 %call.i to i32
  %MCUs_per_row22.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  store i32 %conv21.i, i32* %MCUs_per_row22.i, align 8, !tbaa !13
  %image_height.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
  %14 = load i32, i32* %image_height.i, align 4, !tbaa !34
  %conv23.i = zext i32 %14 to i64
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
  %15 = load i32, i32* %max_v_samp_factor.i, align 8, !tbaa !35
  %mul24.i = shl nsw i32 %15, 3
  %conv25.i = sext i32 %mul24.i to i64
  %call26.i = tail call i64 @jdiv_round_up(i64 %conv23.i, i64 %conv25.i) #3
  %conv27.i = trunc i64 %call26.i to i32
  %MCU_rows_in_scan28.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  store i32 %conv27.i, i32* %MCU_rows_in_scan28.i, align 4, !tbaa !15
  %blocks_in_MCU29.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  store i32 0, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
  %err69.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 0
  br label %for.cond.i

Trying AGAIN
Trying AGAIN
Trying AGAIN
Creating Node
  %call.i = tail call i64 @jdiv_round_up(i64 %conv.i, i64 %conv20.i) #3
  %call26.i = tail call i64 @jdiv_round_up(i64 %conv23.i, i64 %conv25.i) #3
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv.i = zext i32 %12 to i64
  %conv23.i = zext i32 %14 to i64
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %12 = load i32, i32* %image_width.i, align 8, !tbaa !32
  %14 = load i32, i32* %image_height.i, align 4, !tbaa !34
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %image_width.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %image_height.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
Match: 0
2 x 2
Final Match: 0
  %image_width.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %image_height.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %image_width.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
Alt Seq
Creating Node
  %conv20.i = sext i32 %mul.i to i64
  %conv25.i = sext i32 %mul24.i to i64
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %mul.i = shl nsw i32 %13, 3
  %mul24.i = shl nsw i32 %15, 3
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %13 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !33
  %15 = load i32, i32* %max_v_samp_factor.i, align 8, !tbaa !35
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
Match: 0
2 x 2
Final Match: 0
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
Alt Seq
Creating Node
i32 3
i32 3
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
Function: jdiv_round_up
Function: jdiv_round_up
Match: 1
1 x 2
Final Match: 1
All the Same
ScheduleNode: {
  %12 = load i32, i32* %image_width.i, align 8, !tbaa !32
  %13 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !33
}
ScheduleNode: {
  %call.i = tail call i64 @jdiv_round_up(i64 %conv.i, i64 %conv20.i) #3
}
ScheduleNode: {
  %14 = load i32, i32* %image_height.i, align 4, !tbaa !34
  %15 = load i32, i32* %max_v_samp_factor.i, align 8, !tbaa !35
}
ScheduleNode: {
  %call26.i = tail call i64 @jdiv_round_up(i64 %conv23.i, i64 %conv25.i) #3
}
ScheduleNode: {
  %12 = load i32, i32* %image_width.i, align 8, !tbaa !32
  %13 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !33
}
Count: 2
Start:   %12 = load i32, i32* %image_width.i, align 8, !tbaa !32
Processing:   %12 = load i32, i32* %image_width.i, align 8, !tbaa !32
Count: 2
Found:   %12 = load i32, i32* %image_width.i, align 8, !tbaa !32
Non-memory:   %conv.i = zext i32 %12 to i64
Non-memory:   %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
Processing:   %13 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !33
Count: 1
Found:   %13 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !33
ScheduleNode: {
  %call.i = tail call i64 @jdiv_round_up(i64 %conv.i, i64 %conv20.i) #3
}
Non-memory:   %mul.i = shl nsw i32 %13, 3
Non-memory:   %conv20.i = sext i32 %mul.i to i64
Processing:   %call.i = tail call i64 @jdiv_round_up(i64 %conv.i, i64 %conv20.i) #3
Count: 1
Found:   %call.i = tail call i64 @jdiv_round_up(i64 %conv.i, i64 %conv20.i) #3
ScheduleNode: {
  %14 = load i32, i32* %image_height.i, align 4, !tbaa !34
  %15 = load i32, i32* %max_v_samp_factor.i, align 8, !tbaa !35
}
Non-memory:   %conv21.i = trunc i64 %call.i to i32
Non-memory:   %MCUs_per_row22.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
Processing:   store i32 %conv21.i, i32* %MCUs_per_row22.i, align 8, !tbaa !13
Count: 2
Not found:   store i32 %conv21.i, i32* %MCUs_per_row22.i, align 8, !tbaa !13
Read/Write memory
I:   store i32 %conv21.i, i32* %MCUs_per_row22.i, align 8, !tbaa !13
Last:   br label %for.cond.i
Schedulable: 0
digraph VTree {
0 [label="call: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %image_width.i, %image_height.i", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="shl", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %max_h_samp_factor.i, %max_v_samp_factor.i", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="3", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="func: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
9->0 
2->1 
3->2 
5->4 
6->5 
8->5 
7->6 
10 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->10
11 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->11
}


if.end19.i:                                       ; preds = %if.then10.i, %if.else.if.end19_crit_edge.i
  %.pre-phi.i = phi %struct.jpeg_common_struct* [ %.pre.i, %if.else.if.end19_crit_edge.i ], [ %11, %if.then10.i ]
  %image_width.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %12 = load i32, i32* %image_width.i, align 8, !tbaa !32
  %conv.i = zext i32 %12 to i64
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %13 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !33
  %mul.i = shl nsw i32 %13, 3
  %conv20.i = sext i32 %mul.i to i64
  %call.i = tail call i64 @jdiv_round_up(i64 %conv.i, i64 %conv20.i) #3
  %conv21.i = trunc i64 %call.i to i32
  %MCUs_per_row22.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 64
  store i32 %conv21.i, i32* %MCUs_per_row22.i, align 8, !tbaa !13
  %image_height.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
  %14 = load i32, i32* %image_height.i, align 4, !tbaa !34
  %conv23.i = zext i32 %14 to i64
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
  %15 = load i32, i32* %max_v_samp_factor.i, align 8, !tbaa !35
  %mul24.i = shl nsw i32 %15, 3
  %conv25.i = sext i32 %mul24.i to i64
  %call26.i = tail call i64 @jdiv_round_up(i64 %conv23.i, i64 %conv25.i) #3
  %conv27.i = trunc i64 %call26.i to i32
  %MCU_rows_in_scan28.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 65
  store i32 %conv27.i, i32* %MCU_rows_in_scan28.i, align 4, !tbaa !15
  %blocks_in_MCU29.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  store i32 0, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
  %err69.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 0
  br label %for.cond.i

  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.inc.i ], [ 0, %if.end19.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul40.i = mul nsw i32 %20, %19
looking for reduction
  %mul44.i = mul nsw i32 %21, %19
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %19, i32* %MCU_width35.i, align 4, !tbaa !16
  store i32 %20, i32* %MCU_height37.i, align 8, !tbaa !17
  store i32 %mul40.i, i32* %MCU_blocks41.i, align 4, !tbaa !18
  store i32 %mul44.i, i32* %MCU_sample_width45.i, align 8, !tbaa !20
  store i32 %spec.select153.i, i32* %last_col_width54.i, align 4, !tbaa !21
  store i32 %tmp.2.i, i32* %last_row_height63.i, align 8, !tbaa !23
Creating Node
  store i32 %19, i32* %MCU_width35.i, align 4, !tbaa !16
  store i32 %20, i32* %MCU_height37.i, align 8, !tbaa !17
  store i32 %mul40.i, i32* %MCU_blocks41.i, align 4, !tbaa !18
  store i32 %mul44.i, i32* %MCU_sample_width45.i, align 8, !tbaa !20
  store i32 %spec.select153.i, i32* %last_col_width54.i, align 4, !tbaa !21
  store i32 %tmp.2.i, i32* %last_row_height63.i, align 8, !tbaa !23
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
  %19 = load i32, i32* %h_samp_factor.i, align 8, !tbaa !36
  %20 = load i32, i32* %v_samp_factor36.i, align 4, !tbaa !22
  %mul40.i = mul nsw i32 %20, %19
  %mul44.i = mul nsw i32 %21, %19
  %spec.select153.i = select i1 %cmp49.i, i32 %19, i32 %rem48.i
  %tmp.2.i = select i1 %cmp58.i, i32 %20, i32 %rem57.i
Match: 0
6 x 6
Final Match: 0
GEPSeq2
BinOP?
  %19 = load i32, i32* %h_samp_factor.i, align 8, !tbaa !36
BinOp Seq
Creating Node
  %19 = load i32, i32* %h_samp_factor.i, align 8, !tbaa !36
  %20 = load i32, i32* %v_samp_factor36.i, align 4, !tbaa !22
  %20 = load i32, i32* %v_samp_factor36.i, align 4, !tbaa !22
  %21 = load i32, i32* %DCT_scaled_size43.i, align 4, !tbaa !19
  %spec.select153.i = select i1 %cmp49.i, i32 %19, i32 %rem48.i
  %tmp.2.i = select i1 %cmp58.i, i32 %20, i32 %rem57.i
Match: 0
5 x 6
Final Match: 0
GEPSeq2
BinOP?
  %19 = load i32, i32* %h_samp_factor.i, align 8, !tbaa !36
Mismatching
Creating Node
i32 1
i32 1
  %19 = load i32, i32* %h_samp_factor.i, align 8, !tbaa !36
  %19 = load i32, i32* %h_samp_factor.i, align 8, !tbaa !36
i32 1
i32 1
Match: 0
2 x 6
Final Match: 0
GEPSeq2
BinOP?
i32 1
Mismatching
Creating Node
  %MCU_width35.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 13
  %MCU_height37.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 14
  %MCU_blocks41.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 15
  %MCU_sample_width45.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 16
  %last_col_width54.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 17
  %last_row_height63.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 18
Match: 0
6 x 6
Final Match: 0
  %MCU_width35.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 13
  %MCU_height37.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 14
  %MCU_blocks41.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 15
  %MCU_sample_width45.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 16
  %last_col_width54.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 17
  %last_row_height63.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 18
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %MCU_width35.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 13
Mismatching
ScheduleNode: {
  store i32 %19, i32* %MCU_width35.i, align 4, !tbaa !16
}
ScheduleNode: {
  store i32 %20, i32* %MCU_height37.i, align 8, !tbaa !17
}
ScheduleNode: {
  store i32 %mul40.i, i32* %MCU_blocks41.i, align 4, !tbaa !18
}
ScheduleNode: {
  store i32 %mul44.i, i32* %MCU_sample_width45.i, align 8, !tbaa !20
}
ScheduleNode: {
  store i32 %spec.select153.i, i32* %last_col_width54.i, align 4, !tbaa !21
}
ScheduleNode: {
  store i32 %tmp.2.i, i32* %last_row_height63.i, align 8, !tbaa !23
}
ScheduleNode: {
  store i32 %19, i32* %MCU_width35.i, align 4, !tbaa !16
}
Count: 1
Start:   store i32 %19, i32* %MCU_width35.i, align 4, !tbaa !16
Processing:   store i32 %19, i32* %MCU_width35.i, align 4, !tbaa !16
Count: 1
Found:   store i32 %19, i32* %MCU_width35.i, align 4, !tbaa !16
ScheduleNode: {
  store i32 %20, i32* %MCU_height37.i, align 8, !tbaa !17
}
Non-memory:   %v_samp_factor36.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 3
Processing:   %20 = load i32, i32* %v_samp_factor36.i, align 4, !tbaa !22
Count: 1
Not found:   %20 = load i32, i32* %v_samp_factor36.i, align 4, !tbaa !22
Read/Write memory
I:   %20 = load i32, i32* %v_samp_factor36.i, align 4, !tbaa !22
Last:   br i1 %cmp66.i, label %if.then68.i, label %if.end73.i
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mul seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
3 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
4 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
4->0 
2->1 
3->1 
5 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
1->5
}


for.body.i:                                       ; preds = %for.cond.i
  %arrayidx34.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 63, i64 %indvars.iv.i
  %18 = load %struct.jpeg_component_info*, %struct.jpeg_component_info** %arrayidx34.i, align 8, !tbaa !10
  %h_samp_factor.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 2
  %19 = load i32, i32* %h_samp_factor.i, align 8, !tbaa !36
  %MCU_width35.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 13
  store i32 %19, i32* %MCU_width35.i, align 4, !tbaa !16
  %v_samp_factor36.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 3
  %20 = load i32, i32* %v_samp_factor36.i, align 4, !tbaa !22
  %MCU_height37.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 14
  store i32 %20, i32* %MCU_height37.i, align 8, !tbaa !17
  %mul40.i = mul nsw i32 %20, %19
  %MCU_blocks41.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 15
  store i32 %mul40.i, i32* %MCU_blocks41.i, align 4, !tbaa !18
  %DCT_scaled_size43.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 9
  %21 = load i32, i32* %DCT_scaled_size43.i, align 4, !tbaa !19
  %mul44.i = mul nsw i32 %21, %19
  %MCU_sample_width45.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 16
  store i32 %mul44.i, i32* %MCU_sample_width45.i, align 8, !tbaa !20
  %width_in_blocks46.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 7
  %22 = load i32, i32* %width_in_blocks46.i, align 4, !tbaa !11
  %rem48.i = urem i32 %22, %19
  %cmp49.i = icmp eq i32 %rem48.i, 0
  %spec.select153.i = select i1 %cmp49.i, i32 %19, i32 %rem48.i
  %last_col_width54.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 17
  store i32 %spec.select153.i, i32* %last_col_width54.i, align 4, !tbaa !21
  %height_in_blocks55.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 8
  %23 = load i32, i32* %height_in_blocks55.i, align 8, !tbaa !14
  %rem57.i = urem i32 %23, %20
  %cmp58.i = icmp eq i32 %rem57.i, 0
  %tmp.2.i = select i1 %cmp58.i, i32 %20, i32 %rem57.i
  %last_row_height63.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %18, i64 0, i32 18
  store i32 %tmp.2.i, i32* %last_row_height63.i, align 8, !tbaa !23
  %24 = load i32, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
  %add.i = add nsw i32 %24, %mul40.i
  %cmp66.i = icmp sgt i32 %add.i, 10
  br i1 %cmp66.i, label %if.then68.i, label %if.end73.i

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
Attempting Group:
  store i32 11, i32* %msg_code70.i, align 8, !tbaa !27
  %mcublks.0.i = phi i32 [ %mul40.i, %if.end73.i ], [ %dec.i, %while.body.i ]
looking for reduction
looking for reduction
  %inc.i = add nsw i32 %28, 1
looking for reduction
Attempting Group:
  store i32 %inc.i, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
  store i32 %27, i32* %arrayidx79.i, align 4, !tbaa !25
Creating Node
  store i32 %inc.i, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
  store i32 %27, i32* %arrayidx79.i, align 4, !tbaa !25
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %inc.i = add nsw i32 %28, 1
  %27 = trunc i64 %indvars.iv.i to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %inc.i = add nsw i32 %28, 1
BinOp Seq
Creating Node
  %28 = load i32, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
  %27 = trunc i64 %indvars.iv.i to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %28 = load i32, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
Alt Seq
Creating Node
i32 1
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
  %blocks_in_MCU29.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  %arrayidx79.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 %idxprom78.i
Match: 0
2 x 2
Final Match: 0
  %blocks_in_MCU29.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  %arrayidx79.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 %idxprom78.i
GEPSeq2
BinOP?
  %blocks_in_MCU29.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
Alt Seq
ScheduleNode: {
  store i32 %inc.i, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
}
ScheduleNode: {
  store i32 %27, i32* %arrayidx79.i, align 4, !tbaa !25
}
ScheduleNode: {
  store i32 %inc.i, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
}
Count: 1
Start:   %inc.i = add nsw i32 %28, 1
Non-memory:   %inc.i = add nsw i32 %28, 1
Processing:   store i32 %inc.i, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
Count: 1
Found:   store i32 %inc.i, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
ScheduleNode: {
  store i32 %27, i32* %arrayidx79.i, align 4, !tbaa !25
}
Non-memory:   %idxprom78.i = sext i32 %28 to i64
Non-memory:   %arrayidx79.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 %idxprom78.i
Processing:   store i32 %27, i32* %arrayidx79.i, align 4, !tbaa !25
Count: 1
Found:   store i32 %27, i32* %arrayidx79.i, align 4, !tbaa !25
I:   br label %while.cond.i, !llvm.loop !37
Last:   br label %while.cond.i, !llvm.loop !37
Schedulable: 1
Loop Rolling: start_input_pass
Generating tree
Generating MATCH
Match: 
  store i32 %inc.i, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
  store i32 %27, i32* %arrayidx79.i, align 4, !tbaa !25
Generating BINOP
Generating ALTSEQ
Values:
  %28 = load i32, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
  %27 = trunc i64 %indvars.iv.i to i32
Generated Version 4:
  %56 = icmp eq i8 %55, 0
  %57 = select i1 %56, i32 %28, i32 %27
Generating INTSEQ
Gen:   %60 = add i32 %59, 1
Closing BINOP
Gen:   %61 = add nsw i32 %57, %60
Generating ALTSEQ
Values:
  %blocks_in_MCU29.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 66
  %arrayidx79.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 67, i64 %idxprom78.i
Generated Version 4:
  %62 = select i1 %56, i32* %blocks_in_MCU29.i, i32* %arrayidx79.i
Operands done!
Generated:   store i32 %61, i32* %62, align 1
Gen:   store i32 %61, i32* %62, align 1
Graph code generated!
Root:
  store i32 %inc.i, i32* %blocks_in_MCU29.i, align 8, !tbaa !24
  store i32 %27, i32* %arrayidx79.i, align 4, !tbaa !25
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %28, %27", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="1..0, -1", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %blocks_in_MCU29.i, %arrayidx79.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->1 
}

Gains: 6 - 12 = -6; Width: 2; Unprofitable; start_input_pass
Trying AGAIN
Trying AGAIN
  %.lcssa = phi i32 [ %16, %for.cond.i ]
  %29 = phi i32 [ 1, %if.then.i ], [ %.lcssa, %per_scan_setup.exit.loopexit ]
  %31 = phi i32 [ %.pre, %for.inc.i22 ], [ %29, %per_scan_setup.exit ]
  %indvars.iv.i13 = phi i64 [ %indvars.iv.next.i21, %for.inc.i22 ], [ 0, %per_scan_setup.exit ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 51, i32* %msg_code.i18, align 8, !tbaa !27
  store i32 %35, i32* %arrayidx10.i, align 4, !tbaa !30
Creating Node
  store i32 51, i32* %msg_code.i18, align 8, !tbaa !27
  store i32 %35, i32* %arrayidx10.i, align 4, !tbaa !30
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 51
  %35 = load i32, i32* %quant_tbl_no.i, align 8, !tbaa !41
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 51
Alt Seq
Creating Node
  %msg_code.i18 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %38, i64 0, i32 5
  %arrayidx10.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %38, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code.i18 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %38, i64 0, i32 5
  %arrayidx10.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %38, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code.i18 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %38, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 51, i32* %msg_code.i18, align 8, !tbaa !27
}
ScheduleNode: {
  store i32 %35, i32* %arrayidx10.i, align 4, !tbaa !30
}
ScheduleNode: {
  store i32 51, i32* %msg_code.i18, align 8, !tbaa !27
}
Count: 1
Start:   store i32 51, i32* %msg_code.i18, align 8, !tbaa !27
Processing:   store i32 51, i32* %msg_code.i18, align 8, !tbaa !27
Count: 1
Found:   store i32 51, i32* %msg_code.i18, align 8, !tbaa !27
ScheduleNode: {
  store i32 %35, i32* %arrayidx10.i, align 4, !tbaa !30
}
Non-memory:   %arrayidx10.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %38, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %35, i32* %arrayidx10.i, align 4, !tbaa !30
Count: 1
Found:   store i32 %35, i32* %arrayidx10.i, align 4, !tbaa !30
I:   %39 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i12, align 8, !tbaa !26
Last:   br label %if.end12.i
Schedulable: 1
Loop Rolling: start_input_pass
Generating tree
Generating MATCH
Match: 
  store i32 51, i32* %msg_code.i18, align 8, !tbaa !27
  store i32 %35, i32* %arrayidx10.i, align 4, !tbaa !30
Generating ALTSEQ
Values:
i32 51
  %35 = load i32, i32* %quant_tbl_no.i, align 8, !tbaa !41
Generated Version 4:
  %56 = icmp eq i8 %55, 0
  %57 = select i1 %56, i32 51, i32 %35
Generating ALTSEQ
Values:
  %msg_code.i18 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %38, i64 0, i32 5
  %arrayidx10.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %38, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %58 = select i1 %56, i32* %msg_code.i18, i32* %arrayidx10.i
Operands done!
Generated:   store i32 %57, i32* %58, align 1
Gen:   store i32 %57, i32* %58, align 1
Graph code generated!
Root:
  store i32 51, i32* %msg_code.i18, align 8, !tbaa !27
  store i32 %35, i32* %arrayidx10.i, align 4, !tbaa !30
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 51, %35", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code.i18, %arrayidx10.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; start_input_pass
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8* %call.i20, i8** %45, align 8, !tbaa !40
Attempting Group:
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 dereferenceable(132) %call.i20, i8* nonnull align 1 dereferenceable(132) %44, i64 132, i1 false) #4
  %.pre = phi i32 [ %.pre.pre, %if.end12.i ], [ %31, %for.body.i17 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 (%struct.jpeg_decompress_struct*)* %53, i32 (%struct.jpeg_decompress_struct*)** %consume_input, align 8, !tbaa !54
Done Loop Roller: 0/3
Optimizing: consume_markers
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 40, i32* %msg_code.i, align 8, !tbaa !20
  store i32 65500, i32* %arrayidx.i, align 4, !tbaa !23
Creating Node
  store i32 40, i32* %msg_code.i, align 8, !tbaa !20
  store i32 65500, i32* %arrayidx.i, align 4, !tbaa !23
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 40
i32 65500
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 40
Int Seq
Creating Node
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 5
  %arrayidx.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 5
  %arrayidx.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 40, i32* %msg_code.i, align 8, !tbaa !20
}
ScheduleNode: {
  store i32 65500, i32* %arrayidx.i, align 4, !tbaa !23
}
ScheduleNode: {
  store i32 40, i32* %msg_code.i, align 8, !tbaa !20
}
Count: 1
Start:   store i32 40, i32* %msg_code.i, align 8, !tbaa !20
Processing:   store i32 40, i32* %msg_code.i, align 8, !tbaa !20
Count: 1
Found:   store i32 40, i32* %msg_code.i, align 8, !tbaa !20
ScheduleNode: {
  store i32 65500, i32* %arrayidx.i, align 4, !tbaa !23
}
Non-memory:   %arrayidx.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 65500, i32* %arrayidx.i, align 4, !tbaa !23
Count: 1
Found:   store i32 65500, i32* %arrayidx.i, align 4, !tbaa !23
I:   %9 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err.i, align 8, !tbaa !19
Last:   br label %if.end.i
Schedulable: 1
Loop Rolling: consume_markers
Generating tree
Generating MATCH
Match: 
  store i32 40, i32* %msg_code.i, align 8, !tbaa !20
  store i32 65500, i32* %arrayidx.i, align 4, !tbaa !23
Generating INTSEQ
Gen:   %73 = add i32 %72, 40
Generating ALTSEQ
Values:
  %msg_code.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 5
  %arrayidx.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %74 = icmp eq i8 %70, 0
  %75 = select i1 %74, i32* %msg_code.i, i32* %arrayidx.i
Operands done!
Generated:   store i32 %73, i32* %75, align 1
Gen:   store i32 %73, i32* %75, align 1
Graph code generated!
Root:
  store i32 40, i32* %msg_code.i, align 8, !tbaa !20
  store i32 65500, i32* %arrayidx.i, align 4, !tbaa !23
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="40..65500, 65460", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code.i, %arrayidx.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; consume_markers
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 13, i32* %msg_code11.i, align 8, !tbaa !20
  store i32 %12, i32* %arrayidx16.i, align 4, !tbaa !23
Creating Node
  store i32 13, i32* %msg_code11.i, align 8, !tbaa !20
  store i32 %12, i32* %arrayidx16.i, align 4, !tbaa !23
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 13
  %12 = load i32, i32* %data_precision.i, align 8, !tbaa !25
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 13
Alt Seq
Creating Node
  %msg_code11.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 5
  %arrayidx16.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code11.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 5
  %arrayidx16.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code11.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 13, i32* %msg_code11.i, align 8, !tbaa !20
}
ScheduleNode: {
  store i32 %12, i32* %arrayidx16.i, align 4, !tbaa !23
}
ScheduleNode: {
  store i32 13, i32* %msg_code11.i, align 8, !tbaa !20
}
Count: 1
Start:   store i32 13, i32* %msg_code11.i, align 8, !tbaa !20
Processing:   store i32 13, i32* %msg_code11.i, align 8, !tbaa !20
Count: 1
Found:   store i32 13, i32* %msg_code11.i, align 8, !tbaa !20
ScheduleNode: {
  store i32 %12, i32* %arrayidx16.i, align 4, !tbaa !23
}
Non-memory:   %arrayidx16.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %12, i32* %arrayidx16.i, align 4, !tbaa !23
Count: 1
Found:   store i32 %12, i32* %arrayidx16.i, align 4, !tbaa !23
I:   %14 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err10.i, align 8, !tbaa !19
Last:   br label %if.end19.i
Schedulable: 1
Loop Rolling: consume_markers
Generating tree
Generating MATCH
Match: 
  store i32 13, i32* %msg_code11.i, align 8, !tbaa !20
  store i32 %12, i32* %arrayidx16.i, align 4, !tbaa !23
Generating ALTSEQ
Values:
i32 13
  %12 = load i32, i32* %data_precision.i, align 8, !tbaa !25
Generated Version 4:
  %71 = icmp eq i8 %70, 0
  %72 = select i1 %71, i32 13, i32 %12
Generating ALTSEQ
Values:
  %msg_code11.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 5
  %arrayidx16.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %13, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %73 = select i1 %71, i32* %msg_code11.i, i32* %arrayidx16.i
Operands done!
Generated:   store i32 %72, i32* %73, align 1
Gen:   store i32 %72, i32* %73, align 1
Graph code generated!
Root:
  store i32 13, i32* %msg_code11.i, align 8, !tbaa !20
  store i32 %12, i32* %arrayidx16.i, align 4, !tbaa !23
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 13, %12", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code11.i, %arrayidx16.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; consume_markers
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 10, i32* %arrayidx33.i, align 4, !tbaa !23
Attempting Group:
  store i32 24, i32* %msg_code24.i, align 8, !tbaa !20
  store i32 %17, i32* %arrayidx29.i, align 4, !tbaa !23
Creating Node
  store i32 24, i32* %msg_code24.i, align 8, !tbaa !20
  store i32 %17, i32* %arrayidx29.i, align 4, !tbaa !23
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 24
  %17 = load i32, i32* %num_components.i, align 8, !tbaa !26
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 24
Alt Seq
Creating Node
  %msg_code24.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %18, i64 0, i32 5
  %arrayidx29.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %18, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code24.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %18, i64 0, i32 5
  %arrayidx29.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %18, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code24.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %18, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 24, i32* %msg_code24.i, align 8, !tbaa !20
}
ScheduleNode: {
  store i32 %17, i32* %arrayidx29.i, align 4, !tbaa !23
}
ScheduleNode: {
  store i32 24, i32* %msg_code24.i, align 8, !tbaa !20
}
Count: 1
Start:   store i32 24, i32* %msg_code24.i, align 8, !tbaa !20
Processing:   store i32 24, i32* %msg_code24.i, align 8, !tbaa !20
Count: 1
Found:   store i32 24, i32* %msg_code24.i, align 8, !tbaa !20
ScheduleNode: {
  store i32 %17, i32* %arrayidx29.i, align 4, !tbaa !23
}
Non-memory:   %arrayidx29.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %18, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %17, i32* %arrayidx29.i, align 4, !tbaa !23
Count: 1
Found:   store i32 %17, i32* %arrayidx29.i, align 4, !tbaa !23
I:   %19 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err23.i, align 8, !tbaa !19
Last:   br label %if.end36.i
Schedulable: 1
Loop Rolling: consume_markers
Generating tree
Generating MATCH
Match: 
  store i32 24, i32* %msg_code24.i, align 8, !tbaa !20
  store i32 %17, i32* %arrayidx29.i, align 4, !tbaa !23
Generating ALTSEQ
Values:
i32 24
  %17 = load i32, i32* %num_components.i, align 8, !tbaa !26
Generated Version 4:
  %71 = icmp eq i8 %70, 0
  %72 = select i1 %71, i32 24, i32 %17
Generating ALTSEQ
Values:
  %msg_code24.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %18, i64 0, i32 5
  %arrayidx29.i = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %18, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %73 = select i1 %71, i32* %msg_code24.i, i32* %arrayidx29.i
Operands done!
Generated:   store i32 %72, i32* %73, align 1
Gen:   store i32 %72, i32* %73, align 1
Graph code generated!
Root:
  store i32 24, i32* %msg_code24.i, align 8, !tbaa !20
  store i32 %17, i32* %arrayidx29.i, align 4, !tbaa !23
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 24, %17", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code24.i, %arrayidx29.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; consume_markers
Trying AGAIN
Trying AGAIN
  %.pre-phi.i = phi %struct.jpeg_common_struct* [ %.pre224.i, %if.end19.if.end36_crit_edge.i ], [ %22, %if.then22.i ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %max_h_samp_factor.i, align 4, !tbaa !27
  store i32 1, i32* %max_v_samp_factor.i, align 8, !tbaa !28
Creating Node
  store i32 1, i32* %max_h_samp_factor.i, align 4, !tbaa !27
  store i32 1, i32* %max_v_samp_factor.i, align 8, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 1
i32 1
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
Match: 0
2 x 2
Final Match: 0
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
Alt Seq
ScheduleNode: {
  store i32 1, i32* %max_h_samp_factor.i, align 4, !tbaa !27
}
ScheduleNode: {
  store i32 1, i32* %max_v_samp_factor.i, align 8, !tbaa !28
}
ScheduleNode: {
  store i32 1, i32* %max_h_samp_factor.i, align 4, !tbaa !27
}
Count: 1
Start:   store i32 1, i32* %max_h_samp_factor.i, align 4, !tbaa !27
Processing:   store i32 1, i32* %max_h_samp_factor.i, align 4, !tbaa !27
Count: 1
Found:   store i32 1, i32* %max_h_samp_factor.i, align 4, !tbaa !27
ScheduleNode: {
  store i32 1, i32* %max_v_samp_factor.i, align 8, !tbaa !28
}
Non-memory:   %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
Processing:   store i32 1, i32* %max_v_samp_factor.i, align 8, !tbaa !28
Count: 1
Found:   store i32 1, i32* %max_v_samp_factor.i, align 8, !tbaa !28
I:   %comp_info.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 43
Last:   br label %for.cond.i
Schedulable: 1
Loop Rolling: consume_markers
Generating tree
Generating MATCH
Match: 
  store i32 1, i32* %max_h_samp_factor.i, align 4, !tbaa !27
  store i32 1, i32* %max_v_samp_factor.i, align 8, !tbaa !28
Generating IDENTICAL
Generating ALTSEQ
Values:
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
Generated Version 4:
  %71 = icmp eq i8 %70, 0
  %72 = select i1 %71, i32* %max_h_samp_factor.i, i32* %max_v_samp_factor.i
Operands done!
Generated:   store i32 1, i32* %72, align 1
Gen:   store i32 1, i32* %72, align 1
Graph code generated!
Root:
  store i32 1, i32* %max_h_samp_factor.i, align 4, !tbaa !27
  store i32 1, i32* %max_v_samp_factor.i, align 8, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="1", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %max_h_samp_factor.i, %max_v_samp_factor.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 5 = -1; Width: 2; Unprofitable; consume_markers
Trying AGAIN
Trying AGAIN
  %24 = phi i32 [ 1, %if.end36.i ], [ %cond75.i, %if.end58.i ]
  %25 = phi i32 [ 1, %if.end36.i ], [ %cond.i, %if.end58.i ]
  %ci.0.i = phi i32 [ 0, %if.end36.i ], [ %inc.i, %if.end58.i ]
  %compptr.0.i = phi %struct.jpeg_component_info* [ %23, %if.end36.i ], [ %incdec.ptr.i, %if.end58.i ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 16, i32* %msg_code55.i, align 8, !tbaa !20
  %33 = phi i32 [ %29, %lor.lhs.false46.i ], [ %.pre223.i, %if.then53.i ]
  %34 = phi i32 [ %24, %lor.lhs.false46.i ], [ %.pre222.i, %if.then53.i ]
  %35 = phi i32 [ %27, %lor.lhs.false46.i ], [ %.pre221.i, %if.then53.i ]
  %36 = phi i32 [ %25, %lor.lhs.false46.i ], [ %.pre220.i, %if.then53.i ]
looking for reduction
looking for reduction
Attempting Group:
  store i32 %cond.i, i32* %max_h_samp_factor.i, align 4, !tbaa !27
  store i32 %cond75.i, i32* %max_v_samp_factor.i, align 8, !tbaa !28
Creating Node
  store i32 %cond.i, i32* %max_h_samp_factor.i, align 4, !tbaa !27
  store i32 %cond75.i, i32* %max_v_samp_factor.i, align 8, !tbaa !28
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %cond.i = select i1 %cmp61.i, i32 %36, i32 %35
  %cond75.i = select i1 %cmp68.i, i32 %34, i32 %33
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %cmp61.i = icmp sgt i32 %36, %35
  %cmp68.i = icmp sgt i32 %34, %33
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %36 = phi i32 [ %25, %lor.lhs.false46.i ], [ %.pre220.i, %if.then53.i ]
  %34 = phi i32 [ %24, %lor.lhs.false46.i ], [ %.pre222.i, %if.then53.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %36 = phi i32 [ %25, %lor.lhs.false46.i ], [ %.pre220.i, %if.then53.i ]
Alt Seq
Creating Node
  %35 = phi i32 [ %27, %lor.lhs.false46.i ], [ %.pre221.i, %if.then53.i ]
  %33 = phi i32 [ %29, %lor.lhs.false46.i ], [ %.pre223.i, %if.then53.i ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %35 = phi i32 [ %27, %lor.lhs.false46.i ], [ %.pre221.i, %if.then53.i ]
Alt Seq
Creating Node
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
Match: 0
2 x 2
Final Match: 0
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
Alt Seq
ScheduleNode: {
  store i32 %cond.i, i32* %max_h_samp_factor.i, align 4, !tbaa !27
}
ScheduleNode: {
  store i32 %cond75.i, i32* %max_v_samp_factor.i, align 8, !tbaa !28
}
ScheduleNode: {
  store i32 %cond.i, i32* %max_h_samp_factor.i, align 4, !tbaa !27
}
Count: 1
Start:   %cmp61.i = icmp sgt i32 %36, %35
Non-memory:   %cmp61.i = icmp sgt i32 %36, %35
Non-memory:   %cond.i = select i1 %cmp61.i, i32 %36, i32 %35
Processing:   store i32 %cond.i, i32* %max_h_samp_factor.i, align 4, !tbaa !27
Count: 1
Found:   store i32 %cond.i, i32* %max_h_samp_factor.i, align 4, !tbaa !27
ScheduleNode: {
  store i32 %cond75.i, i32* %max_v_samp_factor.i, align 8, !tbaa !28
}
Non-memory:   %cmp68.i = icmp sgt i32 %34, %33
Non-memory:   %cond75.i = select i1 %cmp68.i, i32 %34, i32 %33
Processing:   store i32 %cond75.i, i32* %max_v_samp_factor.i, align 8, !tbaa !28
Count: 1
Found:   store i32 %cond75.i, i32* %max_v_samp_factor.i, align 8, !tbaa !28
I:   %inc.i = add nuw nsw i32 %ci.0.i, 1
Last:   br label %for.cond.i, !llvm.loop !33
Schedulable: 1
Loop Rolling: consume_markers
Generating tree
Generating MATCH
Match: 
  store i32 %cond.i, i32* %max_h_samp_factor.i, align 4, !tbaa !27
  store i32 %cond75.i, i32* %max_v_samp_factor.i, align 8, !tbaa !28
Generating MATCH
Match: 
  %cond.i = select i1 %cmp61.i, i32 %36, i32 %35
  %cond75.i = select i1 %cmp68.i, i32 %34, i32 %33
Generating MATCH
Match: 
  %cmp61.i = icmp sgt i32 %36, %35
  %cmp68.i = icmp sgt i32 %34, %33
Generating ALTSEQ
Values:
  %36 = phi i32 [ %25, %lor.lhs.false46.i ], [ %.pre220.i, %if.then53.i ]
  %34 = phi i32 [ %24, %lor.lhs.false46.i ], [ %.pre222.i, %if.then53.i ]
Generated Version 4:
  %71 = icmp eq i8 %70, 0
  %72 = select i1 %71, i32 %36, i32 %34
Generating ALTSEQ
Values:
  %35 = phi i32 [ %27, %lor.lhs.false46.i ], [ %.pre221.i, %if.then53.i ]
  %33 = phi i32 [ %29, %lor.lhs.false46.i ], [ %.pre223.i, %if.then53.i ]
Generated Version 4:
  %73 = select i1 %71, i32 %35, i32 %33
Operands done!
Generated:   %74 = icmp sgt i32 %72, %73
Gen:   %74 = icmp sgt i32 %72, %73
Operands done!
Generated:   %75 = select i1 %74, i32 %72, i32 %73
Found use: 0:   %25 = phi i32 [ 1, %if.end36.i ], [ %cond.i, %if.end58.i ]
Found use: 1:   %24 = phi i32 [ 1, %if.end36.i ], [ %cond75.i, %if.end58.i ]
Extracting:   %75 = select i1 %74, i32 %72, i32 %73
Gen:   %76 = select i1 %75, i32 %73, i32 %74
Generating ALTSEQ
Values:
  %max_h_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 57
  %max_v_samp_factor.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
Generated Version 4:
  %78 = select i1 %72, i32* %max_h_samp_factor.i, i32* %max_v_samp_factor.i
Operands done!
Generated:   store i32 %76, i32* %78, align 1
Gen:   store i32 %76, i32* %78, align 1
Graph code generated!
Root:
  store i32 %cond.i, i32* %max_h_samp_factor.i, align 4, !tbaa !27
  store i32 %cond75.i, i32* %max_v_samp_factor.i, align 8, !tbaa !28
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="select", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="icmp", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %37, %35", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %36, %34", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="alt: %max_h_samp_factor.i, %max_v_samp_factor.i", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
5->0 
2->1 
3->1 
4->1 
3->2 
4->2 
6 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
1->6
7 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
1->7
}

Gains: 8 - 24 = -16; Width: 2; Unprofitable; consume_markers
Trying AGAIN
Trying AGAIN
  %.lcssa = phi i32 [ %27, %for.cond.i ]
looking for reduction
Attempting Group:
  store i32 8, i32* %min_DCT_scaled_size.i, align 4, !tbaa !35
  %39 = phi i32 [ %.lcssa, %for.end.i ], [ %.pre.i, %for.body82.i ]
  %ci.1.i = phi i32 [ 0, %for.end.i ], [ %inc120.i, %for.body82.i ]
  %compptr.1.i = phi %struct.jpeg_component_info* [ %38, %for.end.i ], [ %incdec.ptr121.i, %for.body82.i ]
looking for reduction
looking for reduction
looking for reduction
  %mul.i = mul nsw i64 %conv86.i, %conv84.i
looking for reduction
looking for reduction
looking for reduction
  %mul95.i = mul nsw i64 %conv94.i, %conv92.i
looking for reduction
looking for reduction
looking for reduction
  %mul105.i = mul nsw i64 %conv104.i, %conv102.i
looking for reduction
looking for reduction
looking for reduction
  %mul114.i = mul nsw i64 %conv113.i, %conv111.i
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !36
  store i32 %conv90.i, i32* %width_in_blocks.i, align 4, !tbaa !37
  store i32 %conv100.i, i32* %height_in_blocks.i, align 8, !tbaa !38
  store i32 %conv109.i, i32* %downsampled_width.i, align 8, !tbaa !39
  store i32 %conv118.i, i32* %downsampled_height.i, align 4, !tbaa !40
  store i32 1, i32* %component_needed.i, align 8, !tbaa !41
Attempting Group:
  %call.i = tail call i64 @jdiv_round_up(i64 %mul.i, i64 %conv89.i) #3
  %call99.i = tail call i64 @jdiv_round_up(i64 %mul95.i, i64 %conv98.i) #3
  %call108.i = tail call i64 @jdiv_round_up(i64 %mul105.i, i64 %conv107.i) #3
  %call117.i = tail call i64 @jdiv_round_up(i64 %mul114.i, i64 %conv116.i) #3
Creating Node
  store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !36
  store i32 %conv90.i, i32* %width_in_blocks.i, align 4, !tbaa !37
  store i32 %conv100.i, i32* %height_in_blocks.i, align 8, !tbaa !38
  store i32 %conv109.i, i32* %downsampled_width.i, align 8, !tbaa !39
  store i32 %conv118.i, i32* %downsampled_height.i, align 4, !tbaa !40
  store i32 1, i32* %component_needed.i, align 8, !tbaa !41
Match: 1
6 x 6
Final Match: 1
Matching
Creating Node
i32 8
  %conv90.i = trunc i64 %call.i to i32
  %conv100.i = trunc i64 %call99.i to i32
  %conv109.i = trunc i64 %call108.i to i32
  %conv118.i = trunc i64 %call117.i to i32
i32 1
Match: 0
6 x 6
Final Match: 0
GEPSeq2
BinOP?
i32 8
Mismatching
Creating Node
  %DCT_scaled_size.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 9
  %width_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 7
  %height_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 8
  %downsampled_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 10
  %downsampled_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 11
  %component_needed.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 12
Match: 0
6 x 6
Final Match: 0
  %DCT_scaled_size.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 9
  %width_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 7
  %height_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 8
  %downsampled_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 10
  %downsampled_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 11
  %component_needed.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 12
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %DCT_scaled_size.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 9
Mismatching
ScheduleNode: {
  store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !36
}
ScheduleNode: {
  store i32 %conv90.i, i32* %width_in_blocks.i, align 4, !tbaa !37
}
ScheduleNode: {
  store i32 %conv100.i, i32* %height_in_blocks.i, align 8, !tbaa !38
}
ScheduleNode: {
  store i32 %conv109.i, i32* %downsampled_width.i, align 8, !tbaa !39
}
ScheduleNode: {
  store i32 %conv118.i, i32* %downsampled_height.i, align 4, !tbaa !40
}
ScheduleNode: {
  store i32 1, i32* %component_needed.i, align 8, !tbaa !41
}
ScheduleNode: {
  store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !36
}
Count: 1
Start:   store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !36
Processing:   store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !36
Count: 1
Found:   store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !36
ScheduleNode: {
  store i32 %conv90.i, i32* %width_in_blocks.i, align 4, !tbaa !37
}
Processing:   %40 = load i32, i32* %image_width83.i, align 8, !tbaa !18
Count: 1
Not found:   %40 = load i32, i32* %image_width83.i, align 8, !tbaa !18
Read/Write memory
I:   %40 = load i32, i32* %image_width83.i, align 8, !tbaa !18
Last:   br label %for.cond78.i, !llvm.loop !43
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
2 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
1->0 
2->0 
}


for.body82.i:                                     ; preds = %for.cond78.i
  %DCT_scaled_size.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 9
  store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !36
  %40 = load i32, i32* %image_width83.i, align 8, !tbaa !18
  %conv84.i = zext i32 %40 to i64
  %h_samp_factor85.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
  %41 = load i32, i32* %h_samp_factor85.i, align 8, !tbaa !30
  %conv86.i = sext i32 %41 to i64
  %mul.i = mul nsw i64 %conv86.i, %conv84.i
  %42 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !27
  %mul88.i = shl nsw i32 %42, 3
  %conv89.i = sext i32 %mul88.i to i64
  %call.i = tail call i64 @jdiv_round_up(i64 %mul.i, i64 %conv89.i) #3
  %conv90.i = trunc i64 %call.i to i32
  %width_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 7
  store i32 %conv90.i, i32* %width_in_blocks.i, align 4, !tbaa !37
  %43 = load i32, i32* %image_height.i, align 4, !tbaa !17
  %conv92.i = zext i32 %43 to i64
  %v_samp_factor93.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 3
  %44 = load i32, i32* %v_samp_factor93.i, align 4, !tbaa !32
  %conv94.i = sext i32 %44 to i64
  %mul95.i = mul nsw i64 %conv94.i, %conv92.i
  %45 = load i32, i32* %max_v_samp_factor.i, align 8, !tbaa !28
  %mul97.i = shl nsw i32 %45, 3
  %conv98.i = sext i32 %mul97.i to i64
  %call99.i = tail call i64 @jdiv_round_up(i64 %mul95.i, i64 %conv98.i) #3
  %conv100.i = trunc i64 %call99.i to i32
  %height_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 8
  store i32 %conv100.i, i32* %height_in_blocks.i, align 8, !tbaa !38
  %46 = load i32, i32* %image_width83.i, align 8, !tbaa !18
  %conv102.i = zext i32 %46 to i64
  %47 = load i32, i32* %h_samp_factor85.i, align 8, !tbaa !30
  %conv104.i = sext i32 %47 to i64
  %mul105.i = mul nsw i64 %conv104.i, %conv102.i
  %48 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !27
  %conv107.i = sext i32 %48 to i64
  %call108.i = tail call i64 @jdiv_round_up(i64 %mul105.i, i64 %conv107.i) #3
  %conv109.i = trunc i64 %call108.i to i32
  %downsampled_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 10
  store i32 %conv109.i, i32* %downsampled_width.i, align 8, !tbaa !39
  %49 = load i32, i32* %image_height.i, align 4, !tbaa !17
  %conv111.i = zext i32 %49 to i64
  %50 = load i32, i32* %v_samp_factor93.i, align 4, !tbaa !32
  %conv113.i = sext i32 %50 to i64
  %mul114.i = mul nsw i64 %conv113.i, %conv111.i
  %51 = load i32, i32* %max_v_samp_factor.i, align 8, !tbaa !28
  %conv116.i = sext i32 %51 to i64
  %call117.i = tail call i64 @jdiv_round_up(i64 %mul114.i, i64 %conv116.i) #3
  %conv118.i = trunc i64 %call117.i to i32
  %downsampled_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 11
  store i32 %conv118.i, i32* %downsampled_height.i, align 4, !tbaa !40
  %component_needed.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 12
  store i32 1, i32* %component_needed.i, align 8, !tbaa !41
  %quant_table.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 19
  store %struct.JQUANT_TBL* null, %struct.JQUANT_TBL** %quant_table.i, align 8, !tbaa !42
  %inc120.i = add nuw nsw i32 %ci.1.i, 1
  %incdec.ptr121.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 1
  %.pre.i = load i32, i32* %num_components.i, align 8, !tbaa !26
  br label %for.cond78.i, !llvm.loop !43

Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Trying AGAIN
Creating Node
  %call.i = tail call i64 @jdiv_round_up(i64 %mul.i, i64 %conv89.i) #3
  %call99.i = tail call i64 @jdiv_round_up(i64 %mul95.i, i64 %conv98.i) #3
  %call108.i = tail call i64 @jdiv_round_up(i64 %mul105.i, i64 %conv107.i) #3
  %call117.i = tail call i64 @jdiv_round_up(i64 %mul114.i, i64 %conv116.i) #3
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %mul.i = mul nsw i64 %conv86.i, %conv84.i
  %mul95.i = mul nsw i64 %conv94.i, %conv92.i
  %mul105.i = mul nsw i64 %conv104.i, %conv102.i
  %mul114.i = mul nsw i64 %conv113.i, %conv111.i
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %conv86.i = sext i32 %41 to i64
  %conv94.i = sext i32 %44 to i64
  %conv104.i = sext i32 %47 to i64
  %conv113.i = sext i32 %50 to i64
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %41 = load i32, i32* %h_samp_factor85.i, align 8, !tbaa !30
  %44 = load i32, i32* %v_samp_factor93.i, align 4, !tbaa !32
  %47 = load i32, i32* %h_samp_factor85.i, align 8, !tbaa !30
  %50 = load i32, i32* %v_samp_factor93.i, align 4, !tbaa !32
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %h_samp_factor85.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
  %v_samp_factor93.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 3
  %h_samp_factor85.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
  %v_samp_factor93.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 3
Match: 0
2 x 4
Final Match: 0
  %h_samp_factor85.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
  %v_samp_factor93.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 3
  %h_samp_factor85.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
  %v_samp_factor93.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 3
GEPSeq2
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
BinOP?
  %h_samp_factor85.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
Alt Seq
Creating Node
  %conv84.i = zext i32 %40 to i64
  %conv92.i = zext i32 %43 to i64
  %conv102.i = zext i32 %46 to i64
  %conv111.i = zext i32 %49 to i64
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %40 = load i32, i32* %image_width83.i, align 8, !tbaa !18
  %43 = load i32, i32* %image_height.i, align 4, !tbaa !17
  %46 = load i32, i32* %image_width83.i, align 8, !tbaa !18
  %49 = load i32, i32* %image_height.i, align 4, !tbaa !17
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %image_width83.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %image_height.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
  %image_width83.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %image_height.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
Match: 0
2 x 4
Final Match: 0
  %image_width83.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %image_height.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
  %image_width83.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
  %image_height.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 7
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %image_width83.i = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 6
Alt Seq
Creating Node
  %conv89.i = sext i32 %mul88.i to i64
  %conv98.i = sext i32 %mul97.i to i64
  %conv107.i = sext i32 %48 to i64
  %conv116.i = sext i32 %51 to i64
Match: 1
4 x 4
Final Match: 1
Matching
Creating Node
  %mul88.i = shl nsw i32 %42, 3
  %mul97.i = shl nsw i32 %45, 3
  %48 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !27
  %51 = load i32, i32* %max_v_samp_factor.i, align 8, !tbaa !28
Match: 0
4 x 4
Final Match: 0
GEPSeq2
BinOP?
  %mul88.i = shl nsw i32 %42, 3
Mismatching
Creating Node
Function: jdiv_round_up
Function: jdiv_round_up
Function: jdiv_round_up
Function: jdiv_round_up
Match: 1
1 x 4
Final Match: 1
All the Same
ScheduleNode: {
  %41 = load i32, i32* %h_samp_factor85.i, align 8, !tbaa !30
  %40 = load i32, i32* %image_width83.i, align 8, !tbaa !18
}
ScheduleNode: {
  %call.i = tail call i64 @jdiv_round_up(i64 %mul.i, i64 %conv89.i) #3
}
ScheduleNode: {
  %44 = load i32, i32* %v_samp_factor93.i, align 4, !tbaa !32
  %43 = load i32, i32* %image_height.i, align 4, !tbaa !17
}
ScheduleNode: {
  %call99.i = tail call i64 @jdiv_round_up(i64 %mul95.i, i64 %conv98.i) #3
}
ScheduleNode: {
  %47 = load i32, i32* %h_samp_factor85.i, align 8, !tbaa !30
  %46 = load i32, i32* %image_width83.i, align 8, !tbaa !18
}
ScheduleNode: {
  %call108.i = tail call i64 @jdiv_round_up(i64 %mul105.i, i64 %conv107.i) #3
}
ScheduleNode: {
  %49 = load i32, i32* %image_height.i, align 4, !tbaa !17
  %50 = load i32, i32* %v_samp_factor93.i, align 4, !tbaa !32
}
ScheduleNode: {
  %call117.i = tail call i64 @jdiv_round_up(i64 %mul114.i, i64 %conv116.i) #3
}
ScheduleNode: {
  %41 = load i32, i32* %h_samp_factor85.i, align 8, !tbaa !30
  %40 = load i32, i32* %image_width83.i, align 8, !tbaa !18
}
Count: 2
Start:   %40 = load i32, i32* %image_width83.i, align 8, !tbaa !18
Processing:   %40 = load i32, i32* %image_width83.i, align 8, !tbaa !18
Count: 2
Found:   %40 = load i32, i32* %image_width83.i, align 8, !tbaa !18
Non-memory:   %conv84.i = zext i32 %40 to i64
Non-memory:   %h_samp_factor85.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
Processing:   %41 = load i32, i32* %h_samp_factor85.i, align 8, !tbaa !30
Count: 1
Found:   %41 = load i32, i32* %h_samp_factor85.i, align 8, !tbaa !30
ScheduleNode: {
  %call.i = tail call i64 @jdiv_round_up(i64 %mul.i, i64 %conv89.i) #3
}
Non-memory:   %conv86.i = sext i32 %41 to i64
Non-memory:   %mul.i = mul nsw i64 %conv86.i, %conv84.i
Processing:   %42 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !27
Count: 1
Not found:   %42 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !27
Read/Write memory
I:   %42 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !27
Last:   br label %for.cond78.i, !llvm.loop !43
Schedulable: 0
digraph VTree {
0 [label="call: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mul", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %h_samp_factor85.i, %v_samp_factor93.i", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="alt: %image_width83.i, %image_height.i", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="sext", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="mismatch", style="filled" , fillcolor="#ff6671", shape=box];
10 [label="func: jdiv_round_up", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
8->0 
10->0 
2->1 
5->1 
3->2 
4->3 
6->5 
7->6 
9->8 
11 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->11
12 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->12
13 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->13
14 [label="trunc", style="filled" , fillcolor="#f2eb5c", shape=box];
0->14
}


for.body82.i:                                     ; preds = %for.cond78.i
  %DCT_scaled_size.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 9
  store i32 8, i32* %DCT_scaled_size.i, align 4, !tbaa !36
  %40 = load i32, i32* %image_width83.i, align 8, !tbaa !18
  %conv84.i = zext i32 %40 to i64
  %h_samp_factor85.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 2
  %41 = load i32, i32* %h_samp_factor85.i, align 8, !tbaa !30
  %conv86.i = sext i32 %41 to i64
  %mul.i = mul nsw i64 %conv86.i, %conv84.i
  %42 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !27
  %mul88.i = shl nsw i32 %42, 3
  %conv89.i = sext i32 %mul88.i to i64
  %call.i = tail call i64 @jdiv_round_up(i64 %mul.i, i64 %conv89.i) #3
  %conv90.i = trunc i64 %call.i to i32
  %width_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 7
  store i32 %conv90.i, i32* %width_in_blocks.i, align 4, !tbaa !37
  %43 = load i32, i32* %image_height.i, align 4, !tbaa !17
  %conv92.i = zext i32 %43 to i64
  %v_samp_factor93.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 3
  %44 = load i32, i32* %v_samp_factor93.i, align 4, !tbaa !32
  %conv94.i = sext i32 %44 to i64
  %mul95.i = mul nsw i64 %conv94.i, %conv92.i
  %45 = load i32, i32* %max_v_samp_factor.i, align 8, !tbaa !28
  %mul97.i = shl nsw i32 %45, 3
  %conv98.i = sext i32 %mul97.i to i64
  %call99.i = tail call i64 @jdiv_round_up(i64 %mul95.i, i64 %conv98.i) #3
  %conv100.i = trunc i64 %call99.i to i32
  %height_in_blocks.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 8
  store i32 %conv100.i, i32* %height_in_blocks.i, align 8, !tbaa !38
  %46 = load i32, i32* %image_width83.i, align 8, !tbaa !18
  %conv102.i = zext i32 %46 to i64
  %47 = load i32, i32* %h_samp_factor85.i, align 8, !tbaa !30
  %conv104.i = sext i32 %47 to i64
  %mul105.i = mul nsw i64 %conv104.i, %conv102.i
  %48 = load i32, i32* %max_h_samp_factor.i, align 4, !tbaa !27
  %conv107.i = sext i32 %48 to i64
  %call108.i = tail call i64 @jdiv_round_up(i64 %mul105.i, i64 %conv107.i) #3
  %conv109.i = trunc i64 %call108.i to i32
  %downsampled_width.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 10
  store i32 %conv109.i, i32* %downsampled_width.i, align 8, !tbaa !39
  %49 = load i32, i32* %image_height.i, align 4, !tbaa !17
  %conv111.i = zext i32 %49 to i64
  %50 = load i32, i32* %v_samp_factor93.i, align 4, !tbaa !32
  %conv113.i = sext i32 %50 to i64
  %mul114.i = mul nsw i64 %conv113.i, %conv111.i
  %51 = load i32, i32* %max_v_samp_factor.i, align 8, !tbaa !28
  %conv116.i = sext i32 %51 to i64
  %call117.i = tail call i64 @jdiv_round_up(i64 %mul114.i, i64 %conv116.i) #3
  %conv118.i = trunc i64 %call117.i to i32
  %downsampled_height.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 11
  store i32 %conv118.i, i32* %downsampled_height.i, align 4, !tbaa !40
  %component_needed.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 12
  store i32 1, i32* %component_needed.i, align 8, !tbaa !41
  %quant_table.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 0, i32 19
  store %struct.JQUANT_TBL* null, %struct.JQUANT_TBL** %quant_table.i, align 8, !tbaa !42
  %inc120.i = add nuw nsw i32 %ci.1.i, 1
  %incdec.ptr121.i = getelementptr inbounds %struct.jpeg_component_info, %struct.jpeg_component_info* %compptr.1.i, i64 1
  %.pre.i = load i32, i32* %num_components.i, align 8, !tbaa !26
  br label %for.cond78.i, !llvm.loop !43

looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %conv129.i, i32* %total_iMCU_rows.i, align 8, !tbaa !44
Attempting Group:
  %call128.i = tail call i64 @jdiv_round_up(i64 %conv124.i, i64 %conv127.i) #3
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %has_multiple_scans.i, align 8, !tbaa !47
looking for reduction
Attempting Group:
  store i32 0, i32* %has_multiple_scans136.i, align 8, !tbaa !47
looking for reduction
Attempting Group:
  store i32 0, i32* %inheaders, align 8, !tbaa !16
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 34, i32* %msg_code, align 8, !tbaa !20
looking for reduction
Attempting Group:
  tail call void @start_input_pass(%struct.jpeg_decompress_struct* nonnull %cinfo) #4
looking for reduction
looking for reduction
Attempting Group:
  store i32 1, i32* %eoi_reached, align 4, !tbaa !10
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 58, i32* %msg_code21, align 8, !tbaa !20
looking for reduction
looking for reduction
Attempting Group:
  store i32 %70, i32* %output_scan_number, align 4, !tbaa !50
  %retval.0 = phi i32 [ 2, %entry ], [ 2, %if.then19 ], [ 2, %if.then16 ], [ 2, %if.then26 ], [ 2, %if.else25 ], [ 1, %initial_setup.exit ], [ 1, %if.end9 ], [ %call, %if.end ]
looking for reduction
Done Loop Roller: 0/5
Optimizing: reset_input_controller
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store [64 x i32]* null, [64 x i32]** %coef_bits, align 8, !tbaa !23
Attempting Group:
  store i32 (%struct.jpeg_decompress_struct*)* @consume_markers, i32 (%struct.jpeg_decompress_struct*)** %consume_input, align 8, !tbaa !10
Done Loop Roller: 0/0
Nothing found in: reset_input_controller
Optimizing: finish_input_pass
looking for reduction
looking for reduction
Attempting Group:
  store i32 (%struct.jpeg_decompress_struct*)* @consume_markers, i32 (%struct.jpeg_decompress_struct*)** %consume_input, align 8, !tbaa !10
Done Loop Roller: 0/0
Nothing found in: finish_input_pass
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jdsample.c -o src/jdsample.o   -mllvm -reroll-loops=3
Optimizing: jinit_upsampler
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*)* @start_pass_upsample, void (%struct.jpeg_decompress_struct*)** %start_pass2, align 8, !tbaa !14
Attempting Group:
  store i8* %call, i8** %3, align 8, !tbaa !13
looking for reduction
looking for reduction
Attempting Group:
  store i32 23, i32* %msg_code, align 8, !tbaa !21
looking for reduction
  %11 = phi i1 [ false, %if.end ], [ %cmp, %land.rhs ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %land.end ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %incdec.ptr, %for.inc ], [ %12, %land.end ]
looking for reduction
looking for reduction
  %div13 = sdiv i32 %mul11, %20
looking for reduction
Attempting Group:
  store i32 %div13, i32* %arrayidx, align 4, !tbaa !34
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)* @noop_upsample, void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)** %arrayidx17, align 8, !tbaa !36
looking for reduction
  %or.cond = and i1 %cmp18, %cmp19
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)* @fullsize_upsample, void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)** %arrayidx23, align 8, !tbaa !36
looking for reduction
  %or.cond186 = and i1 %cmp26, %cmp19
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)* @h2v1_fancy_upsample, void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)** %arrayidx36, align 8, !tbaa !36
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)* @h2v1_upsample, void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)** %arrayidx40, align 8, !tbaa !36
looking for reduction
  %or.cond187 = and i1 %cmp26, %cmp47
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)* @h2v2_fancy_upsample, void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)** %arrayidx56, align 8, !tbaa !36
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)* @h2v2_upsample, void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)** %arrayidx62, align 8, !tbaa !36
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)* @int_upsample, void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)** %arrayidx72, align 8, !tbaa !36
looking for reduction
looking for reduction
Attempting Group:
  store i32 37, i32* %msg_code82, align 8, !tbaa !21
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8** %call99, i8*** %arrayidx101, align 8, !tbaa !36
Attempting Group:
  %call96 = tail call i64 @jround_up(i64 %conv93, i64 %conv95) #2
looking for reduction
Done Loop Roller: 0/0
Nothing found in: jinit_upsampler
Optimizing: start_pass_upsample
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %2, i32* %next_row_out, align 8, !tbaa !11
  store i32 %3, i32* %rows_to_go, align 4, !tbaa !15
Creating Node
  store i32 %2, i32* %next_row_out, align 8, !tbaa !11
  store i32 %3, i32* %rows_to_go, align 4, !tbaa !15
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %2 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !10
  %3 = load i32, i32* %output_height, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
  %output_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 27
Match: 0
2 x 2
Final Match: 0
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
  %output_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 27
GEPSeq2
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
BinOP?
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
Alt Seq
Creating Node
  %next_row_out = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 3
  %rows_to_go = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 4
Match: 0
2 x 2
Final Match: 0
  %next_row_out = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 3
  %rows_to_go = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 4
GEPSeq2
%struct.my_upsampler = type { %struct.jpeg_upsampler, [10 x i8**], [10 x void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)*], i32, i32, [10 x i32], [10 x i8], [10 x i8] }
BinOP?
  %next_row_out = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 3
Alt Seq
ScheduleNode: {
  %2 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !10
}
ScheduleNode: {
  store i32 %2, i32* %next_row_out, align 8, !tbaa !11
}
ScheduleNode: {
  %3 = load i32, i32* %output_height, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 %3, i32* %rows_to_go, align 4, !tbaa !15
}
ScheduleNode: {
  %2 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !10
}
Count: 1
Start:   %2 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !10
Processing:   %2 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !10
Count: 1
Found:   %2 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !10
ScheduleNode: {
  store i32 %2, i32* %next_row_out, align 8, !tbaa !11
}
Non-memory:   %next_row_out = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 3
Processing:   store i32 %2, i32* %next_row_out, align 8, !tbaa !11
Count: 1
Found:   store i32 %2, i32* %next_row_out, align 8, !tbaa !11
ScheduleNode: {
  %3 = load i32, i32* %output_height, align 4, !tbaa !14
}
Non-memory:   %output_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 27
Processing:   %3 = load i32, i32* %output_height, align 4, !tbaa !14
Count: 1
Found:   %3 = load i32, i32* %output_height, align 4, !tbaa !14
ScheduleNode: {
  store i32 %3, i32* %rows_to_go, align 4, !tbaa !15
}
Non-memory:   %rows_to_go = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 4
Processing:   store i32 %3, i32* %rows_to_go, align 4, !tbaa !15
Count: 1
Found:   store i32 %3, i32* %rows_to_go, align 4, !tbaa !15
I:   ret void
Last:   ret void
Schedulable: 1
Loop Rolling: start_pass_upsample
Generating tree
Generating MATCH
Match: 
  store i32 %2, i32* %next_row_out, align 8, !tbaa !11
  store i32 %3, i32* %rows_to_go, align 4, !tbaa !15
Generating MATCH
Match: 
  %2 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !10
  %3 = load i32, i32* %output_height, align 4, !tbaa !14
Generating ALTSEQ
Values:
  %max_v_samp_factor = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 58
  %output_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 27
Generated Version 4:
  %5 = icmp eq i8 %4, 0
  %6 = select i1 %5, i32* %max_v_samp_factor, i32* %output_height
Operands done!
Generated:   %7 = load i32, i32* %6, align 1
Gen:   %7 = load i32, i32* %6, align 1
Generating ALTSEQ
Values:
  %next_row_out = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 3
  %rows_to_go = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 4
Generated Version 4:
  %8 = select i1 %5, i32* %next_row_out, i32* %rows_to_go
Operands done!
Generated:   store i32 %7, i32* %8, align 1
Gen:   store i32 %7, i32* %8, align 1
Graph code generated!
Root:
  store i32 %2, i32* %next_row_out, align 8, !tbaa !11
  store i32 %3, i32* %rows_to_go, align 4, !tbaa !15
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %max_v_samp_factor, %output_height", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %next_row_out, %rows_to_go", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
3->0 
2->1 
}

Gains: 8 - 8 = 0; Width: 2; Unprofitable; start_pass_upsample
Trying AGAIN
Trying AGAIN
Done Loop Roller: 0/1
Optimizing: sep_upsample
looking for reduction
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %if.then ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %incdec.ptr, %for.body ], [ %4, %if.then ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %next_row_out, align 8, !tbaa !10
  %11 = phi i32 [ 0, %for.end ], [ %2, %entry ]
  %12 = phi i32 [ %.pre, %for.end ], [ %3, %entry ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add = add i32 %17, %num_rows.1
looking for reduction
  %sub26 = sub i32 %18, %num_rows.1
looking for reduction
  %add28 = add i32 %19, %num_rows.1
looking for reduction
Attempting Group:
  store i32 %sub26, i32* %rows_to_go, align 4, !tbaa !20
  store i32 %add28, i32* %next_row_out, align 8, !tbaa !10
Attempting Group:
  store i32 %add, i32* %out_row_ctr, align 4, !tbaa !17
Creating Node
  store i32 %sub26, i32* %rows_to_go, align 4, !tbaa !20
  store i32 %add28, i32* %next_row_out, align 8, !tbaa !10
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %sub26 = sub i32 %18, %num_rows.1
  %add28 = add i32 %19, %num_rows.1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %sub26 = sub i32 %18, %num_rows.1
BinOp Seq
Creating Node
  %sub26 = sub i32 %18, %num_rows.1
  %19 = load i32, i32* %next_row_out, align 8, !tbaa !10
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %sub26 = sub i32 %18, %num_rows.1
BinOp Seq
Creating Node
  %18 = load i32, i32* %rows_to_go, align 4, !tbaa !20
  %19 = load i32, i32* %next_row_out, align 8, !tbaa !10
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %rows_to_go = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 4
  %next_row_out = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 3
Match: 0
2 x 2
Final Match: 0
  %rows_to_go = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 4
  %next_row_out = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 3
GEPSeq2
%struct.my_upsampler = type { %struct.jpeg_upsampler, [10 x i8**], [10 x void (%struct.jpeg_decompress_struct*, %struct.jpeg_component_info*, i8**, i8***)*], i32, i32, [10 x i32], [10 x i8], [10 x i8] }
BinOP?
  %rows_to_go = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 4
Alt Seq
Creating Node
  %num_rows.1 = select i1 %cmp17, i32 %sub16, i32 %spec.select
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %num_rows.1 = select i1 %cmp17, i32 %sub16, i32 %spec.select
Alt Seq
Creating Node
i32 0
  %num_rows.1 = select i1 %cmp17, i32 %sub16, i32 %spec.select
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
ScheduleNode: {
  %18 = load i32, i32* %rows_to_go, align 4, !tbaa !20
}
ScheduleNode: {
  store i32 %sub26, i32* %rows_to_go, align 4, !tbaa !20
}
ScheduleNode: {
  %19 = load i32, i32* %next_row_out, align 8, !tbaa !10
}
ScheduleNode: {
  store i32 %add28, i32* %next_row_out, align 8, !tbaa !10
}
ScheduleNode: {
  %18 = load i32, i32* %rows_to_go, align 4, !tbaa !20
}
Count: 1
Start:   %18 = load i32, i32* %rows_to_go, align 4, !tbaa !20
Processing:   %18 = load i32, i32* %rows_to_go, align 4, !tbaa !20
Count: 1
Found:   %18 = load i32, i32* %rows_to_go, align 4, !tbaa !20
ScheduleNode: {
  store i32 %sub26, i32* %rows_to_go, align 4, !tbaa !20
}
Non-memory:   %sub26 = sub i32 %18, %num_rows.1
Processing:   store i32 %sub26, i32* %rows_to_go, align 4, !tbaa !20
Count: 1
Found:   store i32 %sub26, i32* %rows_to_go, align 4, !tbaa !20
ScheduleNode: {
  %19 = load i32, i32* %next_row_out, align 8, !tbaa !10
}
Processing:   %19 = load i32, i32* %next_row_out, align 8, !tbaa !10
Count: 1
Found:   %19 = load i32, i32* %next_row_out, align 8, !tbaa !10
ScheduleNode: {
  store i32 %add28, i32* %next_row_out, align 8, !tbaa !10
}
Non-memory:   %add28 = add i32 %19, %num_rows.1
Processing:   store i32 %add28, i32* %next_row_out, align 8, !tbaa !10
Count: 1
Found:   store i32 %add28, i32* %next_row_out, align 8, !tbaa !10
I:   %20 = load i32, i32* %max_v_samp_factor, align 8, !tbaa !13
Last:   br i1 %cmp31.not, label %if.end34, label %if.then32
Schedulable: 1
Loop Rolling: sep_upsample
Generating tree
Generating MATCH
Match: 
  store i32 %sub26, i32* %rows_to_go, align 4, !tbaa !20
  store i32 %add28, i32* %next_row_out, align 8, !tbaa !10
Generating BINOP
Generating BINOP
Generating MATCH
Match: 
  %18 = load i32, i32* %rows_to_go, align 4, !tbaa !20
  %19 = load i32, i32* %next_row_out, align 8, !tbaa !10
Generating ALTSEQ
Values:
  %rows_to_go = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 4
  %next_row_out = getelementptr inbounds %struct.my_upsampler, %struct.my_upsampler* %1, i64 0, i32 3
Generated Version 4:
  %23 = icmp eq i8 %22, 0
  %24 = select i1 %23, i32* %rows_to_go, i32* %next_row_out
Operands done!
Generated:   %25 = load i32, i32* %24, align 1
Gen:   %25 = load i32, i32* %24, align 1
Generating ALTSEQ
Values:
  %num_rows.1 = select i1 %cmp17, i32 %sub16, i32 %spec.select
i32 0
Generated Version 4:
  %26 = select i1 %23, i32 %num_rows.1, i32 0
Closing BINOP
Gen:   %27 = sub i32 %25, %26
Generating ALTSEQ
Values:
i32 0
  %num_rows.1 = select i1 %cmp17, i32 %sub16, i32 %spec.select
Generated Version 4:
  %28 = select i1 %23, i32 0, i32 %num_rows.1
Closing BINOP
Found use: 1:   %cmp31.not = icmp slt i32 %add28, %20
Extracting:   %29 = add i32 %27, %28
Gen:   %30 = add i32 %28, %29
Operands done!
Generated:   store i32 %30, i32* %25, align 1
Gen:   store i32 %30, i32* %25, align 1
Graph code generated!
Root:
  store i32 %sub26, i32* %rows_to_go, align 4, !tbaa !20
  store i32 %add28, i32* %next_row_out, align 8, !tbaa !10
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="sub seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %rows_to_go, %next_row_out", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="alt: %num_rows.1, 0", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="alt: 0, %num_rows.1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
6->1 
3->2 
5->2 
4->3 
7 [label="icmp", style="filled" , fillcolor="#f2eb5c", shape=box];
1->7
}

Gains: 10 - 20 = -10; Width: 2; Unprofitable; sep_upsample
Trying AGAIN
Trying AGAIN
looking for reduction
  %inc33 = add i32 %22, 1
Attempting Group:
  store i32 %inc33, i32* %in_row_group_ctr, align 4, !tbaa !17
looking for reduction
Done Loop Roller: 0/1
Optimizing: noop_upsample
looking for reduction
looking for reduction
Attempting Group:
  store i8** null, i8*** %output_data_ptr, align 8, !tbaa !2
Done Loop Roller: 0/0
Nothing found in: noop_upsample
Optimizing: fullsize_upsample
looking for reduction
looking for reduction
Attempting Group:
  store i8** %input_data, i8*** %output_data_ptr, align 8, !tbaa !2
Done Loop Roller: 0/0
Nothing found in: fullsize_upsample
Optimizing: h2v1_fancy_upsample
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.end ], [ 0, %entry ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %5, i8* %4, align 1, !tbaa !11
  store i8 %conv7, i8* %incdec.ptr4, align 1, !tbaa !11
Creating Node
  store i8 %5, i8* %4, align 1, !tbaa !11
  store i8 %conv7, i8* %incdec.ptr4, align 1, !tbaa !11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %5 = load i8, i8* %3, align 1, !tbaa !11
  %conv7 = trunc i16 %7 to i8
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %5 = load i8, i8* %3, align 1, !tbaa !11
Alt Seq
Creating Node
  %4 = load i8*, i8** %arrayidx2, align 8, !tbaa !2
  %incdec.ptr4 = getelementptr inbounds i8, i8* %4, i64 1
Match: 0
2 x 2
Final Match: 0
  %4 = load i8*, i8** %arrayidx2, align 8, !tbaa !2
  %incdec.ptr4 = getelementptr inbounds i8, i8* %4, i64 1
Ptr:   %4 = load i8*, i8** %arrayidx2, align 8, !tbaa !2
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
ScheduleNode: {
  store i8 %5, i8* %4, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %conv7, i8* %incdec.ptr4, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %5, i8* %4, align 1, !tbaa !11
}
Count: 1
Start:   %incdec.ptr4 = getelementptr inbounds i8, i8* %4, i64 1
Non-memory:   %incdec.ptr4 = getelementptr inbounds i8, i8* %4, i64 1
Processing:   store i8 %5, i8* %4, align 1, !tbaa !11
Count: 1
Found:   store i8 %5, i8* %4, align 1, !tbaa !11
ScheduleNode: {
  store i8 %conv7, i8* %incdec.ptr4, align 1, !tbaa !11
}
Non-memory:   %mul = mul nuw nsw i16 %conv, 3
Processing:   %6 = load i8, i8* %incdec.ptr, align 1, !tbaa !11
Count: 1
Not found:   %6 = load i8, i8* %incdec.ptr, align 1, !tbaa !11
Read/Write memory
I:   %6 = load i8, i8* %incdec.ptr, align 1, !tbaa !11
Last:   br label %for.cond9
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: %5, %conv7", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->2 
}


for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i8*, i8** %input_data, i64 %indvars.iv
  %3 = load i8*, i8** %arrayidx, align 8, !tbaa !2
  %arrayidx2 = getelementptr inbounds i8*, i8** %0, i64 %indvars.iv
  %4 = load i8*, i8** %arrayidx2, align 8, !tbaa !2
  %incdec.ptr = getelementptr inbounds i8, i8* %3, i64 1
  %5 = load i8, i8* %3, align 1, !tbaa !11
  %conv = zext i8 %5 to i16
  %incdec.ptr4 = getelementptr inbounds i8, i8* %4, i64 1
  store i8 %5, i8* %4, align 1, !tbaa !11
  %mul = mul nuw nsw i16 %conv, 3
  %6 = load i8, i8* %incdec.ptr, align 1, !tbaa !11
  %conv5 = zext i8 %6 to i16
  %add = add nuw nsw i16 %mul, 2
  %add6 = add nuw nsw i16 %add, %conv5
  %7 = lshr i16 %add6, 2
  %conv7 = trunc i16 %7 to i8
  store i8 %conv7, i8* %incdec.ptr4, align 1, !tbaa !11
  %8 = load i32, i32* %downsampled_width, align 8, !tbaa !12
  %sub = add i32 %8, -2
  br label %for.cond9

Trying AGAIN
Trying AGAIN
  %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
  %.pn = phi i8* [ %4, %for.body ], [ %outptr.0, %for.body12 ]
  %colctr.0 = phi i32 [ %sub, %for.body ], [ %dec, %for.body12 ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
  store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
Creating Node
  store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
  store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv21 = trunc i32 %11 to i8
  %conv27 = trunc i32 %13 to i8
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %11 = lshr i32 %add19, 2
  %13 = lshr i32 %add25, 2
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %add19 = add nuw nsw i32 %add18, %mul15
  %add25 = add nuw nsw i32 %add24, %conv23
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %add18 = add nuw nsw i32 %conv17, 1
  %add24 = add nuw nsw i32 %mul15, 2
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv17 = zext i8 %10 to i32
  %mul15 = mul nuw nsw i32 %conv14, 3
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %conv17 = zext i8 %10 to i32
BinOp Seq
Creating Node
  %conv17 = zext i8 %10 to i32
  %conv14 = zext i8 %9 to i32
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %10 = load i8, i8* %arrayidx16, align 1, !tbaa !11
  %9 = load i8, i8* %inptr.0, align 1, !tbaa !11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx16 = getelementptr inbounds i8, i8* %inptr.0, i64 -1
  %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
Match: 0
2 x 2
Final Match: 0
  %arrayidx16 = getelementptr inbounds i8, i8* %inptr.0, i64 -1
  %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
Ptr:   %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
AllGEPs: 0
GEP Seq
Creating Node
i64 -1
i64 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 -1
Int Seq
Creating Node
i32 1
i32 3
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
i32 1
i32 2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
  %mul15 = mul nuw nsw i32 %conv14, 3
  %conv23 = zext i8 %12 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %mul15 = mul nuw nsw i32 %conv14, 3
BinOp Seq
Creating Node
  %conv14 = zext i8 %9 to i32
  %conv23 = zext i8 %12 to i32
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %9 = load i8, i8* %inptr.0, align 1, !tbaa !11
  %12 = load i8, i8* %incdec.ptr13, align 1, !tbaa !11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
  %incdec.ptr13 = getelementptr inbounds i8, i8* %inptr.0, i64 1
Match: 0
2 x 2
Final Match: 0
  %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
  %incdec.ptr13 = getelementptr inbounds i8, i8* %inptr.0, i64 1
Ptr:   %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
Creating Node
i32 3
i32 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 3
Int Seq
Creating Node
i32 2
i32 2
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
  %incdec.ptr22 = getelementptr inbounds i8, i8* %.pn, i64 3
Match: 0
2 x 2
Final Match: 0
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
  %incdec.ptr22 = getelementptr inbounds i8, i8* %.pn, i64 3
GEPSeq2
i8
BinOP?
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
Alt Seq
Already scheduled?!   %9 = load i8, i8* %inptr.0, align 1, !tbaa !11
ScheduleNode: {
  %9 = load i8, i8* %inptr.0, align 1, !tbaa !11
  %10 = load i8, i8* %arrayidx16, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
}
ScheduleNode: {
  %12 = load i8, i8* %incdec.ptr13, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
}
ScheduleNode: {
  %9 = load i8, i8* %inptr.0, align 1, !tbaa !11
  %10 = load i8, i8* %arrayidx16, align 1, !tbaa !11
}
Count: 2
Start:   %incdec.ptr13 = getelementptr inbounds i8, i8* %inptr.0, i64 1
Non-memory:   %incdec.ptr13 = getelementptr inbounds i8, i8* %inptr.0, i64 1
Processing:   %9 = load i8, i8* %inptr.0, align 1, !tbaa !11
Count: 2
Found:   %9 = load i8, i8* %inptr.0, align 1, !tbaa !11
Non-memory:   %conv14 = zext i8 %9 to i32
Non-memory:   %mul15 = mul nuw nsw i32 %conv14, 3
Non-memory:   %arrayidx16 = getelementptr inbounds i8, i8* %inptr.0, i64 -1
Processing:   %10 = load i8, i8* %arrayidx16, align 1, !tbaa !11
Count: 1
Found:   %10 = load i8, i8* %arrayidx16, align 1, !tbaa !11
ScheduleNode: {
  store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
}
Non-memory:   %conv17 = zext i8 %10 to i32
Non-memory:   %add18 = add nuw nsw i32 %conv17, 1
Non-memory:   %add19 = add nuw nsw i32 %add18, %mul15
Non-memory:   %11 = lshr i32 %add19, 2
Non-memory:   %conv21 = trunc i32 %11 to i8
Non-memory:   %incdec.ptr22 = getelementptr inbounds i8, i8* %.pn, i64 3
Processing:   store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
Count: 1
Found:   store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
ScheduleNode: {
  %12 = load i8, i8* %incdec.ptr13, align 1, !tbaa !11
}
Processing:   %12 = load i8, i8* %incdec.ptr13, align 1, !tbaa !11
Count: 1
Found:   %12 = load i8, i8* %incdec.ptr13, align 1, !tbaa !11
ScheduleNode: {
  store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
}
Non-memory:   %conv23 = zext i8 %12 to i32
Non-memory:   %add24 = add nuw nsw i32 %mul15, 2
Non-memory:   %add25 = add nuw nsw i32 %add24, %conv23
Non-memory:   %13 = lshr i32 %add25, 2
Non-memory:   %conv27 = trunc i32 %13 to i8
Processing:   store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
Count: 1
Found:   store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
I:   %dec = add i32 %colctr.0, -1
Last:   br label %for.cond9, !llvm.loop !14
Schedulable: 1
Loop Rolling: h2v1_fancy_upsample
Generating tree
Generating MATCH
Match: 
  store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
  store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
Generating MATCH
Match: 
  %conv21 = trunc i32 %11 to i8
  %conv27 = trunc i32 %13 to i8
Generating MATCH
Match: 
  %11 = lshr i32 %add19, 2
  %13 = lshr i32 %add25, 2
Generating MATCH
Match: 
  %add19 = add nuw nsw i32 %add18, %mul15
  %add25 = add nuw nsw i32 %add24, %conv23
Generating MATCH
Match: 
  %add18 = add nuw nsw i32 %conv17, 1
  %add24 = add nuw nsw i32 %mul15, 2
Generating BINOP
Generating MATCH
Match: 
  %conv17 = zext i8 %10 to i32
  %conv14 = zext i8 %9 to i32
Generating MATCH
Match: 
  %10 = load i8, i8* %arrayidx16, align 1, !tbaa !11
  %9 = load i8, i8* %inptr.0, align 1, !tbaa !11
Generating GEPSEQ
Generating INTSEQ
Gen:   %19 = add i64 %18, -1
Closing GEPSEQ
Gen:   %20 = getelementptr i8, i8* %inptr.0, i64 %19
Operands done!
Generated:   %21 = load i8, i8* %20, align 1
Gen:   %21 = load i8, i8* %20, align 1
Operands done!
Generated:   %22 = zext i8 %21 to i32
Gen:   %22 = zext i8 %21 to i32
Generating INTSEQ
Gen:   %25 = add i32 %24, 1
Closing BINOP
Gen:   %26 = mul nuw nsw i32 %22, %25
Generating INTSEQ
Gen:   %27 = add i32 %23, 1
Operands done!
Generated:   %28 = add nuw nsw i32 %26, %27
Gen:   %28 = add nuw nsw i32 %26, %27
Generating BINOP
Generating MATCH
Match: 
  %conv14 = zext i8 %9 to i32
  %conv23 = zext i8 %12 to i32
Generating MATCH
Match: 
  %9 = load i8, i8* %inptr.0, align 1, !tbaa !11
  %12 = load i8, i8* %incdec.ptr13, align 1, !tbaa !11
Generating GEPSEQ
Generating INTSEQ
Gen:   %18 = zext i8 %17 to i64
Closing GEPSEQ
Found use: 1:   %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
Extracting:   %29 = getelementptr i8, i8* %inptr.0, i64 %18
Gen:   %30 = getelementptr i8, i8* %inptr.0, i64 %19
Operands done!
Generated:   %32 = load i8, i8* %30, align 1
Gen:   %32 = load i8, i8* %30, align 1
Operands done!
Generated:   %33 = zext i8 %32 to i32
Gen:   %33 = zext i8 %32 to i32
Generating INTSEQ
Gen:   %35 = add i32 %34, 3
Closing BINOP
Gen:   %36 = mul nuw nsw i32 %33, %35
Operands done!
Generated:   %37 = add nuw nsw i32 %29, %36
Gen:   %37 = add nuw nsw i32 %29, %36
Generating IDENTICAL
Operands done!
Generated:   %38 = lshr i32 %37, 2
Gen:   %38 = lshr i32 %37, 2
Operands done!
Generated:   %39 = trunc i32 %38 to i8
Gen:   %39 = trunc i32 %38 to i8
Generating ALTSEQ
Values:
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
  %incdec.ptr22 = getelementptr inbounds i8, i8* %.pn, i64 3
Generated Version 4:
  %40 = icmp eq i8 %18, 0
  %41 = select i1 %40, i8* %outptr.0, i8* %incdec.ptr22
Operands done!
Generated:   store i8 %39, i8* %41, align 1
Gen:   store i8 %39, i8* %41, align 1
Graph code generated!
Root:
  store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
  store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="trunc", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="lshr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="mul seq.", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="-1..0, 1", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="1..3, 2", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="1..2, 1", style="filled" , fillcolor="#8ae18a", shape=box];
12 [label="mul seq.", style="filled" , fillcolor="#8ae18a", shape=box];
13 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
15 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
16 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
17 [label="3..1, -2", style="filled" , fillcolor="#8ae18a", shape=box];
18 [label="2", style="filled" , fillcolor="#8ae18a", shape=box];
19 [label="alt: %outptr.0, %incdec.ptr22", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
19->0 
2->1 
3->2 
18->2 
4->3 
12->3 
5->4 
11->4 
6->5 
10->5 
7->6 
8->7 
9->8 
13->12 
17->12 
14->13 
15->14 
16->15 
20 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
15->20
}

Gains: 29 - 44 = -15; Width: 2; Unprofitable; h2v1_fancy_upsample
Trying AGAIN
Creating Node
  store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
  store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv21 = trunc i32 %12 to i8
  %conv27 = trunc i32 %14 to i8
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %12 = lshr i32 %add19, 2
  %14 = lshr i32 %add25, 2
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %add19 = add nuw nsw i32 %add18, %mul15
  %add25 = add nuw nsw i32 %add24, %conv23
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %add18 = add nuw nsw i32 %conv17, 1
  %add24 = add nuw nsw i32 %mul15, 2
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv17 = zext i8 %11 to i32
  %mul15 = mul nuw nsw i32 %conv14, 3
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %conv17 = zext i8 %11 to i32
BinOp Seq
Creating Node
  %conv17 = zext i8 %11 to i32
  %conv14 = zext i8 %10 to i32
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %11 = load i8, i8* %arrayidx16, align 1, !tbaa !11
  %10 = load i8, i8* %inptr.0, align 1, !tbaa !11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %arrayidx16 = getelementptr inbounds i8, i8* %inptr.0, i64 -1
  %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
Match: 0
2 x 2
Final Match: 0
  %arrayidx16 = getelementptr inbounds i8, i8* %inptr.0, i64 -1
  %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
Ptr:   %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
AllGEPs: 0
GEP Seq
Creating Node
i64 -1
i64 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 -1
Int Seq
Creating Node
i32 1
i32 3
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
i32 1
i32 2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
  %mul15 = mul nuw nsw i32 %conv14, 3
  %conv23 = zext i8 %13 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %mul15 = mul nuw nsw i32 %conv14, 3
BinOp Seq
Creating Node
  %conv14 = zext i8 %10 to i32
  %conv23 = zext i8 %13 to i32
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %10 = load i8, i8* %inptr.0, align 1, !tbaa !11
  %13 = load i8, i8* %incdec.ptr13, align 1, !tbaa !11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
  %incdec.ptr13 = getelementptr inbounds i8, i8* %inptr.0, i64 1
Match: 0
2 x 2
Final Match: 0
  %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
  %incdec.ptr13 = getelementptr inbounds i8, i8* %inptr.0, i64 1
Ptr:   %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
Creating Node
i32 3
i32 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 3
Int Seq
Creating Node
i32 2
i32 2
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
  %incdec.ptr22 = getelementptr inbounds i8, i8* %.pn, i64 3
Match: 0
2 x 2
Final Match: 0
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
  %incdec.ptr22 = getelementptr inbounds i8, i8* %.pn, i64 3
GEPSeq2
i8
BinOP?
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
Alt Seq
Already scheduled?!   %10 = load i8, i8* %inptr.0, align 1, !tbaa !11
ScheduleNode: {
  %10 = load i8, i8* %inptr.0, align 1, !tbaa !11
  %11 = load i8, i8* %arrayidx16, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
}
ScheduleNode: {
  %13 = load i8, i8* %incdec.ptr13, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
}
ScheduleNode: {
  %10 = load i8, i8* %inptr.0, align 1, !tbaa !11
  %11 = load i8, i8* %arrayidx16, align 1, !tbaa !11
}
Count: 2
Start:   %incdec.ptr13 = getelementptr inbounds i8, i8* %inptr.0, i64 1
Non-memory:   %incdec.ptr13 = getelementptr inbounds i8, i8* %inptr.0, i64 1
Processing:   %10 = load i8, i8* %inptr.0, align 1, !tbaa !11
Count: 2
Found:   %10 = load i8, i8* %inptr.0, align 1, !tbaa !11
Non-memory:   %conv14 = zext i8 %10 to i32
Non-memory:   %mul15 = mul nuw nsw i32 %conv14, 3
Non-memory:   %arrayidx16 = getelementptr inbounds i8, i8* %inptr.0, i64 -1
Processing:   %11 = load i8, i8* %arrayidx16, align 1, !tbaa !11
Count: 1
Found:   %11 = load i8, i8* %arrayidx16, align 1, !tbaa !11
ScheduleNode: {
  store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
}
Non-memory:   %conv17 = zext i8 %11 to i32
Non-memory:   %add18 = add nuw nsw i32 %conv17, 1
Non-memory:   %add19 = add nuw nsw i32 %add18, %mul15
Non-memory:   %12 = lshr i32 %add19, 2
Non-memory:   %conv21 = trunc i32 %12 to i8
Non-memory:   %incdec.ptr22 = getelementptr inbounds i8, i8* %.pn, i64 3
Processing:   store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
Count: 1
Found:   store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
ScheduleNode: {
  %13 = load i8, i8* %incdec.ptr13, align 1, !tbaa !11
}
Processing:   %13 = load i8, i8* %incdec.ptr13, align 1, !tbaa !11
Count: 1
Found:   %13 = load i8, i8* %incdec.ptr13, align 1, !tbaa !11
ScheduleNode: {
  store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
}
Non-memory:   %conv23 = zext i8 %13 to i32
Non-memory:   %add24 = add nuw nsw i32 %mul15, 2
Non-memory:   %add25 = add nuw nsw i32 %add24, %conv23
Non-memory:   %14 = lshr i32 %add25, 2
Non-memory:   %conv27 = trunc i32 %14 to i8
Processing:   store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
Count: 1
Found:   store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
I:   %dec = add i32 %colctr.0, -1
Last:   br label %for.cond9, !llvm.loop !14
Schedulable: 1
Loop Rolling: h2v1_fancy_upsample
Generating tree
Generating MATCH
Match: 
  store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
  store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
Generating MATCH
Match: 
  %conv21 = trunc i32 %12 to i8
  %conv27 = trunc i32 %14 to i8
Generating MATCH
Match: 
  %12 = lshr i32 %add19, 2
  %14 = lshr i32 %add25, 2
Generating MATCH
Match: 
  %add19 = add nuw nsw i32 %add18, %mul15
  %add25 = add nuw nsw i32 %add24, %conv23
Generating MATCH
Match: 
  %add18 = add nuw nsw i32 %conv17, 1
  %add24 = add nuw nsw i32 %mul15, 2
Generating BINOP
Generating MATCH
Match: 
  %conv17 = zext i8 %11 to i32
  %conv14 = zext i8 %10 to i32
Generating MATCH
Match: 
  %11 = load i8, i8* %arrayidx16, align 1, !tbaa !11
  %10 = load i8, i8* %inptr.0, align 1, !tbaa !11
Generating GEPSEQ
Generating INTSEQ
Gen:   %20 = add i64 %19, -1
Closing GEPSEQ
Gen:   %21 = getelementptr i8, i8* %inptr.0, i64 %20
Operands done!
Generated:   %22 = load i8, i8* %21, align 1
Gen:   %22 = load i8, i8* %21, align 1
Operands done!
Generated:   %23 = zext i8 %22 to i32
Gen:   %23 = zext i8 %22 to i32
Generating INTSEQ
Gen:   %26 = add i32 %25, 1
Closing BINOP
Gen:   %27 = mul nuw nsw i32 %23, %26
Generating INTSEQ
Gen:   %28 = add i32 %24, 1
Operands done!
Generated:   %29 = add nuw nsw i32 %27, %28
Gen:   %29 = add nuw nsw i32 %27, %28
Generating BINOP
Generating MATCH
Match: 
  %conv14 = zext i8 %10 to i32
  %conv23 = zext i8 %13 to i32
Generating MATCH
Match: 
  %10 = load i8, i8* %inptr.0, align 1, !tbaa !11
  %13 = load i8, i8* %incdec.ptr13, align 1, !tbaa !11
Generating GEPSEQ
Generating INTSEQ
Gen:   %19 = zext i8 %18 to i64
Closing GEPSEQ
Found use: 1:   %inptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr13, %for.body12 ]
Extracting:   %30 = getelementptr i8, i8* %inptr.0, i64 %19
Gen:   %31 = getelementptr i8, i8* %inptr.0, i64 %20
Operands done!
Generated:   %33 = load i8, i8* %31, align 1
Gen:   %33 = load i8, i8* %31, align 1
Operands done!
Generated:   %34 = zext i8 %33 to i32
Gen:   %34 = zext i8 %33 to i32
Generating INTSEQ
Gen:   %36 = add i32 %35, 3
Closing BINOP
Gen:   %37 = mul nuw nsw i32 %34, %36
Operands done!
Generated:   %38 = add nuw nsw i32 %30, %37
Gen:   %38 = add nuw nsw i32 %30, %37
Generating IDENTICAL
Operands done!
Generated:   %39 = lshr i32 %38, 2
Gen:   %39 = lshr i32 %38, 2
Operands done!
Generated:   %40 = trunc i32 %39 to i8
Gen:   %40 = trunc i32 %39 to i8
Generating ALTSEQ
Values:
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
  %incdec.ptr22 = getelementptr inbounds i8, i8* %.pn, i64 3
Generated Version 4:
  %41 = icmp eq i8 %19, 0
  %42 = select i1 %41, i8* %outptr.0, i8* %incdec.ptr22
Operands done!
Generated:   store i8 %40, i8* %42, align 1
Gen:   store i8 %40, i8* %42, align 1
Graph code generated!
Root:
  store i8 %conv21, i8* %outptr.0, align 1, !tbaa !11
  store i8 %conv27, i8* %incdec.ptr22, align 1, !tbaa !11
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="trunc", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="lshr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="mul seq.", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="-1..0, 1", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="1..3, 2", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="1..2, 1", style="filled" , fillcolor="#8ae18a", shape=box];
12 [label="mul seq.", style="filled" , fillcolor="#8ae18a", shape=box];
13 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
15 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
16 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
17 [label="3..1, -2", style="filled" , fillcolor="#8ae18a", shape=box];
18 [label="2", style="filled" , fillcolor="#8ae18a", shape=box];
19 [label="alt: %outptr.0, %incdec.ptr22", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
19->0 
2->1 
3->2 
18->2 
4->3 
12->3 
5->4 
11->4 
6->5 
10->5 
7->6 
8->7 
9->8 
13->12 
17->12 
14->13 
15->14 
16->15 
20 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
15->20
}

Gains: 29 - 44 = -15; Width: 2; Unprofitable; h2v1_fancy_upsample
  %inptr.0.lcssa = phi i8* [ %inptr.0, %for.cond9 ]
  %.pn.lcssa = phi i8* [ %.pn, %for.cond9 ]
  %outptr.0.lcssa = phi i8* [ %outptr.0, %for.cond9 ]
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv36, i8* %outptr.0.lcssa, align 1, !tbaa !11
  store i8 %16, i8* %incdec.ptr37, align 1, !tbaa !11
Creating Node
  store i8 %conv36, i8* %outptr.0.lcssa, align 1, !tbaa !11
  store i8 %16, i8* %incdec.ptr37, align 1, !tbaa !11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv36 = trunc i16 %18 to i8
  %16 = load i8, i8* %inptr.0.lcssa, align 1, !tbaa !11
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %conv36 = trunc i16 %18 to i8
Alt Seq
Creating Node
  %outptr.0.lcssa = phi i8* [ %outptr.0, %for.cond9 ]
  %incdec.ptr37 = getelementptr inbounds i8, i8* %.pn.lcssa, i64 3
Match: 0
2 x 2
Final Match: 0
  %outptr.0.lcssa = phi i8* [ %outptr.0, %for.cond9 ]
  %incdec.ptr37 = getelementptr inbounds i8, i8* %.pn.lcssa, i64 3
Ptr:   %.pn.lcssa = phi i8* [ %.pn, %for.cond9 ]
GEPSeq2
BinOP?
  %outptr.0.lcssa = phi i8* [ %outptr.0, %for.cond9 ]
Alt Seq
ScheduleNode: {
  store i8 %conv36, i8* %outptr.0.lcssa, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %16, i8* %incdec.ptr37, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %conv36, i8* %outptr.0.lcssa, align 1, !tbaa !11
}
Count: 1
Start:   store i8 %conv36, i8* %outptr.0.lcssa, align 1, !tbaa !11
Processing:   store i8 %conv36, i8* %outptr.0.lcssa, align 1, !tbaa !11
Count: 1
Found:   store i8 %conv36, i8* %outptr.0.lcssa, align 1, !tbaa !11
ScheduleNode: {
  store i8 %16, i8* %incdec.ptr37, align 1, !tbaa !11
}
Processing:   store i8 %16, i8* %incdec.ptr37, align 1, !tbaa !11
Count: 1
Found:   store i8 %16, i8* %incdec.ptr37, align 1, !tbaa !11
I:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
Last:   br label %for.cond, !llvm.loop !16
Schedulable: 1
Loop Rolling: h2v1_fancy_upsample
Generating tree
Generating MATCH
Match: 
  store i8 %conv36, i8* %outptr.0.lcssa, align 1, !tbaa !11
  store i8 %16, i8* %incdec.ptr37, align 1, !tbaa !11
Generating ALTSEQ
Values:
  %conv36 = trunc i16 %18 to i8
  %16 = load i8, i8* %inptr.0.lcssa, align 1, !tbaa !11
Generated Version 4:
  %20 = icmp eq i8 %19, 0
  %21 = select i1 %20, i8 %conv36, i8 %16
Generating ALTSEQ
Values:
  %outptr.0.lcssa = phi i8* [ %outptr.0, %for.cond9 ]
  %incdec.ptr37 = getelementptr inbounds i8, i8* %.pn.lcssa, i64 3
Generated Version 4:
  %22 = select i1 %20, i8* %outptr.0.lcssa, i8* %incdec.ptr37
Operands done!
Generated:   store i8 %21, i8* %22, align 1
Gen:   store i8 %21, i8* %22, align 1
Graph code generated!
Root:
  store i8 %conv36, i8* %outptr.0.lcssa, align 1, !tbaa !11
  store i8 %16, i8* %incdec.ptr37, align 1, !tbaa !11
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: %conv36, %16", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %outptr.0.lcssa, %incdec.ptr37", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; h2v1_fancy_upsample
Trying AGAIN
Trying AGAIN
looking for reduction
Done Loop Roller: 0/3
Optimizing: h2v1_upsample
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
looking for reduction
  %outptr.0 = phi i8* [ %4, %for.body ], [ %incdec.ptr5, %while.body ]
  %inptr.0 = phi i8* [ %3, %for.body ], [ %incdec.ptr, %while.body ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %6, i8* %outptr.0, align 1, !tbaa !12
  store i8 %6, i8* %incdec.ptr4, align 1, !tbaa !12
Creating Node
  store i8 %6, i8* %outptr.0, align 1, !tbaa !12
  store i8 %6, i8* %incdec.ptr4, align 1, !tbaa !12
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %6 = load i8, i8* %inptr.0, align 1, !tbaa !12
  %6 = load i8, i8* %inptr.0, align 1, !tbaa !12
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %outptr.0 = phi i8* [ %4, %for.body ], [ %incdec.ptr5, %while.body ]
  %incdec.ptr4 = getelementptr inbounds i8, i8* %outptr.0, i64 1
Match: 0
2 x 2
Final Match: 0
  %outptr.0 = phi i8* [ %4, %for.body ], [ %incdec.ptr5, %while.body ]
  %incdec.ptr4 = getelementptr inbounds i8, i8* %outptr.0, i64 1
Ptr:   %outptr.0 = phi i8* [ %4, %for.body ], [ %incdec.ptr5, %while.body ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
ScheduleNode: {
  store i8 %6, i8* %outptr.0, align 1, !tbaa !12
}
ScheduleNode: {
  store i8 %6, i8* %incdec.ptr4, align 1, !tbaa !12
}
ScheduleNode: {
  store i8 %6, i8* %outptr.0, align 1, !tbaa !12
}
Count: 1
Start:   %incdec.ptr4 = getelementptr inbounds i8, i8* %outptr.0, i64 1
Non-memory:   %incdec.ptr4 = getelementptr inbounds i8, i8* %outptr.0, i64 1
Processing:   store i8 %6, i8* %outptr.0, align 1, !tbaa !12
Count: 1
Found:   store i8 %6, i8* %outptr.0, align 1, !tbaa !12
ScheduleNode: {
  store i8 %6, i8* %incdec.ptr4, align 1, !tbaa !12
}
Non-memory:   %incdec.ptr5 = getelementptr inbounds i8, i8* %outptr.0, i64 2
Processing:   store i8 %6, i8* %incdec.ptr4, align 1, !tbaa !12
Count: 1
Found:   store i8 %6, i8* %incdec.ptr4, align 1, !tbaa !12
I:   br label %while.cond, !llvm.loop !13
Last:   br label %while.cond, !llvm.loop !13
Schedulable: 1
Loop Rolling: h2v1_upsample
Generating tree
Generating MATCH
Match: 
  store i8 %6, i8* %outptr.0, align 1, !tbaa !12
  store i8 %6, i8* %incdec.ptr4, align 1, !tbaa !12
Generating IDENTICAL
Generating GEPSEQ
Generating INTSEQ
Gen:   %8 = zext i8 %7 to i64
Closing GEPSEQ
Gen:   %9 = getelementptr i8, i8* %outptr.0, i64 %8
Operands done!
Generated:   store i8 %6, i8* %9, align 1
Gen:   store i8 %6, i8* %9, align 1
Graph code generated!
Root:
  store i8 %6, i8* %outptr.0, align 1, !tbaa !12
  store i8 %6, i8* %incdec.ptr4, align 1, !tbaa !12
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->2 
}

Gains: 5 - 6 = -1; Width: 2; Unprofitable; h2v1_upsample
Trying AGAIN
Trying AGAIN
looking for reduction
Done Loop Roller: 0/1
Optimizing: h2v2_fancy_upsample
  %indvars.iv106 = phi i64 [ %indvars.iv.next107, %for.end64 ], [ 0, %entry ]
  %outrow.0 = phi i32 [ %18, %for.end64 ], [ 0, %entry ]
looking for reduction
  %indvars.iv = phi i64 [ %3, %for.cond.preheader ], [ %indvars.iv.next, %for.end ]
  %v.0 = phi i32 [ 0, %for.cond.preheader ], [ %inc63, %for.end ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv20, i8* %5, align 1, !tbaa !11
  store i8 %conv26, i8* %incdec.ptr21, align 1, !tbaa !11
Creating Node
  store i8 %conv20, i8* %5, align 1, !tbaa !11
  store i8 %conv26, i8* %incdec.ptr21, align 1, !tbaa !11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv20 = trunc i32 %10 to i8
  %conv26 = trunc i32 %shr25 to i8
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %10 = lshr i32 %add19, 4
  %shr25 = lshr i32 %add24, 4
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %add19 = add nuw nsw i32 %mul18, 8
  %add24 = add nuw nsw i32 %add23, %add17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %mul18 = shl nuw nsw i32 %add11, 2
  %add23 = add nuw nsw i32 %mul22, 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %mul18 = shl nuw nsw i32 %add11, 2
BinOp Seq
Creating Node
  %mul18 = shl nuw nsw i32 %add11, 2
  %mul22 = mul nuw nsw i32 %add11, 3
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %mul18 = shl nuw nsw i32 %add11, 2
BinOp Seq
Creating Node
  %mul18 = shl nuw nsw i32 %add11, 2
  %add11 = add nuw nsw i32 %mul, %conv10
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %mul18 = shl nuw nsw i32 %add11, 2
BinOp Seq
Creating Node
  %mul18 = shl nuw nsw i32 %add11, 2
  %mul = mul nuw nsw i32 %conv, 3
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %mul18 = shl nuw nsw i32 %add11, 2
BinOp Seq
Creating Node
  %mul18 = shl nuw nsw i32 %add11, 2
  %conv = zext i8 %6 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %mul18 = shl nuw nsw i32 %add11, 2
Alt Seq
Creating Node
i32 1
i32 3
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
i32 0
  %conv10 = zext i8 %7 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
i32 0
i32 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Int Seq
Creating Node
i32 8
  %add17 = add nuw nsw i32 %mul14, %conv16
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 8
BinOp Seq
Creating Node
i32 8
  %mul14 = mul nuw nsw i32 %conv13, 3
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 8
BinOp Seq
Creating Node
i32 8
  %conv13 = zext i8 %8 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 8
Alt Seq
Creating Node
i32 0
  %conv16 = zext i8 %9 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
i32 4
i32 4
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %5 = load i8*, i8** %arrayidx8, align 8, !tbaa !2
  %incdec.ptr21 = getelementptr inbounds i8, i8* %5, i64 1
Match: 0
2 x 2
Final Match: 0
  %5 = load i8*, i8** %arrayidx8, align 8, !tbaa !2
  %incdec.ptr21 = getelementptr inbounds i8, i8* %5, i64 1
Ptr:   %5 = load i8*, i8** %arrayidx8, align 8, !tbaa !2
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
Invalid:   %add11 = add nuw nsw i32 %mul, %conv10
Invalid dependence found!
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="trunc", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="lshr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="mul seq.", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="mul seq.", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="alt: %mul18, %conv", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="1..3, 2", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="alt: 0, %conv10", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="0..7, 7", style="filled" , fillcolor="#8ae18a", shape=box];
12 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
13 [label="mul seq.", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="alt: 8, %conv13", style="filled" , fillcolor="#8ae18a", shape=box];
15 [label="alt: 0, %conv16", style="filled" , fillcolor="#8ae18a", shape=box];
16 [label="4", style="filled" , fillcolor="#8ae18a", shape=box];
17 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
18 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
17->0 
2->1 
3->2 
16->2 
4->3 
12->3 
5->4 
11->4 
6->5 
9->5 
7->6 
10->6 
8->7 
9->7 
13->12 
15->12 
14->13 
9->13 
18->17 
19 [label="shl", style="filled" , fillcolor="#f2eb5c", shape=box];
6->19
20 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
12->20
}


for.body:                                         ; preds = %for.cond
  %4 = load i8*, i8** %arrayidx, align 8, !tbaa !2
  %cmp2 = icmp eq i32 %v.0, 0
  %idxprom3.pn = select i1 %cmp2, i64 %2, i64 %indvars.iv.next107
  %inptr1.0.in = getelementptr inbounds i8*, i8** %input_data, i64 %idxprom3.pn
  %inptr1.0 = load i8*, i8** %inptr1.0.in, align 8, !tbaa !2
  %arrayidx8 = getelementptr inbounds i8*, i8** %0, i64 %indvars.iv
  %5 = load i8*, i8** %arrayidx8, align 8, !tbaa !2
  %incdec.ptr = getelementptr inbounds i8, i8* %4, i64 1
  %6 = load i8, i8* %4, align 1, !tbaa !11
  %conv = zext i8 %6 to i32
  %mul = mul nuw nsw i32 %conv, 3
  %incdec.ptr9 = getelementptr inbounds i8, i8* %inptr1.0, i64 1
  %7 = load i8, i8* %inptr1.0, align 1, !tbaa !11
  %conv10 = zext i8 %7 to i32
  %add11 = add nuw nsw i32 %mul, %conv10
  %incdec.ptr12 = getelementptr inbounds i8, i8* %4, i64 2
  %8 = load i8, i8* %incdec.ptr, align 1, !tbaa !11
  %conv13 = zext i8 %8 to i32
  %mul14 = mul nuw nsw i32 %conv13, 3
  %incdec.ptr15 = getelementptr inbounds i8, i8* %inptr1.0, i64 2
  %9 = load i8, i8* %incdec.ptr9, align 1, !tbaa !11
  %conv16 = zext i8 %9 to i32
  %add17 = add nuw nsw i32 %mul14, %conv16
  %mul18 = shl nuw nsw i32 %add11, 2
  %add19 = add nuw nsw i32 %mul18, 8
  %10 = lshr i32 %add19, 4
  %conv20 = trunc i32 %10 to i8
  %incdec.ptr21 = getelementptr inbounds i8, i8* %5, i64 1
  store i8 %conv20, i8* %5, align 1, !tbaa !11
  %mul22 = mul nuw nsw i32 %add11, 3
  %add23 = add nuw nsw i32 %mul22, 7
  %add24 = add nuw nsw i32 %add23, %add17
  %shr25 = lshr i32 %add24, 4
  %conv26 = trunc i32 %shr25 to i8
  store i8 %conv26, i8* %incdec.ptr21, align 1, !tbaa !11
  %11 = load i32, i32* %downsampled_width, align 8, !tbaa !12
  %sub28 = add i32 %11, -2
  br label %for.cond29

Trying AGAIN
Trying AGAIN
  %inptr0.0 = phi i8* [ %incdec.ptr12, %for.body ], [ %incdec.ptr33, %for.body32 ]
  %inptr1.1 = phi i8* [ %incdec.ptr15, %for.body ], [ %incdec.ptr36, %for.body32 ]
  %.pn = phi i8* [ %5, %for.body ], [ %outptr.0, %for.body32 ]
  %thiscolsum.0 = phi i32 [ %add17, %for.body ], [ %add38, %for.body32 ]
  %lastcolsum.0 = phi i32 [ %add11, %for.body ], [ %thiscolsum.0, %for.body32 ]
  %colctr.0 = phi i32 [ %sub28, %for.body ], [ %dec, %for.body32 ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv43, i8* %outptr.0, align 1, !tbaa !11
  store i8 %conv49, i8* %incdec.ptr44, align 1, !tbaa !11
Creating Node
  store i8 %conv43, i8* %outptr.0, align 1, !tbaa !11
  store i8 %conv49, i8* %incdec.ptr44, align 1, !tbaa !11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv43 = trunc i32 %14 to i8
  %conv49 = trunc i32 %15 to i8
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %14 = lshr i32 %add41, 4
  %15 = lshr i32 %add47, 4
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %add41 = add nuw nsw i32 %add40, %mul39
  %add47 = add nuw nsw i32 %add46, %add38
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %add40 = add nuw nsw i32 %lastcolsum.0, 8
  %add46 = add nuw nsw i32 %mul39, 7
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %lastcolsum.0 = phi i32 [ %add11, %for.body ], [ %thiscolsum.0, %for.body32 ]
  %mul39 = mul nuw nsw i32 %thiscolsum.0, 3
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %lastcolsum.0 = phi i32 [ %add11, %for.body ], [ %thiscolsum.0, %for.body32 ]
BinOp Seq
Creating Node
  %lastcolsum.0 = phi i32 [ %add11, %for.body ], [ %thiscolsum.0, %for.body32 ]
  %thiscolsum.0 = phi i32 [ %add17, %for.body ], [ %add38, %for.body32 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %lastcolsum.0 = phi i32 [ %add11, %for.body ], [ %thiscolsum.0, %for.body32 ]
Alt Seq
Creating Node
i32 1
i32 3
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
i32 8
i32 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 8
Int Seq
Creating Node
  %mul39 = mul nuw nsw i32 %thiscolsum.0, 3
  %add38 = add nuw nsw i32 %mul35, %conv37
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %mul39 = mul nuw nsw i32 %thiscolsum.0, 3
BinOp Seq
Creating Node
  %mul39 = mul nuw nsw i32 %thiscolsum.0, 3
  %mul35 = mul nuw nsw i32 %conv34, 3
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %thiscolsum.0 = phi i32 [ %add17, %for.body ], [ %add38, %for.body32 ]
  %conv34 = zext i8 %12 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %thiscolsum.0 = phi i32 [ %add17, %for.body ], [ %add38, %for.body32 ]
Alt Seq
Creating Node
i32 3
i32 3
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
i32 0
  %conv37 = zext i8 %13 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
i32 4
i32 4
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
  %incdec.ptr44 = getelementptr inbounds i8, i8* %.pn, i64 3
Match: 0
2 x 2
Final Match: 0
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
  %incdec.ptr44 = getelementptr inbounds i8, i8* %.pn, i64 3
GEPSeq2
i8
BinOP?
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
Alt Seq
ScheduleNode: {
  store i8 %conv43, i8* %outptr.0, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %conv49, i8* %incdec.ptr44, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %conv43, i8* %outptr.0, align 1, !tbaa !11
}
Count: 1
Start:   %mul35 = mul nuw nsw i32 %conv34, 3
Non-memory:   %mul35 = mul nuw nsw i32 %conv34, 3
Non-memory:   %incdec.ptr36 = getelementptr inbounds i8, i8* %inptr1.1, i64 1
Processing:   %13 = load i8, i8* %inptr1.1, align 1, !tbaa !11
Count: 1
Not found:   %13 = load i8, i8* %inptr1.1, align 1, !tbaa !11
Read/Write memory
I:   %13 = load i8, i8* %inptr1.1, align 1, !tbaa !11
Last:   br label %for.cond29, !llvm.loop !14
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="trunc", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="lshr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="mul seq.", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="alt: %lastcolsum.0, %thiscolsum.0", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="1..3, 2", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="8..7, -1", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="mul", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="alt: %thiscolsum.0, %conv34", style="filled" , fillcolor="#8ae18a", shape=box];
12 [label="3", style="filled" , fillcolor="#8ae18a", shape=box];
13 [label="alt: 0, %conv37", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="4", style="filled" , fillcolor="#8ae18a", shape=box];
15 [label="alt: %outptr.0, %incdec.ptr44", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
15->0 
2->1 
3->2 
14->2 
4->3 
9->3 
5->4 
8->4 
6->5 
7->5 
10->9 
13->9 
11->10 
12->10 
16 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
9->16
}


for.body32:                                       ; preds = %for.cond29
  %incdec.ptr33 = getelementptr inbounds i8, i8* %inptr0.0, i64 1
  %12 = load i8, i8* %inptr0.0, align 1, !tbaa !11
  %conv34 = zext i8 %12 to i32
  %mul35 = mul nuw nsw i32 %conv34, 3
  %incdec.ptr36 = getelementptr inbounds i8, i8* %inptr1.1, i64 1
  %13 = load i8, i8* %inptr1.1, align 1, !tbaa !11
  %conv37 = zext i8 %13 to i32
  %add38 = add nuw nsw i32 %mul35, %conv37
  %mul39 = mul nuw nsw i32 %thiscolsum.0, 3
  %add40 = add nuw nsw i32 %lastcolsum.0, 8
  %add41 = add nuw nsw i32 %add40, %mul39
  %14 = lshr i32 %add41, 4
  %conv43 = trunc i32 %14 to i8
  %incdec.ptr44 = getelementptr inbounds i8, i8* %.pn, i64 3
  store i8 %conv43, i8* %outptr.0, align 1, !tbaa !11
  %add46 = add nuw nsw i32 %mul39, 7
  %add47 = add nuw nsw i32 %add46, %add38
  %15 = lshr i32 %add47, 4
  %conv49 = trunc i32 %15 to i8
  store i8 %conv49, i8* %incdec.ptr44, align 1, !tbaa !11
  %dec = add i32 %colctr.0, -1
  br label %for.cond29, !llvm.loop !14

Trying AGAIN
Creating Node
  store i8 %conv43, i8* %outptr.0, align 1, !tbaa !11
  store i8 %conv49, i8* %incdec.ptr44, align 1, !tbaa !11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv43 = trunc i32 %14 to i8
  %conv49 = trunc i32 %15 to i8
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %14 = lshr i32 %add41, 4
  %15 = lshr i32 %add47, 4
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %add41 = add nuw nsw i32 %add40, %mul39
  %add47 = add nuw nsw i32 %add46, %add38
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %add40 = add nuw nsw i32 %lastcolsum.0, 8
  %add46 = add nuw nsw i32 %mul39, 7
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %lastcolsum.0 = phi i32 [ %add11, %for.body ], [ %thiscolsum.0, %for.body32 ]
  %mul39 = mul nuw nsw i32 %thiscolsum.0, 3
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %lastcolsum.0 = phi i32 [ %add11, %for.body ], [ %thiscolsum.0, %for.body32 ]
BinOp Seq
Creating Node
  %lastcolsum.0 = phi i32 [ %add11, %for.body ], [ %thiscolsum.0, %for.body32 ]
  %thiscolsum.0 = phi i32 [ %add17, %for.body ], [ %add38, %for.body32 ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %lastcolsum.0 = phi i32 [ %add11, %for.body ], [ %thiscolsum.0, %for.body32 ]
Alt Seq
Creating Node
i32 1
i32 3
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 1
Int Seq
Creating Node
i32 8
i32 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 8
Int Seq
Creating Node
  %mul39 = mul nuw nsw i32 %thiscolsum.0, 3
  %add38 = add nuw nsw i32 %mul35, %conv37
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %mul39 = mul nuw nsw i32 %thiscolsum.0, 3
BinOp Seq
Creating Node
  %mul39 = mul nuw nsw i32 %thiscolsum.0, 3
  %mul35 = mul nuw nsw i32 %conv34, 3
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %thiscolsum.0 = phi i32 [ %add17, %for.body ], [ %add38, %for.body32 ]
  %conv34 = zext i8 %12 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %thiscolsum.0 = phi i32 [ %add17, %for.body ], [ %add38, %for.body32 ]
Alt Seq
Creating Node
i32 3
i32 3
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
i32 0
  %conv37 = zext i8 %13 to i32
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
i32 4
i32 4
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
  %incdec.ptr44 = getelementptr inbounds i8, i8* %.pn, i64 3
Match: 0
2 x 2
Final Match: 0
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
  %incdec.ptr44 = getelementptr inbounds i8, i8* %.pn, i64 3
GEPSeq2
i8
BinOP?
  %outptr.0 = getelementptr inbounds i8, i8* %.pn, i64 2
Alt Seq
ScheduleNode: {
  store i8 %conv43, i8* %outptr.0, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %conv49, i8* %incdec.ptr44, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %conv43, i8* %outptr.0, align 1, !tbaa !11
}
Count: 1
Start:   %mul35 = mul nuw nsw i32 %conv34, 3
Non-memory:   %mul35 = mul nuw nsw i32 %conv34, 3
Non-memory:   %incdec.ptr36 = getelementptr inbounds i8, i8* %inptr1.1, i64 1
Processing:   %13 = load i8, i8* %inptr1.1, align 1, !tbaa !11
Count: 1
Not found:   %13 = load i8, i8* %inptr1.1, align 1, !tbaa !11
Read/Write memory
I:   %13 = load i8, i8* %inptr1.1, align 1, !tbaa !11
Last:   br label %for.cond29, !llvm.loop !14
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="trunc", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="lshr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="mul seq.", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="alt: %lastcolsum.0, %thiscolsum.0", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="1..3, 2", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="8..7, -1", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="mul", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="alt: %thiscolsum.0, %conv34", style="filled" , fillcolor="#8ae18a", shape=box];
12 [label="3", style="filled" , fillcolor="#8ae18a", shape=box];
13 [label="alt: 0, %conv37", style="filled" , fillcolor="#8ae18a", shape=box];
14 [label="4", style="filled" , fillcolor="#8ae18a", shape=box];
15 [label="alt: %outptr.0, %incdec.ptr44", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
15->0 
2->1 
3->2 
14->2 
4->3 
9->3 
5->4 
8->4 
6->5 
7->5 
10->9 
13->9 
11->10 
12->10 
16 [label="phi", style="filled" , fillcolor="#f2eb5c", shape=box];
9->16
}


for.body32:                                       ; preds = %for.cond29
  %incdec.ptr33 = getelementptr inbounds i8, i8* %inptr0.0, i64 1
  %12 = load i8, i8* %inptr0.0, align 1, !tbaa !11
  %conv34 = zext i8 %12 to i32
  %mul35 = mul nuw nsw i32 %conv34, 3
  %incdec.ptr36 = getelementptr inbounds i8, i8* %inptr1.1, i64 1
  %13 = load i8, i8* %inptr1.1, align 1, !tbaa !11
  %conv37 = zext i8 %13 to i32
  %add38 = add nuw nsw i32 %mul35, %conv37
  %mul39 = mul nuw nsw i32 %thiscolsum.0, 3
  %add40 = add nuw nsw i32 %lastcolsum.0, 8
  %add41 = add nuw nsw i32 %add40, %mul39
  %14 = lshr i32 %add41, 4
  %conv43 = trunc i32 %14 to i8
  %incdec.ptr44 = getelementptr inbounds i8, i8* %.pn, i64 3
  store i8 %conv43, i8* %outptr.0, align 1, !tbaa !11
  %add46 = add nuw nsw i32 %mul39, 7
  %add47 = add nuw nsw i32 %add46, %add38
  %15 = lshr i32 %add47, 4
  %conv49 = trunc i32 %15 to i8
  store i8 %conv49, i8* %incdec.ptr44, align 1, !tbaa !11
  %dec = add i32 %colctr.0, -1
  br label %for.cond29, !llvm.loop !14

  %.pn.lcssa = phi i8* [ %.pn, %for.cond29 ]
  %thiscolsum.0.lcssa = phi i32 [ %thiscolsum.0, %for.cond29 ]
  %lastcolsum.0.lcssa = phi i32 [ %lastcolsum.0, %for.cond29 ]
  %outptr.0.lcssa = phi i8* [ %outptr.0, %for.cond29 ]
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv55, i8* %outptr.0.lcssa, align 1, !tbaa !11
  store i8 %conv60, i8* %incdec.ptr56, align 1, !tbaa !11
Creating Node
  store i8 %conv55, i8* %outptr.0.lcssa, align 1, !tbaa !11
  store i8 %conv60, i8* %incdec.ptr56, align 1, !tbaa !11
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv55 = trunc i32 %16 to i8
  %conv60 = trunc i32 %17 to i8
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %16 = lshr i32 %add53, 4
  %17 = lshr i32 %add58, 4
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %add53 = add nuw nsw i32 %add52, %mul51
  %add58 = add nuw nsw i32 %mul57, 7
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %add52 = add nuw nsw i32 %lastcolsum.0.lcssa, 8
  %mul57 = shl nuw nsw i32 %thiscolsum.0.lcssa, 2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %add52 = add nuw nsw i32 %lastcolsum.0.lcssa, 8
BinOp Seq
Creating Node
  %lastcolsum.0.lcssa = phi i32 [ %lastcolsum.0, %for.cond29 ]
  %mul57 = shl nuw nsw i32 %thiscolsum.0.lcssa, 2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %lastcolsum.0.lcssa = phi i32 [ %lastcolsum.0, %for.cond29 ]
Alt Seq
Creating Node
i32 8
i32 0
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 8
Int Seq
Creating Node
  %mul51 = mul nuw nsw i32 %thiscolsum.0.lcssa, 3
i32 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %mul51 = mul nuw nsw i32 %thiscolsum.0.lcssa, 3
BinOp Seq
Creating Node
  %thiscolsum.0.lcssa = phi i32 [ %thiscolsum.0, %for.cond29 ]
i32 7
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %thiscolsum.0.lcssa = phi i32 [ %thiscolsum.0, %for.cond29 ]
Alt Seq
Creating Node
i32 3
i32 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 3
Int Seq
Creating Node
i32 4
i32 4
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %outptr.0.lcssa = phi i8* [ %outptr.0, %for.cond29 ]
  %incdec.ptr56 = getelementptr inbounds i8, i8* %.pn.lcssa, i64 3
Match: 0
2 x 2
Final Match: 0
  %outptr.0.lcssa = phi i8* [ %outptr.0, %for.cond29 ]
  %incdec.ptr56 = getelementptr inbounds i8, i8* %.pn.lcssa, i64 3
Ptr:   %.pn.lcssa = phi i8* [ %.pn, %for.cond29 ]
GEPSeq2
BinOP?
  %outptr.0.lcssa = phi i8* [ %outptr.0, %for.cond29 ]
Alt Seq
ScheduleNode: {
  store i8 %conv55, i8* %outptr.0.lcssa, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %conv60, i8* %incdec.ptr56, align 1, !tbaa !11
}
ScheduleNode: {
  store i8 %conv55, i8* %outptr.0.lcssa, align 1, !tbaa !11
}
Count: 1
Start:   %mul51 = mul nuw nsw i32 %thiscolsum.0.lcssa, 3
Non-memory:   %mul51 = mul nuw nsw i32 %thiscolsum.0.lcssa, 3
Non-memory:   %add52 = add nuw nsw i32 %lastcolsum.0.lcssa, 8
Non-memory:   %add53 = add nuw nsw i32 %add52, %mul51
Non-memory:   %16 = lshr i32 %add53, 4
Non-memory:   %conv55 = trunc i32 %16 to i8
Non-memory:   %incdec.ptr56 = getelementptr inbounds i8, i8* %.pn.lcssa, i64 3
Processing:   store i8 %conv55, i8* %outptr.0.lcssa, align 1, !tbaa !11
Count: 1
Found:   store i8 %conv55, i8* %outptr.0.lcssa, align 1, !tbaa !11
ScheduleNode: {
  store i8 %conv60, i8* %incdec.ptr56, align 1, !tbaa !11
}
Non-memory:   %mul57 = shl nuw nsw i32 %thiscolsum.0.lcssa, 2
Non-memory:   %add58 = add nuw nsw i32 %mul57, 7
Non-memory:   %17 = lshr i32 %add58, 4
Non-memory:   %conv60 = trunc i32 %17 to i8
Processing:   store i8 %conv60, i8* %incdec.ptr56, align 1, !tbaa !11
Count: 1
Found:   store i8 %conv60, i8* %incdec.ptr56, align 1, !tbaa !11
I:   %inc63 = add nuw nsw i32 %v.0, 1
Last:   br label %for.cond, !llvm.loop !16
Schedulable: 1
Loop Rolling: h2v2_fancy_upsample
Generating tree
Generating MATCH
Match: 
  store i8 %conv55, i8* %outptr.0.lcssa, align 1, !tbaa !11
  store i8 %conv60, i8* %incdec.ptr56, align 1, !tbaa !11
Generating MATCH
Match: 
  %conv55 = trunc i32 %16 to i8
  %conv60 = trunc i32 %17 to i8
Generating MATCH
Match: 
  %16 = lshr i32 %add53, 4
  %17 = lshr i32 %add58, 4
Generating MATCH
Match: 
  %add53 = add nuw nsw i32 %add52, %mul51
  %add58 = add nuw nsw i32 %mul57, 7
Generating BINOP
Generating ALTSEQ
Values:
  %lastcolsum.0.lcssa = phi i32 [ %lastcolsum.0, %for.cond29 ]
  %mul57 = shl nuw nsw i32 %thiscolsum.0.lcssa, 2
Generated Version 4:
  %20 = icmp eq i8 %19, 0
  %21 = select i1 %20, i32 %lastcolsum.0.lcssa, i32 %mul57
Generating INTSEQ
Gen:   %24 = add i32 %23, 8
Closing BINOP
Gen:   %25 = add nuw nsw i32 %21, %24
Generating BINOP
Generating ALTSEQ
Values:
  %thiscolsum.0.lcssa = phi i32 [ %thiscolsum.0, %for.cond29 ]
i32 7
Generated Version 4:
  %26 = select i1 %20, i32 %thiscolsum.0.lcssa, i32 7
Generating INTSEQ
Gen:   %28 = add i32 %27, 3
Closing BINOP
Gen:   %29 = mul nuw nsw i32 %26, %28
Operands done!
Generated:   %30 = add nuw nsw i32 %25, %29
Gen:   %30 = add nuw nsw i32 %25, %29
Generating IDENTICAL
Operands done!
Generated:   %31 = lshr i32 %30, 4
Gen:   %31 = lshr i32 %30, 4
Operands done!
Generated:   %32 = trunc i32 %31 to i8
Gen:   %32 = trunc i32 %31 to i8
Generating ALTSEQ
Values:
  %outptr.0.lcssa = phi i8* [ %outptr.0, %for.cond29 ]
  %incdec.ptr56 = getelementptr inbounds i8, i8* %.pn.lcssa, i64 3
Generated Version 4:
  %33 = select i1 %20, i8* %outptr.0.lcssa, i8* %incdec.ptr56
Operands done!
Generated:   store i8 %32, i8* %33, align 1
Gen:   store i8 %32, i8* %33, align 1
Graph code generated!
Root:
  store i8 %conv55, i8* %outptr.0.lcssa, align 1, !tbaa !11
  store i8 %conv60, i8* %incdec.ptr56, align 1, !tbaa !11
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="trunc", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="lshr", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="add", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="add seq.", style="filled" , fillcolor="#8ae18a", shape=box];
5 [label="alt: %lastcolsum.0.lcssa, %mul57", style="filled" , fillcolor="#8ae18a", shape=box];
6 [label="8..0, -8", style="filled" , fillcolor="#8ae18a", shape=box];
7 [label="mul seq.", style="filled" , fillcolor="#8ae18a", shape=box];
8 [label="alt: %thiscolsum.0.lcssa, 7", style="filled" , fillcolor="#8ae18a", shape=box];
9 [label="3..1, -2", style="filled" , fillcolor="#8ae18a", shape=box];
10 [label="4", style="filled" , fillcolor="#8ae18a", shape=box];
11 [label="alt: %outptr.0.lcssa, %incdec.ptr56", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
11->0 
2->1 
3->2 
10->2 
4->3 
7->3 
5->4 
6->4 
8->7 
9->7 
}

Gains: 17 - 22 = -5; Width: 2; Unprofitable; h2v2_fancy_upsample
Trying AGAIN
Trying AGAIN
  %indvars.iv.lcssa = phi i64 [ %indvars.iv, %for.cond ]
looking for reduction
Done Loop Roller: 0/1
Optimizing: h2v2_upsample
  %indvars.iv30 = phi i64 [ %indvars.iv.next31, %while.end ], [ 0, %entry ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %while.end ], [ 0, %entry ]
  %outrow.0 = phi i32 [ %add9, %while.end ], [ 0, %entry ]
looking for reduction
  %outptr.0 = phi i8* [ %4, %while.body ], [ %incdec.ptr7, %while.body5 ]
  %inptr.0 = phi i8* [ %3, %while.body ], [ %incdec.ptr, %while.body5 ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i8 %6, i8* %outptr.0, align 1, !tbaa !12
  store i8 %6, i8* %incdec.ptr6, align 1, !tbaa !12
Creating Node
  store i8 %6, i8* %outptr.0, align 1, !tbaa !12
  store i8 %6, i8* %incdec.ptr6, align 1, !tbaa !12
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %6 = load i8, i8* %inptr.0, align 1, !tbaa !12
  %6 = load i8, i8* %inptr.0, align 1, !tbaa !12
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %outptr.0 = phi i8* [ %4, %while.body ], [ %incdec.ptr7, %while.body5 ]
  %incdec.ptr6 = getelementptr inbounds i8, i8* %outptr.0, i64 1
Match: 0
2 x 2
Final Match: 0
  %outptr.0 = phi i8* [ %4, %while.body ], [ %incdec.ptr7, %while.body5 ]
  %incdec.ptr6 = getelementptr inbounds i8, i8* %outptr.0, i64 1
Ptr:   %outptr.0 = phi i8* [ %4, %while.body ], [ %incdec.ptr7, %while.body5 ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 1
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
ScheduleNode: {
  store i8 %6, i8* %outptr.0, align 1, !tbaa !12
}
ScheduleNode: {
  store i8 %6, i8* %incdec.ptr6, align 1, !tbaa !12
}
ScheduleNode: {
  store i8 %6, i8* %outptr.0, align 1, !tbaa !12
}
Count: 1
Start:   %incdec.ptr6 = getelementptr inbounds i8, i8* %outptr.0, i64 1
Non-memory:   %incdec.ptr6 = getelementptr inbounds i8, i8* %outptr.0, i64 1
Processing:   store i8 %6, i8* %outptr.0, align 1, !tbaa !12
Count: 1
Found:   store i8 %6, i8* %outptr.0, align 1, !tbaa !12
ScheduleNode: {
  store i8 %6, i8* %incdec.ptr6, align 1, !tbaa !12
}
Non-memory:   %incdec.ptr7 = getelementptr inbounds i8, i8* %outptr.0, i64 2
Processing:   store i8 %6, i8* %incdec.ptr6, align 1, !tbaa !12
Count: 1
Found:   store i8 %6, i8* %incdec.ptr6, align 1, !tbaa !12
I:   br label %while.cond3, !llvm.loop !13
Last:   br label %while.cond3, !llvm.loop !13
Schedulable: 1
Loop Rolling: h2v2_upsample
Generating tree
Generating MATCH
Match: 
  store i8 %6, i8* %outptr.0, align 1, !tbaa !12
  store i8 %6, i8* %incdec.ptr6, align 1, !tbaa !12
Generating IDENTICAL
Generating GEPSEQ
Generating INTSEQ
Gen:   %10 = zext i8 %9 to i64
Closing GEPSEQ
Gen:   %11 = getelementptr i8, i8* %outptr.0, i64 %10
Operands done!
Generated:   store i8 %6, i8* %11, align 1
Gen:   store i8 %6, i8* %11, align 1
Graph code generated!
Root:
  store i8 %6, i8* %outptr.0, align 1, !tbaa !12
  store i8 %6, i8* %incdec.ptr6, align 1, !tbaa !12
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="0..1, 1", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->2 
}

Gains: 5 - 6 = -1; Width: 2; Unprofitable; h2v2_upsample
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add = or i32 %outrow.0, 1
looking for reduction
looking for reduction
Attempting Group:
  tail call void @jcopy_sample_rows(i8** %0, i32 %8, i8** %0, i32 %add, i32 1, i32 %7) #4
looking for reduction
Done Loop Roller: 0/1
Optimizing: int_upsample
  %indvars.iv52 = phi i64 [ %indvars.iv.next53, %if.end ], [ 0, %entry ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end ], [ 0, %entry ]
  %outrow.0 = phi i32 [ %add23, %if.end ], [ 0, %entry ]
looking for reduction
  %outptr.1.lcssa = phi i8* [ %outptr.1, %for.cond ]
  %outptr.0 = phi i8* [ %10, %while.body ], [ %outptr.1.lcssa, %while.cond13.loopexit ]
  %inptr.0 = phi i8* [ %9, %while.body ], [ %incdec.ptr, %while.cond13.loopexit ]
looking for reduction
  %h.0 = phi i32 [ %conv, %while.body16 ], [ %dec, %for.body ]
  %outptr.1 = phi i8* [ %outptr.0, %while.body16 ], [ %incdec.ptr19, %for.body ]
looking for reduction
looking for reduction
Attempting Group:
  store i8 %12, i8* %outptr.1, align 1, !tbaa !13
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add = add nuw nsw i32 %outrow.0, 1
looking for reduction
  %sub = add nsw i32 %conv7, -1
looking for reduction
Attempting Group:
  tail call void @jcopy_sample_rows(i8** %2, i32 %14, i8** %2, i32 %add, i32 %sub, i32 %13) #4
looking for reduction
Done Loop Roller: 0/0
Nothing found in: int_upsample
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/ctuning-rtl.c -o src/ctuning-rtl.o   -mllvm -reroll-loops=3
Optimizing: main
looking for reduction
looking for reduction
Attempting Group:
  %call = tail call i8* @getenv(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str, i64 0, i64 0)) #3
looking for reduction
looking for reduction
Attempting Group:
  %call2 = tail call i64 @atol(i8* nonnull %call) #4
  %ct_repeat_max.010 = phi i64 [ %call2, %if.end ], [ 1, %entry ]
  %2 = phi i64 [ %ct_repeat_max.010, %if.end.thread ], [ 0, %if.end ]
  %ct_repeat.0 = phi i64 [ 0, %1 ], [ %inc, %for.body ]
  %ct_return.0 = phi i32 [ 0, %1 ], [ %call4, %for.body ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  %call4 = tail call i32 @main1(i32 %argc, i8** %argv) #3
  %ct_return.0.lcssa = phi i32 [ %ct_return.0, %for.cond ]
looking for reduction
Done Loop Roller: 0/0
Nothing found in: main
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jidctint.c -o src/jidctint.o   -mllvm -reroll-loops=3
Optimizing: jpeg_idct_islow
looking for reduction
looking for reduction
  %inptr.0 = phi i16* [ %coef_block, %entry ], [ %inptr.1, %for.inc ]
  %quantptr.0 = phi i32* [ %3, %entry ], [ %quantptr.1, %for.inc ]
  %wsptr.0 = phi i32* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %ctr.0 = phi i32 [ 8, %entry ], [ %dec, %for.inc ]
looking for reduction
looking for reduction
looking for reduction
  %shl = mul i32 %mul, %12
looking for reduction
  %shl = mul i32 %mul, %12
looking for reduction
  %shl = mul i32 %mul, %12
looking for reduction
  %shl = mul i32 %mul, %12
looking for reduction
  %shl = mul i32 %mul, %12
looking for reduction
  %shl = mul i32 %mul, %12
looking for reduction
  %shl = mul i32 %mul, %12
Attempting Group:
  store i32 %shl, i32* %wsptr.0, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx24, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx25, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx26, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx27, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx28, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx29, align 4, !tbaa !13
Creating Node
  store i32 %shl, i32* %wsptr.0, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx24, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx25, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx26, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx27, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx28, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx29, align 4, !tbaa !13
Match: 1
7 x 7
Final Match: 1
Matching
Creating Node
  %shl = mul i32 %mul, %12
  %shl = mul i32 %mul, %12
  %shl = mul i32 %mul, %12
  %shl = mul i32 %mul, %12
  %shl = mul i32 %mul, %12
  %shl = mul i32 %mul, %12
  %shl = mul i32 %mul, %12
Match: 1
1 x 7
Final Match: 1
All the Same
Creating Node
  %wsptr.0 = phi i32* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %arrayidx24 = getelementptr inbounds i32, i32* %wsptr.0, i64 8
  %arrayidx25 = getelementptr inbounds i32, i32* %wsptr.0, i64 16
  %arrayidx26 = getelementptr inbounds i32, i32* %wsptr.0, i64 24
  %arrayidx27 = getelementptr inbounds i32, i32* %wsptr.0, i64 32
  %arrayidx28 = getelementptr inbounds i32, i32* %wsptr.0, i64 40
  %arrayidx29 = getelementptr inbounds i32, i32* %wsptr.0, i64 48
Match: 0
7 x 7
Final Match: 0
  %wsptr.0 = phi i32* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
  %arrayidx24 = getelementptr inbounds i32, i32* %wsptr.0, i64 8
  %arrayidx25 = getelementptr inbounds i32, i32* %wsptr.0, i64 16
  %arrayidx26 = getelementptr inbounds i32, i32* %wsptr.0, i64 24
  %arrayidx27 = getelementptr inbounds i32, i32* %wsptr.0, i64 32
  %arrayidx28 = getelementptr inbounds i32, i32* %wsptr.0, i64 40
  %arrayidx29 = getelementptr inbounds i32, i32* %wsptr.0, i64 48
Ptr:   %wsptr.0 = phi i32* [ %arraydecay, %entry ], [ %wsptr.1, %for.inc ]
AllGEPs: 0
GEP Seq
Creating Node
i64 0
i64 8
i64 16
i64 24
i64 32
i64 40
i64 48
Match: 0
7 x 7
Final Match: 0
GEPSeq2
BinOP?
i64 0
Int Seq
ScheduleNode: {
  store i32 %shl, i32* %wsptr.0, align 4, !tbaa !13
}
ScheduleNode: {
  store i32 %shl, i32* %arrayidx24, align 4, !tbaa !13
}
ScheduleNode: {
  store i32 %shl, i32* %arrayidx25, align 4, !tbaa !13
}
ScheduleNode: {
  store i32 %shl, i32* %arrayidx26, align 4, !tbaa !13
}
ScheduleNode: {
  store i32 %shl, i32* %arrayidx27, align 4, !tbaa !13
}
ScheduleNode: {
  store i32 %shl, i32* %arrayidx28, align 4, !tbaa !13
}
ScheduleNode: {
  store i32 %shl, i32* %arrayidx29, align 4, !tbaa !13
}
ScheduleNode: {
  store i32 %shl, i32* %wsptr.0, align 4, !tbaa !13
}
Count: 1
Start:   store i32 %shl, i32* %wsptr.0, align 4, !tbaa !13
Processing:   store i32 %shl, i32* %wsptr.0, align 4, !tbaa !13
Count: 1
Found:   store i32 %shl, i32* %wsptr.0, align 4, !tbaa !13
ScheduleNode: {
  store i32 %shl, i32* %arrayidx24, align 4, !tbaa !13
}
Non-memory:   %arrayidx24 = getelementptr inbounds i32, i32* %wsptr.0, i64 8
Processing:   store i32 %shl, i32* %arrayidx24, align 4, !tbaa !13
Count: 1
Found:   store i32 %shl, i32* %arrayidx24, align 4, !tbaa !13
ScheduleNode: {
  store i32 %shl, i32* %arrayidx25, align 4, !tbaa !13
}
Non-memory:   %arrayidx25 = getelementptr inbounds i32, i32* %wsptr.0, i64 16
Processing:   store i32 %shl, i32* %arrayidx25, align 4, !tbaa !13
Count: 1
Found:   store i32 %shl, i32* %arrayidx25, align 4, !tbaa !13
ScheduleNode: {
  store i32 %shl, i32* %arrayidx26, align 4, !tbaa !13
}
Non-memory:   %arrayidx26 = getelementptr inbounds i32, i32* %wsptr.0, i64 24
Processing:   store i32 %shl, i32* %arrayidx26, align 4, !tbaa !13
Count: 1
Found:   store i32 %shl, i32* %arrayidx26, align 4, !tbaa !13
ScheduleNode: {
  store i32 %shl, i32* %arrayidx27, align 4, !tbaa !13
}
Non-memory:   %arrayidx27 = getelementptr inbounds i32, i32* %wsptr.0, i64 32
Processing:   store i32 %shl, i32* %arrayidx27, align 4, !tbaa !13
Count: 1
Found:   store i32 %shl, i32* %arrayidx27, align 4, !tbaa !13
ScheduleNode: {
  store i32 %shl, i32* %arrayidx28, align 4, !tbaa !13
}
Non-memory:   %arrayidx28 = getelementptr inbounds i32, i32* %wsptr.0, i64 40
Processing:   store i32 %shl, i32* %arrayidx28, align 4, !tbaa !13
Count: 1
Found:   store i32 %shl, i32* %arrayidx28, align 4, !tbaa !13
ScheduleNode: {
  store i32 %shl, i32* %arrayidx29, align 4, !tbaa !13
}
Non-memory:   %arrayidx29 = getelementptr inbounds i32, i32* %wsptr.0, i64 48
Processing:   store i32 %shl, i32* %arrayidx29, align 4, !tbaa !13
Count: 1
Found:   store i32 %shl, i32* %arrayidx29, align 4, !tbaa !13
I:   br label %for.inc
Last:   br label %for.inc
Schedulable: 1
Loop Rolling: jpeg_idct_islow
Generating tree
Generating MATCH
Match: 
  store i32 %shl, i32* %wsptr.0, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx24, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx25, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx26, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx27, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx28, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx29, align 4, !tbaa !13
Generating IDENTICAL
Generating GEPSEQ
Generating INTSEQ
Gen:   %62 = add i64 %61, 0
Closing GEPSEQ
Gen:   %63 = getelementptr i32, i32* %wsptr.0, i64 %62
Operands done!
Generated:   store i32 %shl, i32* %63, align 1
Gen:   store i32 %shl, i32* %63, align 1
Graph code generated!
Root:
  store i32 %shl, i32* %wsptr.0, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx24, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx25, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx26, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx27, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx28, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx29, align 4, !tbaa !13
Root size: 7
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="mul", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="GEP seq.", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="0..48, 8", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
3->2 
}

Gains: 20 - 12 = 8; Width: 7; Profitable; jpeg_idct_islow

if.then:                                          ; preds = %for.body
  %11 = load i16, i16* %inptr.0, align 2, !tbaa !12
  %conv21 = sext i16 %11 to i32
  %12 = load i32, i32* %quantptr.0, align 4, !tbaa !13
  %mul = shl nsw i32 %conv21, 2
  %shl = mul i32 %mul, %12
  %arrayidx24 = getelementptr inbounds i32, i32* %wsptr.0, i64 8
  %arrayidx25 = getelementptr inbounds i32, i32* %wsptr.0, i64 16
  %arrayidx26 = getelementptr inbounds i32, i32* %wsptr.0, i64 24
  %arrayidx27 = getelementptr inbounds i32, i32* %wsptr.0, i64 32
  %arrayidx28 = getelementptr inbounds i32, i32* %wsptr.0, i64 40
  %arrayidx29 = getelementptr inbounds i32, i32* %wsptr.0, i64 48
  br label %rolled.pre


rolled.pre:                                       ; preds = %if.then
  br label %rolled.loop


rolled.loop:                                      ; preds = %rolled.pre, %rolled.loop
  %59 = phi i8 [ 0, %rolled.pre ], [ %64, %rolled.loop ]
  %60 = zext i8 %59 to i64
  %61 = mul i64 %60, 8
  %62 = add i64 %61, 0
  %63 = getelementptr i32, i32* %wsptr.0, i64 %62
  store i32 %shl, i32* %63, align 1
  %64 = add i8 %59, 1
  %65 = icmp ne i8 %64, 7
  br i1 %65, label %rolled.loop, label %rolled.exit


rolled.exit:                                      ; preds = %rolled.loop
  store i32 %shl, i32* %wsptr.0, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx24, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx25, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx26, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx27, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx28, align 4, !tbaa !13
  store i32 %shl, i32* %arrayidx29, align 4, !tbaa !13
  br label %for.inc

Done!
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %conv116.sink = phi i32 [ %shl, %rolled.exit ], [ %conv116, %if.end ]
looking for reduction
  %indvars.iv = phi i64 [ 0, %for.cond152.preheader ], [ %indvars.iv.next, %for.inc315 ]
  %wsptr.2 = phi i32* [ %arraydecay, %for.cond152.preheader ], [ %wsptr.3, %for.inc315 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 1/1
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jcapimin.c -o src/jcapimin.o   -mllvm -reroll-loops=3
Optimizing: jpeg_CreateCompress
looking for reduction
looking for reduction
Attempting Group:
  store %struct.jpeg_memory_mgr* null, %struct.jpeg_memory_mgr** %mem, align 8, !tbaa !2
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %version, i32* %arrayidx6, align 4, !tbaa !14
Attempting Group:
  store i32 10, i32* %msg_code, align 8, !tbaa !11
  store i32 61, i32* %arrayidx, align 4, !tbaa !14
Creating Node
  store i32 10, i32* %msg_code, align 8, !tbaa !11
  store i32 61, i32* %arrayidx, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 10
i32 61
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 10
Int Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 10, i32* %msg_code, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 61, i32* %arrayidx, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 10, i32* %msg_code, align 8, !tbaa !11
}
Count: 1
Start:   store i32 10, i32* %msg_code, align 8, !tbaa !11
Processing:   store i32 10, i32* %msg_code, align 8, !tbaa !11
Count: 1
Found:   store i32 10, i32* %msg_code, align 8, !tbaa !11
ScheduleNode: {
  store i32 61, i32* %arrayidx, align 4, !tbaa !14
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 61, i32* %arrayidx, align 4, !tbaa !14
Count: 1
Found:   store i32 61, i32* %arrayidx, align 4, !tbaa !14
I:   %1 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !10
Last:   br label %if.end
Schedulable: 1
Loop Rolling: jpeg_CreateCompress
Generating tree
Generating MATCH
Match: 
  store i32 10, i32* %msg_code, align 8, !tbaa !11
  store i32 61, i32* %arrayidx, align 4, !tbaa !14
Generating INTSEQ
Gen:   %16 = add i32 %15, 10
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %0, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %17 = icmp eq i8 %13, 0
  %18 = select i1 %17, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %16, i32* %18, align 1
Gen:   store i32 %16, i32* %18, align 1
Graph code generated!
Root:
  store i32 10, i32* %msg_code, align 8, !tbaa !11
  store i32 61, i32* %arrayidx, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="10..61, 51", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; jpeg_CreateCompress
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %conv, i32* %arrayidx19, align 4, !tbaa !14
Attempting Group:
  store i32 19, i32* %msg_code11, align 8, !tbaa !11
  store i32 496, i32* %arrayidx15, align 4, !tbaa !14
Creating Node
  store i32 19, i32* %msg_code11, align 8, !tbaa !11
  store i32 496, i32* %arrayidx15, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 19
i32 496
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 19
Int Seq
Creating Node
  %msg_code11 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %5, i64 0, i32 5
  %arrayidx15 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %5, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code11 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %5, i64 0, i32 5
  %arrayidx15 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %5, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code11 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %5, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 19, i32* %msg_code11, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 496, i32* %arrayidx15, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 19, i32* %msg_code11, align 8, !tbaa !11
}
Count: 1
Start:   store i32 19, i32* %msg_code11, align 8, !tbaa !11
Processing:   store i32 19, i32* %msg_code11, align 8, !tbaa !11
Count: 1
Found:   store i32 19, i32* %msg_code11, align 8, !tbaa !11
ScheduleNode: {
  store i32 496, i32* %arrayidx15, align 4, !tbaa !14
}
Non-memory:   %arrayidx15 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %5, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 496, i32* %arrayidx15, align 4, !tbaa !14
Count: 1
Found:   store i32 496, i32* %arrayidx15, align 4, !tbaa !14
I:   %conv = trunc i64 %structsize to i32
Last:   br label %if.end22
Schedulable: 1
Loop Rolling: jpeg_CreateCompress
Generating tree
Generating MATCH
Match: 
  store i32 19, i32* %msg_code11, align 8, !tbaa !11
  store i32 496, i32* %arrayidx15, align 4, !tbaa !14
Generating INTSEQ
Gen:   %16 = add i32 %15, 19
Generating ALTSEQ
Values:
  %msg_code11 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %5, i64 0, i32 5
  %arrayidx15 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %5, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %17 = icmp eq i8 %13, 0
  %18 = select i1 %17, i32* %msg_code11, i32* %arrayidx15
Operands done!
Generated:   store i32 %16, i32* %18, align 1
Gen:   store i32 %16, i32* %18, align 1
Graph code generated!
Root:
  store i32 19, i32* %msg_code11, align 8, !tbaa !11
  store i32 496, i32* %arrayidx15, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="19..496, 477", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code11, %arrayidx15", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 10 = -6; Width: 2; Unprofitable; jpeg_CreateCompress
Trying AGAIN
Trying AGAIN
  %.pre-phi = phi %struct.jpeg_common_struct* [ %.pre, %if.end.if.end22_crit_edge ], [ %9, %if.then9 ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store %struct.jpeg_error_mgr* %10, %struct.jpeg_error_mgr** %err24, align 8, !tbaa !10
Attempting Group:
  tail call void @jinit_memory_mgr(%struct.jpeg_common_struct* %.pre-phi) #3
Attempting Group:
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 1 dereferenceable(496) %12, i8 0, i64 488, i1 false)
  %indvars.iv73 = phi i64 [ %indvars.iv.next74, %for.body ], [ 0, %if.end22 ]
looking for reduction
looking for reduction
Attempting Group:
  store %struct.JQUANT_TBL* null, %struct.JQUANT_TBL** %arrayidx28, align 8, !tbaa !20
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body32 ], [ 0, %for.cond29.preheader ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx34, align 8, !tbaa !20
  store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx36, align 8, !tbaa !20
Creating Node
  store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx34, align 8, !tbaa !20
  store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx36, align 8, !tbaa !20
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
%struct.JHUFF_TBL* null
%struct.JHUFF_TBL* null
Match: 1
1 x 2
Final Match: 1
All the Same
Creating Node
  %arrayidx34 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 16, i64 %indvars.iv
  %arrayidx36 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 17, i64 %indvars.iv
Match: 0
2 x 2
Final Match: 0
  %arrayidx34 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 16, i64 %indvars.iv
  %arrayidx36 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 17, i64 %indvars.iv
GEPSeq2
BinOP?
  %arrayidx34 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 16, i64 %indvars.iv
Alt Seq
ScheduleNode: {
  store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx34, align 8, !tbaa !20
}
ScheduleNode: {
  store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx36, align 8, !tbaa !20
}
ScheduleNode: {
  store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx34, align 8, !tbaa !20
}
Count: 1
Start:   store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx34, align 8, !tbaa !20
Processing:   store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx34, align 8, !tbaa !20
Count: 1
Found:   store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx34, align 8, !tbaa !20
ScheduleNode: {
  store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx36, align 8, !tbaa !20
}
Non-memory:   %arrayidx36 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 17, i64 %indvars.iv
Processing:   store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx36, align 8, !tbaa !20
Count: 1
Found:   store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx36, align 8, !tbaa !20
I:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
Last:   br label %for.cond29, !llvm.loop !23
Schedulable: 1
Loop Rolling: jpeg_CreateCompress
Generating tree
Generating MATCH
Match: 
  store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx34, align 8, !tbaa !20
  store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx36, align 8, !tbaa !20
Generating IDENTICAL
Generating ALTSEQ
Values:
  %arrayidx34 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 16, i64 %indvars.iv
  %arrayidx36 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 17, i64 %indvars.iv
Generated Version 4:
  %14 = icmp eq i8 %13, 0
  %15 = select i1 %14, %struct.JHUFF_TBL** %arrayidx34, %struct.JHUFF_TBL** %arrayidx36
Operands done!
Generated:   store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %15, align 1
Gen:   store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %15, align 1
Graph code generated!
Root:
  store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx34, align 8, !tbaa !20
  store %struct.JHUFF_TBL* null, %struct.JHUFF_TBL** %arrayidx36, align 8, !tbaa !20
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="null", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %arrayidx34, %arrayidx36", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 5 = -1; Width: 2; Unprofitable; jpeg_CreateCompress
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store double 1.000000e+00, double* %input_gamma, align 8, !tbaa !24
Done Loop Roller: 0/3
Optimizing: jpeg_destroy_compress
looking for reduction
looking for reduction
Attempting Group:
  tail call void @jpeg_destroy(%struct.jpeg_common_struct* %0) #3
Done Loop Roller: 0/0
Nothing found in: jpeg_destroy_compress
Optimizing: jpeg_abort_compress
looking for reduction
looking for reduction
Attempting Group:
  tail call void @jpeg_abort(%struct.jpeg_common_struct* %0) #3
Done Loop Roller: 0/0
Nothing found in: jpeg_abort_compress
Optimizing: jpeg_suppress_tables
  %indvars.iv36 = phi i64 [ %indvars.iv.next37, %for.inc ], [ 0, %entry ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %suppress, i32* %sent_table, align 4, !tbaa !6
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc17 ], [ 0, %for.cond2.preheader ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %suppress, i32* %sent_table9, align 4, !tbaa !11
looking for reduction
looking for reduction
Attempting Group:
  store i32 %suppress, i32* %sent_table15, align 4, !tbaa !11
looking for reduction
Done Loop Roller: 0/0
Nothing found in: jpeg_suppress_tables
Optimizing: jpeg_finish_compress
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 66, i32* %msg_code, align 8, !tbaa !13
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 18, i32* %msg_code10, align 8, !tbaa !13
  store i32 %0, i32* %arrayidx, align 4, !tbaa !20
Creating Node
  store i32 18, i32* %msg_code10, align 8, !tbaa !13
  store i32 %0, i32* %arrayidx, align 4, !tbaa !20
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 18
Alt Seq
Creating Node
  %msg_code10 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code10 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code10 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 18, i32* %msg_code10, align 8, !tbaa !13
}
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !20
}
ScheduleNode: {
  store i32 18, i32* %msg_code10, align 8, !tbaa !13
}
Count: 1
Start:   store i32 18, i32* %msg_code10, align 8, !tbaa !13
Processing:   store i32 18, i32* %msg_code10, align 8, !tbaa !13
Count: 1
Found:   store i32 18, i32* %msg_code10, align 8, !tbaa !13
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !20
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %0, i32* %arrayidx, align 4, !tbaa !20
Count: 1
Found:   store i32 %0, i32* %arrayidx, align 4, !tbaa !20
I:   %9 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err9, align 8, !tbaa !12
Last:   br label %if.end16
Schedulable: 1
Loop Rolling: jpeg_finish_compress
Generating tree
Generating MATCH
Match: 
  store i32 18, i32* %msg_code10, align 8, !tbaa !13
  store i32 %0, i32* %arrayidx, align 4, !tbaa !20
Generating ALTSEQ
Values:
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Generated Version 4:
  %32 = icmp eq i8 %31, 0
  %33 = select i1 %32, i32 18, i32 %0
Generating ALTSEQ
Values:
  %msg_code10 = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %8, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %34 = select i1 %32, i32* %msg_code10, i32* %arrayidx
Operands done!
Generated:   store i32 %33, i32* %34, align 1
Gen:   store i32 %33, i32* %34, align 1
Graph code generated!
Root:
  store i32 18, i32* %msg_code10, align 8, !tbaa !13
  store i32 %0, i32* %arrayidx, align 4, !tbaa !20
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 18, %0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code10, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jpeg_finish_compress
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %while.body ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !25
  store i64 %17, i64* %pass_limit, align 8, !tbaa !27
Creating Node
  store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !25
  store i64 %17, i64* %pass_limit, align 8, !tbaa !27
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %while.body ]
  %17 = zext i32 %16 to i64
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %while.body ]
Alt Seq
Creating Node
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %18, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %18, i64 0, i32 2
Match: 0
2 x 2
Final Match: 0
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %18, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %18, i64 0, i32 2
GEPSeq2
%struct.jpeg_progress_mgr = type { {}*, i64, i64, i32, i32 }
BinOP?
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %18, i64 0, i32 1
Alt Seq
ScheduleNode: {
  store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !25
}
ScheduleNode: {
  store i64 %17, i64* %pass_limit, align 8, !tbaa !27
}
ScheduleNode: {
  store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !25
}
Count: 1
Start:   store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !25
Processing:   store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !25
Count: 1
Found:   store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !25
ScheduleNode: {
  store i64 %17, i64* %pass_limit, align 8, !tbaa !27
}
Non-memory:   %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %18, i64 0, i32 2
Processing:   store i64 %17, i64* %pass_limit, align 8, !tbaa !27
Count: 1
Found:   store i64 %17, i64* %pass_limit, align 8, !tbaa !27
I:   %20 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %19, align 8, !tbaa !28
Last:   br label %if.end28
Schedulable: 1
Loop Rolling: jpeg_finish_compress
Generating tree
Generating MATCH
Match: 
  store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !25
  store i64 %17, i64* %pass_limit, align 8, !tbaa !27
Generating ALTSEQ
Values:
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %while.body ]
  %17 = zext i32 %16 to i64
Generated Version 4:
  %32 = icmp eq i8 %31, 0
  %33 = select i1 %32, i64 %indvars.iv, i64 %17
Generating ALTSEQ
Values:
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %18, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %18, i64 0, i32 2
Generated Version 4:
  %34 = select i1 %32, i64* %pass_counter, i64* %pass_limit
Operands done!
Generated:   store i64 %33, i64* %34, align 1
Gen:   store i64 %33, i64* %34, align 1
Graph code generated!
Root:
  store i64 %indvars.iv, i64* %pass_counter, align 8, !tbaa !25
  store i64 %17, i64* %pass_limit, align 8, !tbaa !27
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: %indvars.iv, %17", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %pass_counter, %pass_limit", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jpeg_finish_compress
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 22, i32* %msg_code32, align 8, !tbaa !13
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call void @jpeg_abort(%struct.jpeg_common_struct* nonnull %12) #4
Done Loop Roller: 0/2
Optimizing: jpeg_write_marker
looking for reduction
looking for reduction
  %2 = phi i32 [ %.pre, %entry.if.then_crit_edge ], [ %1, %lor.lhs.false ]
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 18, i32* %msg_code, align 8, !tbaa !12
  store i32 %2, i32* %arrayidx, align 4, !tbaa !15
Creating Node
  store i32 18, i32* %msg_code, align 8, !tbaa !12
  store i32 %2, i32* %arrayidx, align 4, !tbaa !15
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 18
  %2 = phi i32 [ %.pre, %entry.if.then_crit_edge ], [ %1, %lor.lhs.false ]
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 18
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !12
}
ScheduleNode: {
  store i32 %2, i32* %arrayidx, align 4, !tbaa !15
}
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !12
}
Count: 1
Start:   store i32 18, i32* %msg_code, align 8, !tbaa !12
Processing:   store i32 18, i32* %msg_code, align 8, !tbaa !12
Count: 1
Found:   store i32 18, i32* %msg_code, align 8, !tbaa !12
ScheduleNode: {
  store i32 %2, i32* %arrayidx, align 4, !tbaa !15
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %2, i32* %arrayidx, align 4, !tbaa !15
Count: 1
Found:   store i32 %2, i32* %arrayidx, align 4, !tbaa !15
I:   %4 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !11
Last:   br label %if.end
Schedulable: 1
Loop Rolling: jpeg_write_marker
Generating tree
Generating MATCH
Match: 
  store i32 18, i32* %msg_code, align 8, !tbaa !12
  store i32 %2, i32* %arrayidx, align 4, !tbaa !15
Generating ALTSEQ
Values:
i32 18
  %2 = phi i32 [ %.pre, %entry.if.then_crit_edge ], [ %1, %lor.lhs.false ]
Generated Version 4:
  %10 = icmp eq i8 %9, 0
  %11 = select i1 %10, i32 18, i32 %2
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %3, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %12 = select i1 %10, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %11, i32* %12, align 1
Gen:   store i32 %11, i32* %12, align 1
Graph code generated!
Root:
  store i32 18, i32* %msg_code, align 8, !tbaa !12
  store i32 %2, i32* %arrayidx, align 4, !tbaa !15
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 18, %2", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jpeg_write_marker
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 0/1
Optimizing: jpeg_write_tables
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Creating Node
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 18
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
Count: 1
Start:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Processing:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Count: 1
Found:   store i32 18, i32* %msg_code, align 8, !tbaa !11
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Count: 1
Found:   store i32 %0, i32* %arrayidx, align 4, !tbaa !14
I:   %2 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !10
Last:   br label %if.end
Schedulable: 1
Loop Rolling: jpeg_write_tables
Generating tree
Generating MATCH
Match: 
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Generated Version 4:
  %14 = icmp eq i8 %13, 0
  %15 = select i1 %14, i32 18, i32 %0
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %16 = select i1 %14, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %15, i32* %16, align 1
Gen:   store i32 %15, i32* %16, align 1
Graph code generated!
Root:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 18, %0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jpeg_write_tables
Trying AGAIN
Trying AGAIN
  %.pre-phi = phi %struct.jpeg_common_struct* [ %.pre, %entry.if.end_crit_edge ], [ %4, %if.then ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call void @jpeg_abort(%struct.jpeg_common_struct* %.pre-phi) #4
Attempting Group:
  tail call void @jinit_marker_writer(%struct.jpeg_compress_struct* nonnull %cinfo) #4
Done Loop Roller: 0/1
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jcsample.c -o src/jcsample.o   -mllvm -reroll-loops=3
Optimizing: jinit_downsampler
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_compress_struct*)* @start_pass_downsample, void (%struct.jpeg_compress_struct*)** %start_pass2, align 8, !tbaa !14
Attempting Group:
  store i8* %call, i8** %3, align 8, !tbaa !13
looking for reduction
looking for reduction
Attempting Group:
  store i32 23, i32* %msg_code, align 8, !tbaa !21
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.end ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %incdec.ptr, %for.inc ], [ %9, %if.end ]
  %smoothok.0 = phi i32 [ %smoothok.1, %for.inc ], [ 1, %if.end ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_compress_struct*, %struct.jpeg_component_info*, i8**, i8**)* @fullsize_smooth_downsample, void (%struct.jpeg_compress_struct*, %struct.jpeg_component_info*, i8**, i8**)** %arrayidx, align 8, !tbaa !32
looking for reduction
Attempting Group:
  store void (%struct.jpeg_compress_struct*, %struct.jpeg_component_info*, i8**, i8**)* @fullsize_downsample, void (%struct.jpeg_compress_struct*, %struct.jpeg_component_info*, i8**, i8**)** %arrayidx16, align 8, !tbaa !32
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_compress_struct*, %struct.jpeg_component_info*, i8**, i8**)* @h2v1_downsample, void (%struct.jpeg_compress_struct*, %struct.jpeg_component_info*, i8**, i8**)** %arrayidx29, align 8, !tbaa !32
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_compress_struct*, %struct.jpeg_component_info*, i8**, i8**)* @h2v2_smooth_downsample, void (%struct.jpeg_compress_struct*, %struct.jpeg_component_info*, i8**, i8**)** %arrayidx46, align 8, !tbaa !32
looking for reduction
Attempting Group:
  store void (%struct.jpeg_compress_struct*, %struct.jpeg_component_info*, i8**, i8**)* @h2v2_downsample, void (%struct.jpeg_compress_struct*, %struct.jpeg_component_info*, i8**, i8**)** %arrayidx52, align 8, !tbaa !32
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store void (%struct.jpeg_compress_struct*, %struct.jpeg_component_info*, i8**, i8**)* @int_downsample, void (%struct.jpeg_compress_struct*, %struct.jpeg_component_info*, i8**, i8**)** %arrayidx66, align 8, !tbaa !32
looking for reduction
looking for reduction
Attempting Group:
  store i32 37, i32* %msg_code69, align 8, !tbaa !21
  %smoothok.1 = phi i32 [ %smoothok.0, %if.then11 ], [ %smoothok.0, %if.else ], [ 0, %if.then26 ], [ %smoothok.0, %if.then43 ], [ %smoothok.0, %if.else49 ], [ 0, %if.then63 ], [ %smoothok.0, %if.else67 ]
  %smoothok.0.lcssa = phi i32 [ %smoothok.0, %for.cond ]
looking for reduction
  %or.cond = or i1 %tobool79, %tobool77
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 98, i32* %msg_code82, align 8, !tbaa !21
looking for reduction
Done Loop Roller: 0/0
Nothing found in: jinit_downsampler
Optimizing: start_pass_downsample
looking for reduction
Done Loop Roller: 0/0
Nothing found in: start_pass_downsample
Optimizing: sep_downsample
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %compptr.0 = phi %struct.jpeg_component_info* [ %incdec.ptr, %for.body ], [ %2, %entry ]
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Done Loop Roller: 0/0
Nothing found in: sep_downsample
Optimizing: expand_right_edge
looking for reduction
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc6 ]
looking for reduction
  %count.0 = phi i32 [ %sub, %for.body ], [ %dec, %for.body5 ]
  %ptr.0 = phi i8* [ %add.ptr, %for.body ], [ %incdec.ptr, %for.body5 ]
looking for reduction
looking for reduction
Attempting Group:
  store i8 %2, i8* %ptr.0, align 1, !tbaa !6
looking for reduction
Done Loop Roller: 0/0
Nothing found in: expand_right_edge
Optimizing: fullsize_smooth_downsample
looking for reduction
looking for reduction
  %add = add nsw i32 %1, 2
looking for reduction
looking for reduction
  %mul = shl i32 %0, 3
Attempting Group:
  tail call fastcc void @expand_right_edge(i8** nonnull %add.ptr, i32 %add, i32 %2, i32 %mul) #4
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.end ], [ 0, %entry ]
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv38, i8* %6, align 1, !tbaa !16
  %inptr.0 = phi i8* [ %incdec.ptr20, %for.body ], [ %incdec.ptr45, %for.body44 ]
  %above_ptr.0 = phi i8* [ %incdec.ptr, %for.body ], [ %incdec.ptr48, %for.body44 ]
  %below_ptr.0 = phi i8* [ %incdec.ptr15, %for.body ], [ %incdec.ptr49, %for.body44 ]
  %.pn = phi i8* [ %6, %for.body ], [ %outptr.0, %for.body44 ]
  %colctr.0 = phi i32 [ %sub40, %for.body ], [ %dec, %for.body44 ]
  %colsum.0 = phi i32 [ %add27, %for.body ], [ %add54, %for.body44 ]
  %lastcolsum.0 = phi i32 [ %add19, %for.body ], [ %colsum.0, %for.body44 ]
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv66, i8* %outptr.0, align 1, !tbaa !16
  %inptr.0.lcssa = phi i8* [ %inptr.0, %for.cond41 ]
  %colsum.0.lcssa = phi i32 [ %colsum.0, %for.cond41 ]
  %lastcolsum.0.lcssa = phi i32 [ %lastcolsum.0, %for.cond41 ]
  %outptr.0.lcssa = phi i8* [ %outptr.0, %for.cond41 ]
looking for reduction
Attempting Group:
  store i8 %conv81, i8* %outptr.0.lcssa, align 1, !tbaa !16
looking for reduction
Done Loop Roller: 0/0
Nothing found in: fullsize_smooth_downsample
Optimizing: fullsize_downsample
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul = shl i32 %4, 3
looking for reduction
Attempting Group:
  tail call fastcc void @expand_right_edge(i8** %output_data, i32 %2, i32 %3, i32 %mul) #5
Attempting Group:
  tail call void @jcopy_sample_rows(i8** %input_data, i32 0, i8** %output_data, i32 0, i32 %0, i32 %1) #4
Done Loop Roller: 0/0
Nothing found in: fullsize_downsample
Optimizing: h2v1_downsample
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul1 = shl i32 %0, 4
Attempting Group:
  tail call fastcc void @expand_right_edge(i8** %input_data, i32 %1, i32 %2, i32 %mul1) #4
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc11 ], [ 0, %entry ]
looking for reduction
  %outcol.0 = phi i32 [ 0, %for.body ], [ %inc, %for.body6 ]
  %inptr.0 = phi i8* [ %6, %for.body ], [ %add.ptr, %for.body6 ]
  %outptr.0 = phi i8* [ %5, %for.body ], [ %incdec.ptr, %for.body6 ]
  %bias.0 = phi i32 [ 0, %for.body ], [ %xor, %for.body6 ]
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv10, i8* %outptr.0, align 1, !tbaa !15
looking for reduction
Done Loop Roller: 0/0
Nothing found in: h2v1_downsample
Optimizing: h2v2_smooth_downsample
looking for reduction
looking for reduction
  %add = add nsw i32 %1, 2
looking for reduction
looking for reduction
  %mul1 = shl i32 %0, 4
Attempting Group:
  tail call fastcc void @expand_right_edge(i8** nonnull %add.ptr, i32 %add, i32 %2, i32 %mul1) #4
  %indvars.iv289 = phi i64 [ %indvars.iv.next290, %for.end ], [ 0, %entry ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.end ], [ 0, %entry ]
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv64, i8* %6, align 1, !tbaa !16
  %colctr.0 = phi i32 [ %sub69, %for.body ], [ %dec, %for.body73 ]
  %inptr0.0 = phi i8* [ %arrayidx39, %for.body ], [ %arrayidx96, %for.body73 ]
  %inptr1.0 = phi i8* [ %arrayidx44, %for.body ], [ %arrayidx102, %for.body73 ]
  %above_ptr.0 = phi i8* [ %arrayidx50, %for.body ], [ %arrayidx109, %for.body73 ]
  %below_ptr.0 = phi i8* [ %arrayidx55, %for.body ], [ %arrayidx115, %for.body73 ]
  %.pn = phi i8* [ %6, %for.body ], [ %outptr.0, %for.body73 ]
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv125, i8* %outptr.0, align 1, !tbaa !16
  %inptr0.0.lcssa = phi i8* [ %inptr0.0, %for.cond70 ]
  %inptr1.0.lcssa = phi i8* [ %inptr1.0, %for.cond70 ]
  %above_ptr.0.lcssa = phi i8* [ %above_ptr.0, %for.cond70 ]
  %below_ptr.0.lcssa = phi i8* [ %below_ptr.0, %for.cond70 ]
  %outptr.0.lcssa = phi i8* [ %outptr.0, %for.cond70 ]
looking for reduction
Attempting Group:
  store i8 %conv182, i8* %outptr.0.lcssa, align 1, !tbaa !16
looking for reduction
Done Loop Roller: 0/0
Nothing found in: h2v2_smooth_downsample
Optimizing: h2v2_downsample
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul1 = shl i32 %0, 4
Attempting Group:
  tail call fastcc void @expand_right_edge(i8** %input_data, i32 %1, i32 %2, i32 %mul1) #4
  %indvars.iv47 = phi i64 [ %indvars.iv.next48, %for.end ], [ 0, %entry ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.end ], [ 0, %entry ]
looking for reduction
  %outcol.0 = phi i32 [ 0, %for.body ], [ %inc, %for.body8 ]
  %inptr0.0 = phi i8* [ %6, %for.body ], [ %add.ptr, %for.body8 ]
  %inptr1.0 = phi i8* [ %8, %for.body ], [ %add.ptr19, %for.body8 ]
  %outptr.0 = phi i8* [ %5, %for.body ], [ %incdec.ptr, %for.body8 ]
  %bias.0 = phi i32 [ 1, %for.body ], [ %xor, %for.body8 ]
looking for reduction
looking for reduction
Attempting Group:
  store i8 %conv18, i8* %outptr.0, align 1, !tbaa !15
looking for reduction
Done Loop Roller: 0/0
Nothing found in: h2v2_downsample
Optimizing: int_downsample
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %mul5 = mul i32 %div, %mul
Attempting Group:
  tail call fastcc void @expand_right_edge(i8** %input_data, i32 %3, i32 %5, i32 %mul5) #4
  %indvars.iv80 = phi i64 [ %indvars.iv.next81, %for.end32 ], [ 0, %entry ]
  %indvars.iv78 = phi i64 [ %indvars.iv.next79, %for.end32 ], [ 0, %entry ]
looking for reduction
  %outcol.0 = phi i32 [ 0, %for.body ], [ %inc30, %for.end22 ]
  %outcol_h.0 = phi i32 [ 0, %for.body ], [ %add31, %for.end22 ]
  %outptr.0 = phi i8* [ %11, %for.body ], [ %incdec.ptr28, %for.end22 ]
looking for reduction
  %indvars.iv = phi i64 [ 0, %for.cond10.preheader ], [ %indvars.iv.next, %for.inc20 ]
  %outvalue.0 = phi i64 [ 0, %for.cond10.preheader ], [ %outvalue.1.lcssa, %for.inc20 ]
looking for reduction
  %h.0 = phi i32 [ 0, %for.body12 ], [ %inc, %for.body17 ]
  %inptr.0 = phi i8* [ %add.ptr, %for.body12 ], [ %incdec.ptr, %for.body17 ]
  %outvalue.1 = phi i64 [ %outvalue.0, %for.body12 ], [ %add19, %for.body17 ]
looking for reduction
  %outvalue.1.lcssa = phi i64 [ %outvalue.1, %for.cond15 ]
  %outvalue.0.lcssa = phi i64 [ %outvalue.0, %for.cond10 ]
looking for reduction
Attempting Group:
  store i8 %conv27, i8* %outptr.0, align 1, !tbaa !17
looking for reduction
Done Loop Roller: 0/0
Nothing found in: int_downsample
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/rdrle.c -o src/rdrle.o   -mllvm -reroll-loops=3
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang -std=gnu89 -B /usr/bin -Oz -fno-unroll-loops -fno-vectorize -fno-slp-vectorize  -c src/jcapistd.c -o src/jcapistd.o   -mllvm -reroll-loops=3
Optimizing: jpeg_start_compress
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Creating Node
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 18
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
Count: 1
Start:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Processing:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Count: 1
Found:   store i32 18, i32* %msg_code, align 8, !tbaa !11
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Count: 1
Found:   store i32 %0, i32* %arrayidx, align 4, !tbaa !14
I:   %2 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !10
Last:   br label %if.end
Schedulable: 1
Loop Rolling: jpeg_start_compress
Generating tree
Generating MATCH
Match: 
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Generated Version 4:
  %14 = icmp eq i8 %13, 0
  %15 = select i1 %14, i32 18, i32 %0
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %16 = select i1 %14, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %15, i32* %16, align 1
Gen:   store i32 %15, i32* %16, align 1
Graph code generated!
Root:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 18, %0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jpeg_start_compress
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  tail call void @jpeg_suppress_tables(%struct.jpeg_compress_struct* nonnull %cinfo, i32 0) #3
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 0, i32* %next_scanline, align 8, !tbaa !23
  store i32 %cond, i32* %global_state, align 4, !tbaa !2
Attempting Group:
  tail call void @jinit_compress_master(%struct.jpeg_compress_struct* nonnull %cinfo) #3
Creating Node
  store i32 0, i32* %next_scanline, align 8, !tbaa !23
  store i32 %cond, i32* %global_state, align 4, !tbaa !2
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 0
  %cond = select i1 %tobool7.not, i32 101, i32 102
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 0
Alt Seq
Creating Node
  %next_scanline = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 36
  %global_state = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 4
Match: 0
2 x 2
Final Match: 0
  %next_scanline = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 36
  %global_state = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 4
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %next_scanline = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 36
Alt Seq
ScheduleNode: {
  store i32 0, i32* %next_scanline, align 8, !tbaa !23
}
ScheduleNode: {
  store i32 %cond, i32* %global_state, align 4, !tbaa !2
}
ScheduleNode: {
  store i32 0, i32* %next_scanline, align 8, !tbaa !23
}
Count: 1
Start:   store i32 0, i32* %next_scanline, align 8, !tbaa !23
Processing:   store i32 0, i32* %next_scanline, align 8, !tbaa !23
Count: 1
Found:   store i32 0, i32* %next_scanline, align 8, !tbaa !23
ScheduleNode: {
  store i32 %cond, i32* %global_state, align 4, !tbaa !2
}
Non-memory:   %raw_data_in = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 23
Processing:   %12 = load i32, i32* %raw_data_in, align 8, !tbaa !24
Count: 1
Not found:   %12 = load i32, i32* %raw_data_in, align 8, !tbaa !24
Read/Write memory
I:   %12 = load i32, i32* %raw_data_in, align 8, !tbaa !24
Last:   ret void
Schedulable: 0
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 0, %cond", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %next_scanline, %global_state", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}


if.end5:                                          ; preds = %if.then4, %if.end
  %err6 = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 0
  %5 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err6, align 8, !tbaa !10
  %reset_error_mgr = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %5, i64 0, i32 4
  %6 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %reset_error_mgr, align 8, !tbaa !16
  %7 = bitcast %struct.jpeg_compress_struct* %cinfo to %struct.jpeg_common_struct*
  tail call void %6(%struct.jpeg_common_struct* %7) #3
  %dest = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 5
  %8 = load %struct.jpeg_destination_mgr*, %struct.jpeg_destination_mgr** %dest, align 8, !tbaa !17
  %init_destination = getelementptr inbounds %struct.jpeg_destination_mgr, %struct.jpeg_destination_mgr* %8, i64 0, i32 2
  %9 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %init_destination, align 8, !tbaa !18
  tail call void %9(%struct.jpeg_compress_struct* nonnull %cinfo) #3
  tail call void @jinit_compress_master(%struct.jpeg_compress_struct* nonnull %cinfo) #3
  %master = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 51
  %10 = load %struct.jpeg_comp_master*, %struct.jpeg_comp_master** %master, align 8, !tbaa !20
  %prepare_for_pass = getelementptr inbounds %struct.jpeg_comp_master, %struct.jpeg_comp_master* %10, i64 0, i32 0
  %11 = load void (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)** %prepare_for_pass, align 8, !tbaa !21
  tail call void %11(%struct.jpeg_compress_struct* nonnull %cinfo) #3
  %next_scanline = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 36
  store i32 0, i32* %next_scanline, align 8, !tbaa !23
  %raw_data_in = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 23
  %12 = load i32, i32* %raw_data_in, align 8, !tbaa !24
  %tobool7.not = icmp eq i32 %12, 0
  %cond = select i1 %tobool7.not, i32 101, i32 102
  store i32 %cond, i32* %global_state, align 4, !tbaa !2
  ret void

Trying AGAIN
Trying AGAIN
Done Loop Roller: 0/1
Optimizing: jpeg_write_scanlines
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %1, i32* %arrayidx, align 4, !tbaa !14
Creating Node
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %1, i32* %arrayidx, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 18
  %1 = load i32, i32* %global_state, align 4, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 18
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %1, i32* %arrayidx, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
Count: 1
Start:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Processing:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Count: 1
Found:   store i32 18, i32* %msg_code, align 8, !tbaa !11
ScheduleNode: {
  store i32 %1, i32* %arrayidx, align 4, !tbaa !14
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %1, i32* %arrayidx, align 4, !tbaa !14
Count: 1
Found:   store i32 %1, i32* %arrayidx, align 4, !tbaa !14
I:   %3 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !10
Last:   br label %if.end
Schedulable: 1
Loop Rolling: jpeg_write_scanlines
Generating tree
Generating MATCH
Match: 
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %1, i32* %arrayidx, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 18
  %1 = load i32, i32* %global_state, align 4, !tbaa !2
Generated Version 4:
  %27 = icmp eq i8 %26, 0
  %28 = select i1 %27, i32 18, i32 %1
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %2, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %29 = select i1 %27, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %28, i32* %29, align 1
Gen:   store i32 %28, i32* %29, align 1
Graph code generated!
Root:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %1, i32* %arrayidx, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 18, %1", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jpeg_write_scanlines
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 119, i32* %msg_code7, align 8, !tbaa !11
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Creating Node
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv = zext i32 %13 to i64
  %conv15 = zext i32 %14 to i64
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %13 = load i32, i32* %next_scanline, align 8, !tbaa !16
  %14 = load i32, i32* %image_height, align 4, !tbaa !17
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %next_scanline = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 36
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
Match: 0
2 x 2
Final Match: 0
  %next_scanline = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 36
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
GEPSeq2
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
BinOP?
  %next_scanline = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 36
Alt Seq
Creating Node
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 2
Match: 0
2 x 2
Final Match: 0
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 2
GEPSeq2
%struct.jpeg_progress_mgr = type { {}*, i64, i64, i32, i32 }
BinOP?
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 1
Alt Seq
ScheduleNode: {
  %13 = load i32, i32* %next_scanline, align 8, !tbaa !16
}
ScheduleNode: {
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
}
ScheduleNode: {
  %14 = load i32, i32* %image_height, align 4, !tbaa !17
}
ScheduleNode: {
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
}
ScheduleNode: {
  %13 = load i32, i32* %next_scanline, align 8, !tbaa !16
}
Count: 1
Start:   %13 = load i32, i32* %next_scanline, align 8, !tbaa !16
Processing:   %13 = load i32, i32* %next_scanline, align 8, !tbaa !16
Count: 1
Found:   %13 = load i32, i32* %next_scanline, align 8, !tbaa !16
ScheduleNode: {
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
}
Non-memory:   %conv = zext i32 %13 to i64
Non-memory:   %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 1
Processing:   store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
Count: 1
Found:   store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
ScheduleNode: {
  %14 = load i32, i32* %image_height, align 4, !tbaa !17
}
Processing:   %14 = load i32, i32* %image_height, align 4, !tbaa !17
Count: 1
Found:   %14 = load i32, i32* %image_height, align 4, !tbaa !17
ScheduleNode: {
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
}
Non-memory:   %conv15 = zext i32 %14 to i64
Non-memory:   %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 2
Processing:   store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Count: 1
Found:   store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
I:   %15 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %12, align 8, !tbaa !23
Last:   br label %if.end19
Schedulable: 1
Loop Rolling: jpeg_write_scanlines
Generating tree
Generating MATCH
Match: 
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Generating MATCH
Match: 
  %conv = zext i32 %13 to i64
  %conv15 = zext i32 %14 to i64
Generating MATCH
Match: 
  %13 = load i32, i32* %next_scanline, align 8, !tbaa !16
  %14 = load i32, i32* %image_height, align 4, !tbaa !17
Generating ALTSEQ
Values:
  %next_scanline = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 36
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct, %struct.jpeg_compress_struct* %cinfo, i64 0, i32 7
Generated Version 4:
  %27 = icmp eq i8 %26, 0
  %28 = select i1 %27, i32* %next_scanline, i32* %image_height
Operands done!
Generated:   %29 = load i32, i32* %28, align 1
Gen:   %29 = load i32, i32* %28, align 1
Operands done!
Generated:   %30 = zext i32 %29 to i64
Gen:   %30 = zext i32 %29 to i64
Generating ALTSEQ
Values:
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %11, i64 0, i32 2
Generated Version 4:
  %31 = select i1 %27, i64* %pass_counter, i64* %pass_limit
Operands done!
Generated:   store i64 %30, i64* %31, align 1
Gen:   store i64 %30, i64* %31, align 1
Graph code generated!
Root:
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="load", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %next_scanline, %image_height", style="filled" , fillcolor="#8ae18a", shape=box];
4 [label="alt: %pass_counter, %pass_limit", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
4->0 
2->1 
3->2 
}

Gains: 10 - 9 = 1; Width: 2; Unprofitable; jpeg_write_scanlines
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add = add i32 %25, %24
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 %add, i32* %next_scanline, align 8, !tbaa !16
Attempting Group:
  store i32 0, i32* %row_ctr, align 4, !tbaa !28
Done Loop Roller: 0/2
Optimizing: jpeg_write_raw_data
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Creating Node
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
i32 18
Alt Seq
Creating Node
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Match: 0
2 x 2
Final Match: 0
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
GEPSeq2
BinOP?
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
Alt Seq
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
}
ScheduleNode: {
  store i32 18, i32* %msg_code, align 8, !tbaa !11
}
Count: 1
Start:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Processing:   store i32 18, i32* %msg_code, align 8, !tbaa !11
Count: 1
Found:   store i32 18, i32* %msg_code, align 8, !tbaa !11
ScheduleNode: {
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
}
Non-memory:   %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Processing:   store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Count: 1
Found:   store i32 %0, i32* %arrayidx, align 4, !tbaa !14
I:   %2 = load %struct.jpeg_error_mgr*, %struct.jpeg_error_mgr** %err, align 8, !tbaa !10
Last:   br label %if.end
Schedulable: 1
Loop Rolling: jpeg_write_raw_data
Generating tree
Generating MATCH
Match: 
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Generating ALTSEQ
Values:
i32 18
  %0 = load i32, i32* %global_state, align 4, !tbaa !2
Generated Version 4:
  %25 = icmp eq i8 %24, 0
  %26 = select i1 %25, i32 18, i32 %0
Generating ALTSEQ
Values:
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 5
  %arrayidx = getelementptr inbounds %struct.jpeg_error_mgr, %struct.jpeg_error_mgr* %1, i64 0, i32 6, i32 0, i64 0
Generated Version 4:
  %27 = select i1 %25, i32* %msg_code, i32* %arrayidx
Operands done!
Generated:   store i32 %26, i32* %27, align 1
Gen:   store i32 %26, i32* %27, align 1
Graph code generated!
Root:
  store i32 18, i32* %msg_code, align 8, !tbaa !11
  store i32 %0, i32* %arrayidx, align 4, !tbaa !14
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="alt: 18, %0", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %msg_code, %arrayidx", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
2->0 
}

Gains: 4 - 6 = -2; Width: 2; Unprofitable; jpeg_write_raw_data
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 119, i32* %msg_code7, align 8, !tbaa !11
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Creating Node
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %conv = zext i32 %5 to i64
  %conv15 = zext i32 %6 to i64
Match: 1
2 x 2
Final Match: 1
Matching
Creating Node
  %5 = load i32, i32* %next_scanline, align 8, !tbaa !16
  %6 = load i32, i32* %image_height, align 4, !tbaa !17
Match: 0
2 x 2
Final Match: 0
GEPSeq2
BinOP?
  %5 = load i32, i32* %next_scanline, align 8, !tbaa !16
Alt Seq
Creating Node
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 2
Match: 0
2 x 2
Final Match: 0
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 2
GEPSeq2
%struct.jpeg_progress_mgr = type { {}*, i64, i64, i32, i32 }
BinOP?
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 1
Alt Seq
ScheduleNode: {
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
}
ScheduleNode: {
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
}
ScheduleNode: {
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
}
Count: 1
Start:   %conv = zext i32 %5 to i64
Non-memory:   %conv = zext i32 %5 to i64
Non-memory:   %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 1
Processing:   store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
Count: 1
Found:   store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
ScheduleNode: {
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
}
Non-memory:   %conv15 = zext i32 %6 to i64
Non-memory:   %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 2
Processing:   store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Count: 1
Found:   store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
I:   %12 = load void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*)** %11, align 8, !tbaa !23
Last:   br label %if.end19
Schedulable: 1
Loop Rolling: jpeg_write_raw_data
Generating tree
Generating MATCH
Match: 
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Generating MATCH
Match: 
  %conv = zext i32 %5 to i64
  %conv15 = zext i32 %6 to i64
Generating ALTSEQ
Values:
  %5 = load i32, i32* %next_scanline, align 8, !tbaa !16
  %6 = load i32, i32* %image_height, align 4, !tbaa !17
Generated Version 4:
  %25 = icmp eq i8 %24, 0
  %26 = select i1 %25, i32 %5, i32 %6
Operands done!
Generated:   %27 = zext i32 %26 to i64
Gen:   %27 = zext i32 %26 to i64
Generating ALTSEQ
Values:
  %pass_counter = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 1
  %pass_limit = getelementptr inbounds %struct.jpeg_progress_mgr, %struct.jpeg_progress_mgr* %10, i64 0, i32 2
Generated Version 4:
  %28 = select i1 %25, i64* %pass_counter, i64* %pass_limit
Operands done!
Generated:   store i64 %27, i64* %28, align 1
Gen:   store i64 %27, i64* %28, align 1
Graph code generated!
Root:
  store i64 %conv, i64* %pass_counter, align 8, !tbaa !20
  store i64 %conv15, i64* %pass_limit, align 8, !tbaa !22
Root size: 2
digraph VTree {
0 [label="store", style="filled" , fillcolor="#8ae18a", shape=box];
1 [label="zext", style="filled" , fillcolor="#8ae18a", shape=box];
2 [label="alt: %5, %6", style="filled" , fillcolor="#8ae18a", shape=box];
3 [label="alt: %pass_counter, %pass_limit", style="filled" , fillcolor="#8ae18a", shape=box];
1->0 
3->0 
2->1 
}

Gains: 6 - 7 = -1; Width: 2; Unprofitable; jpeg_write_raw_data
Trying AGAIN
Trying AGAIN
looking for reduction
looking for reduction
looking for reduction
looking for reduction
looking for reduction
Attempting Group:
  store i32 21, i32* %msg_code27, align 8, !tbaa !11
looking for reduction
looking for reduction
looking for reduction
looking for reduction
  %add = add i32 %23, %mul
Attempting Group:
  store i32 %add, i32* %next_scanline, align 8, !tbaa !16
  %retval.0 = phi i32 [ 0, %if.then5 ], [ %mul, %if.end33 ], [ 0, %if.end30 ]
looking for reduction
Done Loop Roller: 0/2
/home/rodrigo/llvm/loop-rerolling/build/release/bin/clang++ -std=gnu++98 -B /usr/bin src/jidctfst.o src/jccolor.o src/jchuff.o src/jidctred.o src/rdppm.o src/jdmarker.o src/jutils.o src/jmemansi.o src/jcinit.o src/jdpostct.o src/jcmainct.o src/jdapimin.o src/jdmaster.o src/jmemmgr.o src/jquant2.o src/jerror.o src/jquant1.o src/jctrans.o src/rdtarga.o src/jcprepct.o src/jfdctfst.o src/ctuning-rtl.o src/jdcolor.o src/jcphuff.o src/jddctmgr.o src/jcomapi.o src/cdjpeg.o src/jdphuff.o src/jidctflt.o src/jcsample.o src/jcparam.o src/rdbmp.o src/jdmainct.o src/jfdctflt.o src/jfdctint.o src/jdmerge.o src/rdswitch.o src/jcdctmgr.o src/cjpeg.o src/jccoefct.o src/rdgif.o src/jdtrans.o src/jdcoefct.o src/jdatasrc.o src/jdapistd.o src/jcmarker.o src/jdsample.o src/jcapimin.o src/jcmaster.o src/jdhuff.o src/jdinput.o src/jdatadst.o src/jidctint.o src/rdrle.o src/jcapistd.o -Oz  -mllvm -reroll-loops=3 -o build/rolled -lm -fno-align-functions -s
clang-12: warning: argument unused during compilation: '-mllvm -reroll-loops=3' [-Wunused-command-line-argument]
#du -bc src/jidctfst.o src/jccolor.o src/jchuff.o src/jidctred.o src/rdppm.o src/jdmarker.o src/jutils.o src/jmemansi.o src/jcinit.o src/jdpostct.o src/jcmainct.o src/jdapimin.o src/jdmaster.o src/jmemmgr.o src/jquant2.o src/jerror.o src/jquant1.o src/jctrans.o src/rdtarga.o src/jcprepct.o src/jfdctfst.o src/ctuning-rtl.o src/jdcolor.o src/jcphuff.o src/jddctmgr.o src/jcomapi.o src/cdjpeg.o src/jdphuff.o src/jidctflt.o src/jcsample.o src/jcparam.o src/rdbmp.o src/jdmainct.o src/jfdctflt.o src/jfdctint.o src/jdmerge.o src/rdswitch.o src/jcdctmgr.o src/cjpeg.o src/jccoefct.o src/rdgif.o src/jdtrans.o src/jdcoefct.o src/jdatasrc.o src/jdapistd.o src/jcmarker.o src/jdsample.o src/jcapimin.o src/jcmaster.o src/jdhuff.o src/jdinput.o src/jdatadst.o src/jidctint.o src/rdrle.o src/jcapistd.o | awk 'END { print  }' > build/rolled.osize
/home/rodrigo/llvm/loop-rerolling/build/release/bin/llvm-size -B -d build/rolled
   text	   data	    bss	    dec	    hex	filename
 123763	    760	     72	 124595	  1e6b3	build/rolled
